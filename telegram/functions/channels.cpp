// This file generated by libqtelegram-code-generator.
// You can download it from: https://github.com/Aseman-Land/libqtelegram-code-generator
// DO NOT EDIT THIS FILE BY HAND -- YOUR CHANGES WILL BE OVERWRITTEN

#include "channels.h"
#include "core/inboundpkt.h"
#include "core/outboundpkt.h"
#include "../coretypes.h"

using namespace Tg;

Functions::Channels::Channels() {
}

Functions::Channels::~Channels() {
}

bool Functions::Channels::getDialogs(OutboundPkt *out, qint32 offset, qint32 limit) {
    out->appendInt(fncChannelsGetDialogs);
    out->appendInt(offset);
    out->appendInt(limit);
    return true;
}

MessagesDialogs Functions::Channels::getDialogsResult(InboundPkt *in) {
    MessagesDialogs result;
    if(!result.fetch(in)) return result;
    return result;
}

bool Functions::Channels::getImportantHistory(OutboundPkt *out, const InputChannel &channel, qint32 offsetId, qint32 offsetDate, qint32 addOffset, qint32 limit, qint32 maxId, qint32 minId) {
    out->appendInt(fncChannelsGetImportantHistory);
    if(!channel.push(out)) return false;
    out->appendInt(offsetId);
    out->appendInt(offsetDate);
    out->appendInt(addOffset);
    out->appendInt(limit);
    out->appendInt(maxId);
    out->appendInt(minId);
    return true;
}

MessagesMessages Functions::Channels::getImportantHistoryResult(InboundPkt *in) {
    MessagesMessages result;
    if(!result.fetch(in)) return result;
    return result;
}

bool Functions::Channels::readHistory(OutboundPkt *out, const InputChannel &channel, qint32 maxId) {
    out->appendInt(fncChannelsReadHistory);
    if(!channel.push(out)) return false;
    out->appendInt(maxId);
    return true;
}

bool Functions::Channels::readHistoryResult(InboundPkt *in) {
    bool result;
    result = in->fetchBool();
    return result;
}

bool Functions::Channels::deleteMessages(OutboundPkt *out, const InputChannel &channel, const QList<qint32> &id) {
    out->appendInt(fncChannelsDeleteMessages);
    if(!channel.push(out)) return false;
    out->appendInt(CoreTypes::typeVector);
    out->appendInt(id.count());
    for (qint32 i = 0; i < id.count(); i++) {
        out->appendInt(id[i]);
    }
    return true;
}

MessagesAffectedMessages Functions::Channels::deleteMessagesResult(InboundPkt *in) {
    MessagesAffectedMessages result;
    if(!result.fetch(in)) return result;
    return result;
}

bool Functions::Channels::deleteUserHistory(OutboundPkt *out, const InputChannel &channel, const InputUser &userId) {
    out->appendInt(fncChannelsDeleteUserHistory);
    if(!channel.push(out)) return false;
    if(!userId.push(out)) return false;
    return true;
}

MessagesAffectedHistory Functions::Channels::deleteUserHistoryResult(InboundPkt *in) {
    MessagesAffectedHistory result;
    if(!result.fetch(in)) return result;
    return result;
}

bool Functions::Channels::reportSpam(OutboundPkt *out, const InputChannel &channel, const InputUser &userId, const QList<qint32> &id) {
    out->appendInt(fncChannelsReportSpam);
    if(!channel.push(out)) return false;
    if(!userId.push(out)) return false;
    out->appendInt(CoreTypes::typeVector);
    out->appendInt(id.count());
    for (qint32 i = 0; i < id.count(); i++) {
        out->appendInt(id[i]);
    }
    return true;
}

bool Functions::Channels::reportSpamResult(InboundPkt *in) {
    bool result;
    result = in->fetchBool();
    return result;
}

bool Functions::Channels::getMessages(OutboundPkt *out, const InputChannel &channel, const QList<qint32> &id) {
    out->appendInt(fncChannelsGetMessages);
    if(!channel.push(out)) return false;
    out->appendInt(CoreTypes::typeVector);
    out->appendInt(id.count());
    for (qint32 i = 0; i < id.count(); i++) {
        out->appendInt(id[i]);
    }
    return true;
}

MessagesMessages Functions::Channels::getMessagesResult(InboundPkt *in) {
    MessagesMessages result;
    if(!result.fetch(in)) return result;
    return result;
}

bool Functions::Channels::getParticipants(OutboundPkt *out, const InputChannel &channel, const ChannelParticipantsFilter &filter, qint32 offset, qint32 limit) {
    out->appendInt(fncChannelsGetParticipants);
    if(!channel.push(out)) return false;
    if(!filter.push(out)) return false;
    out->appendInt(offset);
    out->appendInt(limit);
    return true;
}

ChannelsChannelParticipants Functions::Channels::getParticipantsResult(InboundPkt *in) {
    ChannelsChannelParticipants result;
    if(!result.fetch(in)) return result;
    return result;
}

bool Functions::Channels::getParticipant(OutboundPkt *out, const InputChannel &channel, const InputUser &userId) {
    out->appendInt(fncChannelsGetParticipant);
    if(!channel.push(out)) return false;
    if(!userId.push(out)) return false;
    return true;
}

ChannelsChannelParticipant Functions::Channels::getParticipantResult(InboundPkt *in) {
    ChannelsChannelParticipant result;
    if(!result.fetch(in)) return result;
    return result;
}

bool Functions::Channels::getChannels(OutboundPkt *out, const QList<InputChannel> &id) {
    out->appendInt(fncChannelsGetChannels);
    out->appendInt(CoreTypes::typeVector);
    out->appendInt(id.count());
    for (qint32 i = 0; i < id.count(); i++) {
        if(!id[i].push(out)) return false;
    }
    return true;
}

MessagesChats Functions::Channels::getChannelsResult(InboundPkt *in) {
    MessagesChats result;
    if(!result.fetch(in)) return result;
    return result;
}

bool Functions::Channels::getFullChannel(OutboundPkt *out, const InputChannel &channel) {
    out->appendInt(fncChannelsGetFullChannel);
    if(!channel.push(out)) return false;
    return true;
}

MessagesChatFull Functions::Channels::getFullChannelResult(InboundPkt *in) {
    MessagesChatFull result;
    if(!result.fetch(in)) return result;
    return result;
}

bool Functions::Channels::createChannel(OutboundPkt *out, bool broadcast, bool megagroup, const QString &title, const QString &about) {
    out->appendInt(fncChannelsCreateChannel);
    
    qint32 flags = 0;
    if(broadcast != 0) flags = (1<<0 | flags);
    if(megagroup != 0) flags = (1<<1 | flags);
    
    out->appendInt(flags);
    out->appendQString(title);
    out->appendQString(about);
    return true;
}

UpdatesType Functions::Channels::createChannelResult(InboundPkt *in) {
    UpdatesType result;
    if(!result.fetch(in)) return result;
    return result;
}

bool Functions::Channels::editAbout(OutboundPkt *out, const InputChannel &channel, const QString &about) {
    out->appendInt(fncChannelsEditAbout);
    if(!channel.push(out)) return false;
    out->appendQString(about);
    return true;
}

bool Functions::Channels::editAboutResult(InboundPkt *in) {
    bool result;
    result = in->fetchBool();
    return result;
}

bool Functions::Channels::editAdmin(OutboundPkt *out, const InputChannel &channel, const InputUser &userId, const ChannelParticipantRole &role) {
    out->appendInt(fncChannelsEditAdmin);
    if(!channel.push(out)) return false;
    if(!userId.push(out)) return false;
    if(!role.push(out)) return false;
    return true;
}

UpdatesType Functions::Channels::editAdminResult(InboundPkt *in) {
    UpdatesType result;
    if(!result.fetch(in)) return result;
    return result;
}

bool Functions::Channels::editTitle(OutboundPkt *out, const InputChannel &channel, const QString &title) {
    out->appendInt(fncChannelsEditTitle);
    if(!channel.push(out)) return false;
    out->appendQString(title);
    return true;
}

UpdatesType Functions::Channels::editTitleResult(InboundPkt *in) {
    UpdatesType result;
    if(!result.fetch(in)) return result;
    return result;
}

bool Functions::Channels::editPhoto(OutboundPkt *out, const InputChannel &channel, const InputChatPhoto &photo) {
    out->appendInt(fncChannelsEditPhoto);
    if(!channel.push(out)) return false;
    if(!photo.push(out)) return false;
    return true;
}

UpdatesType Functions::Channels::editPhotoResult(InboundPkt *in) {
    UpdatesType result;
    if(!result.fetch(in)) return result;
    return result;
}

bool Functions::Channels::toggleComments(OutboundPkt *out, const InputChannel &channel, bool enabled) {
    out->appendInt(fncChannelsToggleComments);
    if(!channel.push(out)) return false;
    out->appendBool(enabled);
    return true;
}

UpdatesType Functions::Channels::toggleCommentsResult(InboundPkt *in) {
    UpdatesType result;
    if(!result.fetch(in)) return result;
    return result;
}

bool Functions::Channels::checkUsername(OutboundPkt *out, const InputChannel &channel, const QString &username) {
    out->appendInt(fncChannelsCheckUsername);
    if(!channel.push(out)) return false;
    out->appendQString(username);
    return true;
}

bool Functions::Channels::checkUsernameResult(InboundPkt *in) {
    bool result;
    result = in->fetchBool();
    return result;
}

bool Functions::Channels::updateUsername(OutboundPkt *out, const InputChannel &channel, const QString &username) {
    out->appendInt(fncChannelsUpdateUsername);
    if(!channel.push(out)) return false;
    out->appendQString(username);
    return true;
}

bool Functions::Channels::updateUsernameResult(InboundPkt *in) {
    bool result;
    result = in->fetchBool();
    return result;
}

bool Functions::Channels::joinChannel(OutboundPkt *out, const InputChannel &channel) {
    out->appendInt(fncChannelsJoinChannel);
    if(!channel.push(out)) return false;
    return true;
}

UpdatesType Functions::Channels::joinChannelResult(InboundPkt *in) {
    UpdatesType result;
    if(!result.fetch(in)) return result;
    return result;
}

bool Functions::Channels::leaveChannel(OutboundPkt *out, const InputChannel &channel) {
    out->appendInt(fncChannelsLeaveChannel);
    if(!channel.push(out)) return false;
    return true;
}

UpdatesType Functions::Channels::leaveChannelResult(InboundPkt *in) {
    UpdatesType result;
    if(!result.fetch(in)) return result;
    return result;
}

bool Functions::Channels::inviteToChannel(OutboundPkt *out, const InputChannel &channel, const QList<InputUser> &users) {
    out->appendInt(fncChannelsInviteToChannel);
    if(!channel.push(out)) return false;
    out->appendInt(CoreTypes::typeVector);
    out->appendInt(users.count());
    for (qint32 i = 0; i < users.count(); i++) {
        if(!users[i].push(out)) return false;
    }
    return true;
}

UpdatesType Functions::Channels::inviteToChannelResult(InboundPkt *in) {
    UpdatesType result;
    if(!result.fetch(in)) return result;
    return result;
}

bool Functions::Channels::kickFromChannel(OutboundPkt *out, const InputChannel &channel, const InputUser &userId, bool kicked) {
    out->appendInt(fncChannelsKickFromChannel);
    if(!channel.push(out)) return false;
    if(!userId.push(out)) return false;
    out->appendBool(kicked);
    return true;
}

UpdatesType Functions::Channels::kickFromChannelResult(InboundPkt *in) {
    UpdatesType result;
    if(!result.fetch(in)) return result;
    return result;
}

bool Functions::Channels::exportInvite(OutboundPkt *out, const InputChannel &channel) {
    out->appendInt(fncChannelsExportInvite);
    if(!channel.push(out)) return false;
    return true;
}

ExportedChatInvite Functions::Channels::exportInviteResult(InboundPkt *in) {
    ExportedChatInvite result;
    if(!result.fetch(in)) return result;
    return result;
}

bool Functions::Channels::deleteChannel(OutboundPkt *out, const InputChannel &channel) {
    out->appendInt(fncChannelsDeleteChannel);
    if(!channel.push(out)) return false;
    return true;
}

UpdatesType Functions::Channels::deleteChannelResult(InboundPkt *in) {
    UpdatesType result;
    if(!result.fetch(in)) return result;
    return result;
}

bool Functions::Channels::toggleInvites(OutboundPkt *out, const InputChannel &channel, bool enabled) {
    out->appendInt(fncChannelsToggleInvites);
    if(!channel.push(out)) return false;
    out->appendBool(enabled);
    return true;
}

UpdatesType Functions::Channels::toggleInvitesResult(InboundPkt *in) {
    UpdatesType result;
    if(!result.fetch(in)) return result;
    return result;
}

