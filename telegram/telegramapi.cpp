// This file generated by libqtelegram-code-generator.
// You can download it from: https://github.com/Aseman-Land/libqtelegram-code-generator
// DO NOT EDIT THIS FILE BY HAND -- YOUR CHANGES WILL BE OVERWRITTEN

#include "telegramapi.h"
#include "telegram/types/types.h"
#include "telegram/functions/functions.h"
#include "telegram/coretypes.h"

#include "util/tlvalues.h"
#include "core/dcprovider.h"
#include "secret/encrypter.h"

Q_LOGGING_CATEGORY(TG_CORE_API, "tg.core.api")

#define DEBUG_FUNCTION \
    qCDebug(TG_CORE_API) << __LINE__ << __FUNCTION__;

#define CHECK_SESSION(SESSION) \
    if(!SESSION) \
        return 0;

#define INIT_MAIN_CONNECTION(SESSION)

using namespace Tg;

TelegramApi::TelegramApi(Session *session, Settings *settings, CryptoUtils *crypto, QObject *parent) :
    AbstractApi(session, settings, crypto, parent),
    mSettings(settings),
    mCrypto(crypto)
{
    accountRegisterDeviceMethods.onAnswer = &TelegramApi::onAccountRegisterDeviceAnswer;
    accountRegisterDeviceMethods.onError = &TelegramApi::onAccountRegisterDeviceError;
    accountUnregisterDeviceMethods.onAnswer = &TelegramApi::onAccountUnregisterDeviceAnswer;
    accountUnregisterDeviceMethods.onError = &TelegramApi::onAccountUnregisterDeviceError;
    accountUpdateNotifySettingsMethods.onAnswer = &TelegramApi::onAccountUpdateNotifySettingsAnswer;
    accountUpdateNotifySettingsMethods.onError = &TelegramApi::onAccountUpdateNotifySettingsError;
    accountGetNotifySettingsMethods.onAnswer = &TelegramApi::onAccountGetNotifySettingsAnswer;
    accountGetNotifySettingsMethods.onError = &TelegramApi::onAccountGetNotifySettingsError;
    accountResetNotifySettingsMethods.onAnswer = &TelegramApi::onAccountResetNotifySettingsAnswer;
    accountResetNotifySettingsMethods.onError = &TelegramApi::onAccountResetNotifySettingsError;
    accountUpdateProfileMethods.onAnswer = &TelegramApi::onAccountUpdateProfileAnswer;
    accountUpdateProfileMethods.onError = &TelegramApi::onAccountUpdateProfileError;
    accountUpdateStatusMethods.onAnswer = &TelegramApi::onAccountUpdateStatusAnswer;
    accountUpdateStatusMethods.onError = &TelegramApi::onAccountUpdateStatusError;
    accountGetWallPapersMethods.onAnswer = &TelegramApi::onAccountGetWallPapersAnswer;
    accountGetWallPapersMethods.onError = &TelegramApi::onAccountGetWallPapersError;
    accountReportPeerMethods.onAnswer = &TelegramApi::onAccountReportPeerAnswer;
    accountReportPeerMethods.onError = &TelegramApi::onAccountReportPeerError;
    accountCheckUsernameMethods.onAnswer = &TelegramApi::onAccountCheckUsernameAnswer;
    accountCheckUsernameMethods.onError = &TelegramApi::onAccountCheckUsernameError;
    accountUpdateUsernameMethods.onAnswer = &TelegramApi::onAccountUpdateUsernameAnswer;
    accountUpdateUsernameMethods.onError = &TelegramApi::onAccountUpdateUsernameError;
    accountGetPrivacyMethods.onAnswer = &TelegramApi::onAccountGetPrivacyAnswer;
    accountGetPrivacyMethods.onError = &TelegramApi::onAccountGetPrivacyError;
    accountSetPrivacyMethods.onAnswer = &TelegramApi::onAccountSetPrivacyAnswer;
    accountSetPrivacyMethods.onError = &TelegramApi::onAccountSetPrivacyError;
    accountDeleteAccountMethods.onAnswer = &TelegramApi::onAccountDeleteAccountAnswer;
    accountDeleteAccountMethods.onError = &TelegramApi::onAccountDeleteAccountError;
    accountGetAccountTTLMethods.onAnswer = &TelegramApi::onAccountGetAccountTTLAnswer;
    accountGetAccountTTLMethods.onError = &TelegramApi::onAccountGetAccountTTLError;
    accountSetAccountTTLMethods.onAnswer = &TelegramApi::onAccountSetAccountTTLAnswer;
    accountSetAccountTTLMethods.onError = &TelegramApi::onAccountSetAccountTTLError;
    accountSendChangePhoneCodeMethods.onAnswer = &TelegramApi::onAccountSendChangePhoneCodeAnswer;
    accountSendChangePhoneCodeMethods.onError = &TelegramApi::onAccountSendChangePhoneCodeError;
    accountChangePhoneMethods.onAnswer = &TelegramApi::onAccountChangePhoneAnswer;
    accountChangePhoneMethods.onError = &TelegramApi::onAccountChangePhoneError;
    accountUpdateDeviceLockedMethods.onAnswer = &TelegramApi::onAccountUpdateDeviceLockedAnswer;
    accountUpdateDeviceLockedMethods.onError = &TelegramApi::onAccountUpdateDeviceLockedError;
    accountGetAuthorizationsMethods.onAnswer = &TelegramApi::onAccountGetAuthorizationsAnswer;
    accountGetAuthorizationsMethods.onError = &TelegramApi::onAccountGetAuthorizationsError;
    accountResetAuthorizationMethods.onAnswer = &TelegramApi::onAccountResetAuthorizationAnswer;
    accountResetAuthorizationMethods.onError = &TelegramApi::onAccountResetAuthorizationError;
    accountGetPasswordMethods.onAnswer = &TelegramApi::onAccountGetPasswordAnswer;
    accountGetPasswordMethods.onError = &TelegramApi::onAccountGetPasswordError;
    accountGetPasswordSettingsMethods.onAnswer = &TelegramApi::onAccountGetPasswordSettingsAnswer;
    accountGetPasswordSettingsMethods.onError = &TelegramApi::onAccountGetPasswordSettingsError;
    accountUpdatePasswordSettingsMethods.onAnswer = &TelegramApi::onAccountUpdatePasswordSettingsAnswer;
    accountUpdatePasswordSettingsMethods.onError = &TelegramApi::onAccountUpdatePasswordSettingsError;
    
    authCheckPhoneMethods.onAnswer = &TelegramApi::onAuthCheckPhoneAnswer;
    authCheckPhoneMethods.onError = &TelegramApi::onAuthCheckPhoneError;
    authSendCodeMethods.onAnswer = &TelegramApi::onAuthSendCodeAnswer;
    authSendCodeMethods.onError = &TelegramApi::onAuthSendCodeError;
    authSendCallMethods.onAnswer = &TelegramApi::onAuthSendCallAnswer;
    authSendCallMethods.onError = &TelegramApi::onAuthSendCallError;
    authSignUpMethods.onAnswer = &TelegramApi::onAuthSignUpAnswer;
    authSignUpMethods.onError = &TelegramApi::onAuthSignUpError;
    authSignInMethods.onAnswer = &TelegramApi::onAuthSignInAnswer;
    authSignInMethods.onError = &TelegramApi::onAuthSignInError;
    authLogOutMethods.onAnswer = &TelegramApi::onAuthLogOutAnswer;
    authLogOutMethods.onError = &TelegramApi::onAuthLogOutError;
    authResetAuthorizationsMethods.onAnswer = &TelegramApi::onAuthResetAuthorizationsAnswer;
    authResetAuthorizationsMethods.onError = &TelegramApi::onAuthResetAuthorizationsError;
    authSendInvitesMethods.onAnswer = &TelegramApi::onAuthSendInvitesAnswer;
    authSendInvitesMethods.onError = &TelegramApi::onAuthSendInvitesError;
    authExportAuthorizationMethods.onAnswer = &TelegramApi::onAuthExportAuthorizationAnswer;
    authExportAuthorizationMethods.onError = &TelegramApi::onAuthExportAuthorizationError;
    authImportAuthorizationMethods.onAnswer = &TelegramApi::onAuthImportAuthorizationAnswer;
    authImportAuthorizationMethods.onError = &TelegramApi::onAuthImportAuthorizationError;
    authBindTempAuthKeyMethods.onAnswer = &TelegramApi::onAuthBindTempAuthKeyAnswer;
    authBindTempAuthKeyMethods.onError = &TelegramApi::onAuthBindTempAuthKeyError;
    authSendSmsMethods.onAnswer = &TelegramApi::onAuthSendSmsAnswer;
    authSendSmsMethods.onError = &TelegramApi::onAuthSendSmsError;
    authImportBotAuthorizationMethods.onAnswer = &TelegramApi::onAuthImportBotAuthorizationAnswer;
    authImportBotAuthorizationMethods.onError = &TelegramApi::onAuthImportBotAuthorizationError;
    authCheckPasswordMethods.onAnswer = &TelegramApi::onAuthCheckPasswordAnswer;
    authCheckPasswordMethods.onError = &TelegramApi::onAuthCheckPasswordError;
    authRequestPasswordRecoveryMethods.onAnswer = &TelegramApi::onAuthRequestPasswordRecoveryAnswer;
    authRequestPasswordRecoveryMethods.onError = &TelegramApi::onAuthRequestPasswordRecoveryError;
    authRecoverPasswordMethods.onAnswer = &TelegramApi::onAuthRecoverPasswordAnswer;
    authRecoverPasswordMethods.onError = &TelegramApi::onAuthRecoverPasswordError;
    
    channelsGetDialogsMethods.onAnswer = &TelegramApi::onChannelsGetDialogsAnswer;
    channelsGetDialogsMethods.onError = &TelegramApi::onChannelsGetDialogsError;
    channelsGetImportantHistoryMethods.onAnswer = &TelegramApi::onChannelsGetImportantHistoryAnswer;
    channelsGetImportantHistoryMethods.onError = &TelegramApi::onChannelsGetImportantHistoryError;
    channelsReadHistoryMethods.onAnswer = &TelegramApi::onChannelsReadHistoryAnswer;
    channelsReadHistoryMethods.onError = &TelegramApi::onChannelsReadHistoryError;
    channelsDeleteMessagesMethods.onAnswer = &TelegramApi::onChannelsDeleteMessagesAnswer;
    channelsDeleteMessagesMethods.onError = &TelegramApi::onChannelsDeleteMessagesError;
    channelsDeleteUserHistoryMethods.onAnswer = &TelegramApi::onChannelsDeleteUserHistoryAnswer;
    channelsDeleteUserHistoryMethods.onError = &TelegramApi::onChannelsDeleteUserHistoryError;
    channelsReportSpamMethods.onAnswer = &TelegramApi::onChannelsReportSpamAnswer;
    channelsReportSpamMethods.onError = &TelegramApi::onChannelsReportSpamError;
    channelsGetMessagesMethods.onAnswer = &TelegramApi::onChannelsGetMessagesAnswer;
    channelsGetMessagesMethods.onError = &TelegramApi::onChannelsGetMessagesError;
    channelsGetParticipantsMethods.onAnswer = &TelegramApi::onChannelsGetParticipantsAnswer;
    channelsGetParticipantsMethods.onError = &TelegramApi::onChannelsGetParticipantsError;
    channelsGetParticipantMethods.onAnswer = &TelegramApi::onChannelsGetParticipantAnswer;
    channelsGetParticipantMethods.onError = &TelegramApi::onChannelsGetParticipantError;
    channelsGetChannelsMethods.onAnswer = &TelegramApi::onChannelsGetChannelsAnswer;
    channelsGetChannelsMethods.onError = &TelegramApi::onChannelsGetChannelsError;
    channelsGetFullChannelMethods.onAnswer = &TelegramApi::onChannelsGetFullChannelAnswer;
    channelsGetFullChannelMethods.onError = &TelegramApi::onChannelsGetFullChannelError;
    channelsCreateChannelMethods.onAnswer = &TelegramApi::onChannelsCreateChannelAnswer;
    channelsCreateChannelMethods.onError = &TelegramApi::onChannelsCreateChannelError;
    channelsEditAboutMethods.onAnswer = &TelegramApi::onChannelsEditAboutAnswer;
    channelsEditAboutMethods.onError = &TelegramApi::onChannelsEditAboutError;
    channelsEditAdminMethods.onAnswer = &TelegramApi::onChannelsEditAdminAnswer;
    channelsEditAdminMethods.onError = &TelegramApi::onChannelsEditAdminError;
    channelsEditTitleMethods.onAnswer = &TelegramApi::onChannelsEditTitleAnswer;
    channelsEditTitleMethods.onError = &TelegramApi::onChannelsEditTitleError;
    channelsEditPhotoMethods.onAnswer = &TelegramApi::onChannelsEditPhotoAnswer;
    channelsEditPhotoMethods.onError = &TelegramApi::onChannelsEditPhotoError;
    channelsToggleCommentsMethods.onAnswer = &TelegramApi::onChannelsToggleCommentsAnswer;
    channelsToggleCommentsMethods.onError = &TelegramApi::onChannelsToggleCommentsError;
    channelsCheckUsernameMethods.onAnswer = &TelegramApi::onChannelsCheckUsernameAnswer;
    channelsCheckUsernameMethods.onError = &TelegramApi::onChannelsCheckUsernameError;
    channelsUpdateUsernameMethods.onAnswer = &TelegramApi::onChannelsUpdateUsernameAnswer;
    channelsUpdateUsernameMethods.onError = &TelegramApi::onChannelsUpdateUsernameError;
    channelsJoinChannelMethods.onAnswer = &TelegramApi::onChannelsJoinChannelAnswer;
    channelsJoinChannelMethods.onError = &TelegramApi::onChannelsJoinChannelError;
    channelsLeaveChannelMethods.onAnswer = &TelegramApi::onChannelsLeaveChannelAnswer;
    channelsLeaveChannelMethods.onError = &TelegramApi::onChannelsLeaveChannelError;
    channelsInviteToChannelMethods.onAnswer = &TelegramApi::onChannelsInviteToChannelAnswer;
    channelsInviteToChannelMethods.onError = &TelegramApi::onChannelsInviteToChannelError;
    channelsKickFromChannelMethods.onAnswer = &TelegramApi::onChannelsKickFromChannelAnswer;
    channelsKickFromChannelMethods.onError = &TelegramApi::onChannelsKickFromChannelError;
    channelsExportInviteMethods.onAnswer = &TelegramApi::onChannelsExportInviteAnswer;
    channelsExportInviteMethods.onError = &TelegramApi::onChannelsExportInviteError;
    channelsDeleteChannelMethods.onAnswer = &TelegramApi::onChannelsDeleteChannelAnswer;
    channelsDeleteChannelMethods.onError = &TelegramApi::onChannelsDeleteChannelError;
    channelsToggleInvitesMethods.onAnswer = &TelegramApi::onChannelsToggleInvitesAnswer;
    channelsToggleInvitesMethods.onError = &TelegramApi::onChannelsToggleInvitesError;
    channelsExportMessageLinkMethods.onAnswer = &TelegramApi::onChannelsExportMessageLinkAnswer;
    channelsExportMessageLinkMethods.onError = &TelegramApi::onChannelsExportMessageLinkError;
    channelsToggleSignaturesMethods.onAnswer = &TelegramApi::onChannelsToggleSignaturesAnswer;
    channelsToggleSignaturesMethods.onError = &TelegramApi::onChannelsToggleSignaturesError;
    channelsGetMessageEditDataMethods.onAnswer = &TelegramApi::onChannelsGetMessageEditDataAnswer;
    channelsGetMessageEditDataMethods.onError = &TelegramApi::onChannelsGetMessageEditDataError;
    channelsEditMessageMethods.onAnswer = &TelegramApi::onChannelsEditMessageAnswer;
    channelsEditMessageMethods.onError = &TelegramApi::onChannelsEditMessageError;
    channelsUpdatePinnedMessageMethods.onAnswer = &TelegramApi::onChannelsUpdatePinnedMessageAnswer;
    channelsUpdatePinnedMessageMethods.onError = &TelegramApi::onChannelsUpdatePinnedMessageError;
    
    contactsGetStatusesMethods.onAnswer = &TelegramApi::onContactsGetStatusesAnswer;
    contactsGetStatusesMethods.onError = &TelegramApi::onContactsGetStatusesError;
    contactsGetContactsMethods.onAnswer = &TelegramApi::onContactsGetContactsAnswer;
    contactsGetContactsMethods.onError = &TelegramApi::onContactsGetContactsError;
    contactsImportContactsMethods.onAnswer = &TelegramApi::onContactsImportContactsAnswer;
    contactsImportContactsMethods.onError = &TelegramApi::onContactsImportContactsError;
    contactsDeleteContactMethods.onAnswer = &TelegramApi::onContactsDeleteContactAnswer;
    contactsDeleteContactMethods.onError = &TelegramApi::onContactsDeleteContactError;
    contactsDeleteContactsMethods.onAnswer = &TelegramApi::onContactsDeleteContactsAnswer;
    contactsDeleteContactsMethods.onError = &TelegramApi::onContactsDeleteContactsError;
    contactsBlockMethods.onAnswer = &TelegramApi::onContactsBlockAnswer;
    contactsBlockMethods.onError = &TelegramApi::onContactsBlockError;
    contactsUnblockMethods.onAnswer = &TelegramApi::onContactsUnblockAnswer;
    contactsUnblockMethods.onError = &TelegramApi::onContactsUnblockError;
    contactsGetBlockedMethods.onAnswer = &TelegramApi::onContactsGetBlockedAnswer;
    contactsGetBlockedMethods.onError = &TelegramApi::onContactsGetBlockedError;
    contactsExportCardMethods.onAnswer = &TelegramApi::onContactsExportCardAnswer;
    contactsExportCardMethods.onError = &TelegramApi::onContactsExportCardError;
    contactsImportCardMethods.onAnswer = &TelegramApi::onContactsImportCardAnswer;
    contactsImportCardMethods.onError = &TelegramApi::onContactsImportCardError;
    contactsSearchMethods.onAnswer = &TelegramApi::onContactsSearchAnswer;
    contactsSearchMethods.onError = &TelegramApi::onContactsSearchError;
    contactsResolveUsernameMethods.onAnswer = &TelegramApi::onContactsResolveUsernameAnswer;
    contactsResolveUsernameMethods.onError = &TelegramApi::onContactsResolveUsernameError;
    
    helpGetConfigMethods.onAnswer = &TelegramApi::onHelpGetConfigAnswer;
    helpGetConfigMethods.onError = &TelegramApi::onHelpGetConfigError;
    helpGetNearestDcMethods.onAnswer = &TelegramApi::onHelpGetNearestDcAnswer;
    helpGetNearestDcMethods.onError = &TelegramApi::onHelpGetNearestDcError;
    helpGetAppUpdateMethods.onAnswer = &TelegramApi::onHelpGetAppUpdateAnswer;
    helpGetAppUpdateMethods.onError = &TelegramApi::onHelpGetAppUpdateError;
    helpSaveAppLogMethods.onAnswer = &TelegramApi::onHelpSaveAppLogAnswer;
    helpSaveAppLogMethods.onError = &TelegramApi::onHelpSaveAppLogError;
    helpGetInviteTextMethods.onAnswer = &TelegramApi::onHelpGetInviteTextAnswer;
    helpGetInviteTextMethods.onError = &TelegramApi::onHelpGetInviteTextError;
    helpGetSupportMethods.onAnswer = &TelegramApi::onHelpGetSupportAnswer;
    helpGetSupportMethods.onError = &TelegramApi::onHelpGetSupportError;
    helpGetAppChangelogMethods.onAnswer = &TelegramApi::onHelpGetAppChangelogAnswer;
    helpGetAppChangelogMethods.onError = &TelegramApi::onHelpGetAppChangelogError;
    helpGetTermsOfServiceMethods.onAnswer = &TelegramApi::onHelpGetTermsOfServiceAnswer;
    helpGetTermsOfServiceMethods.onError = &TelegramApi::onHelpGetTermsOfServiceError;
    
    messagesGetMessagesMethods.onAnswer = &TelegramApi::onMessagesGetMessagesAnswer;
    messagesGetMessagesMethods.onError = &TelegramApi::onMessagesGetMessagesError;
    messagesGetDialogsMethods.onAnswer = &TelegramApi::onMessagesGetDialogsAnswer;
    messagesGetDialogsMethods.onError = &TelegramApi::onMessagesGetDialogsError;
    messagesGetHistoryMethods.onAnswer = &TelegramApi::onMessagesGetHistoryAnswer;
    messagesGetHistoryMethods.onError = &TelegramApi::onMessagesGetHistoryError;
    messagesSearchMethods.onAnswer = &TelegramApi::onMessagesSearchAnswer;
    messagesSearchMethods.onError = &TelegramApi::onMessagesSearchError;
    messagesReadHistoryMethods.onAnswer = &TelegramApi::onMessagesReadHistoryAnswer;
    messagesReadHistoryMethods.onError = &TelegramApi::onMessagesReadHistoryError;
    messagesDeleteHistoryMethods.onAnswer = &TelegramApi::onMessagesDeleteHistoryAnswer;
    messagesDeleteHistoryMethods.onError = &TelegramApi::onMessagesDeleteHistoryError;
    messagesDeleteMessagesMethods.onAnswer = &TelegramApi::onMessagesDeleteMessagesAnswer;
    messagesDeleteMessagesMethods.onError = &TelegramApi::onMessagesDeleteMessagesError;
    messagesReceivedMessagesMethods.onAnswer = &TelegramApi::onMessagesReceivedMessagesAnswer;
    messagesReceivedMessagesMethods.onError = &TelegramApi::onMessagesReceivedMessagesError;
    messagesSetTypingMethods.onAnswer = &TelegramApi::onMessagesSetTypingAnswer;
    messagesSetTypingMethods.onError = &TelegramApi::onMessagesSetTypingError;
    messagesSendMessageMethods.onAnswer = &TelegramApi::onMessagesSendMessageAnswer;
    messagesSendMessageMethods.onError = &TelegramApi::onMessagesSendMessageError;
    messagesSendMediaMethods.onAnswer = &TelegramApi::onMessagesSendMediaAnswer;
    messagesSendMediaMethods.onError = &TelegramApi::onMessagesSendMediaError;
    messagesForwardMessagesMethods.onAnswer = &TelegramApi::onMessagesForwardMessagesAnswer;
    messagesForwardMessagesMethods.onError = &TelegramApi::onMessagesForwardMessagesError;
    messagesReportSpamMethods.onAnswer = &TelegramApi::onMessagesReportSpamAnswer;
    messagesReportSpamMethods.onError = &TelegramApi::onMessagesReportSpamError;
    messagesHideReportSpamMethods.onAnswer = &TelegramApi::onMessagesHideReportSpamAnswer;
    messagesHideReportSpamMethods.onError = &TelegramApi::onMessagesHideReportSpamError;
    messagesGetPeerSettingsMethods.onAnswer = &TelegramApi::onMessagesGetPeerSettingsAnswer;
    messagesGetPeerSettingsMethods.onError = &TelegramApi::onMessagesGetPeerSettingsError;
    messagesGetChatsMethods.onAnswer = &TelegramApi::onMessagesGetChatsAnswer;
    messagesGetChatsMethods.onError = &TelegramApi::onMessagesGetChatsError;
    messagesGetFullChatMethods.onAnswer = &TelegramApi::onMessagesGetFullChatAnswer;
    messagesGetFullChatMethods.onError = &TelegramApi::onMessagesGetFullChatError;
    messagesEditChatTitleMethods.onAnswer = &TelegramApi::onMessagesEditChatTitleAnswer;
    messagesEditChatTitleMethods.onError = &TelegramApi::onMessagesEditChatTitleError;
    messagesEditChatPhotoMethods.onAnswer = &TelegramApi::onMessagesEditChatPhotoAnswer;
    messagesEditChatPhotoMethods.onError = &TelegramApi::onMessagesEditChatPhotoError;
    messagesAddChatUserMethods.onAnswer = &TelegramApi::onMessagesAddChatUserAnswer;
    messagesAddChatUserMethods.onError = &TelegramApi::onMessagesAddChatUserError;
    messagesDeleteChatUserMethods.onAnswer = &TelegramApi::onMessagesDeleteChatUserAnswer;
    messagesDeleteChatUserMethods.onError = &TelegramApi::onMessagesDeleteChatUserError;
    messagesCreateChatMethods.onAnswer = &TelegramApi::onMessagesCreateChatAnswer;
    messagesCreateChatMethods.onError = &TelegramApi::onMessagesCreateChatError;
    messagesForwardMessageMethods.onAnswer = &TelegramApi::onMessagesForwardMessageAnswer;
    messagesForwardMessageMethods.onError = &TelegramApi::onMessagesForwardMessageError;
    messagesSendBroadcastMethods.onAnswer = &TelegramApi::onMessagesSendBroadcastAnswer;
    messagesSendBroadcastMethods.onError = &TelegramApi::onMessagesSendBroadcastError;
    messagesGetDhConfigMethods.onAnswer = &TelegramApi::onMessagesGetDhConfigAnswer;
    messagesGetDhConfigMethods.onError = &TelegramApi::onMessagesGetDhConfigError;
    messagesRequestEncryptionMethods.onAnswer = &TelegramApi::onMessagesRequestEncryptionAnswer;
    messagesRequestEncryptionMethods.onError = &TelegramApi::onMessagesRequestEncryptionError;
    messagesAcceptEncryptionMethods.onAnswer = &TelegramApi::onMessagesAcceptEncryptionAnswer;
    messagesAcceptEncryptionMethods.onError = &TelegramApi::onMessagesAcceptEncryptionError;
    messagesDiscardEncryptionMethods.onAnswer = &TelegramApi::onMessagesDiscardEncryptionAnswer;
    messagesDiscardEncryptionMethods.onError = &TelegramApi::onMessagesDiscardEncryptionError;
    messagesSetEncryptedTypingMethods.onAnswer = &TelegramApi::onMessagesSetEncryptedTypingAnswer;
    messagesSetEncryptedTypingMethods.onError = &TelegramApi::onMessagesSetEncryptedTypingError;
    messagesReadEncryptedHistoryMethods.onAnswer = &TelegramApi::onMessagesReadEncryptedHistoryAnswer;
    messagesReadEncryptedHistoryMethods.onError = &TelegramApi::onMessagesReadEncryptedHistoryError;
    messagesSendEncryptedMethods.onAnswer = &TelegramApi::onMessagesSendEncryptedAnswer;
    messagesSendEncryptedMethods.onError = &TelegramApi::onMessagesSendEncryptedError;
    messagesSendEncryptedFileMethods.onAnswer = &TelegramApi::onMessagesSendEncryptedFileAnswer;
    messagesSendEncryptedFileMethods.onError = &TelegramApi::onMessagesSendEncryptedFileError;
    messagesSendEncryptedServiceMethods.onAnswer = &TelegramApi::onMessagesSendEncryptedServiceAnswer;
    messagesSendEncryptedServiceMethods.onError = &TelegramApi::onMessagesSendEncryptedServiceError;
    messagesReceivedQueueMethods.onAnswer = &TelegramApi::onMessagesReceivedQueueAnswer;
    messagesReceivedQueueMethods.onError = &TelegramApi::onMessagesReceivedQueueError;
    messagesReadMessageContentsMethods.onAnswer = &TelegramApi::onMessagesReadMessageContentsAnswer;
    messagesReadMessageContentsMethods.onError = &TelegramApi::onMessagesReadMessageContentsError;
    messagesGetStickersMethods.onAnswer = &TelegramApi::onMessagesGetStickersAnswer;
    messagesGetStickersMethods.onError = &TelegramApi::onMessagesGetStickersError;
    messagesGetAllStickersMethods.onAnswer = &TelegramApi::onMessagesGetAllStickersAnswer;
    messagesGetAllStickersMethods.onError = &TelegramApi::onMessagesGetAllStickersError;
    messagesGetWebPagePreviewMethods.onAnswer = &TelegramApi::onMessagesGetWebPagePreviewAnswer;
    messagesGetWebPagePreviewMethods.onError = &TelegramApi::onMessagesGetWebPagePreviewError;
    messagesExportChatInviteMethods.onAnswer = &TelegramApi::onMessagesExportChatInviteAnswer;
    messagesExportChatInviteMethods.onError = &TelegramApi::onMessagesExportChatInviteError;
    messagesCheckChatInviteMethods.onAnswer = &TelegramApi::onMessagesCheckChatInviteAnswer;
    messagesCheckChatInviteMethods.onError = &TelegramApi::onMessagesCheckChatInviteError;
    messagesImportChatInviteMethods.onAnswer = &TelegramApi::onMessagesImportChatInviteAnswer;
    messagesImportChatInviteMethods.onError = &TelegramApi::onMessagesImportChatInviteError;
    messagesGetStickerSetMethods.onAnswer = &TelegramApi::onMessagesGetStickerSetAnswer;
    messagesGetStickerSetMethods.onError = &TelegramApi::onMessagesGetStickerSetError;
    messagesInstallStickerSetMethods.onAnswer = &TelegramApi::onMessagesInstallStickerSetAnswer;
    messagesInstallStickerSetMethods.onError = &TelegramApi::onMessagesInstallStickerSetError;
    messagesUninstallStickerSetMethods.onAnswer = &TelegramApi::onMessagesUninstallStickerSetAnswer;
    messagesUninstallStickerSetMethods.onError = &TelegramApi::onMessagesUninstallStickerSetError;
    messagesStartBotMethods.onAnswer = &TelegramApi::onMessagesStartBotAnswer;
    messagesStartBotMethods.onError = &TelegramApi::onMessagesStartBotError;
    messagesGetMessagesViewsMethods.onAnswer = &TelegramApi::onMessagesGetMessagesViewsAnswer;
    messagesGetMessagesViewsMethods.onError = &TelegramApi::onMessagesGetMessagesViewsError;
    messagesToggleChatAdminsMethods.onAnswer = &TelegramApi::onMessagesToggleChatAdminsAnswer;
    messagesToggleChatAdminsMethods.onError = &TelegramApi::onMessagesToggleChatAdminsError;
    messagesEditChatAdminMethods.onAnswer = &TelegramApi::onMessagesEditChatAdminAnswer;
    messagesEditChatAdminMethods.onError = &TelegramApi::onMessagesEditChatAdminError;
    messagesMigrateChatMethods.onAnswer = &TelegramApi::onMessagesMigrateChatAnswer;
    messagesMigrateChatMethods.onError = &TelegramApi::onMessagesMigrateChatError;
    messagesSearchGlobalMethods.onAnswer = &TelegramApi::onMessagesSearchGlobalAnswer;
    messagesSearchGlobalMethods.onError = &TelegramApi::onMessagesSearchGlobalError;
    messagesReorderStickerSetsMethods.onAnswer = &TelegramApi::onMessagesReorderStickerSetsAnswer;
    messagesReorderStickerSetsMethods.onError = &TelegramApi::onMessagesReorderStickerSetsError;
    messagesGetDocumentByHashMethods.onAnswer = &TelegramApi::onMessagesGetDocumentByHashAnswer;
    messagesGetDocumentByHashMethods.onError = &TelegramApi::onMessagesGetDocumentByHashError;
    messagesSearchGifsMethods.onAnswer = &TelegramApi::onMessagesSearchGifsAnswer;
    messagesSearchGifsMethods.onError = &TelegramApi::onMessagesSearchGifsError;
    messagesGetSavedGifsMethods.onAnswer = &TelegramApi::onMessagesGetSavedGifsAnswer;
    messagesGetSavedGifsMethods.onError = &TelegramApi::onMessagesGetSavedGifsError;
    messagesSaveGifMethods.onAnswer = &TelegramApi::onMessagesSaveGifAnswer;
    messagesSaveGifMethods.onError = &TelegramApi::onMessagesSaveGifError;
    messagesGetInlineBotResultsMethods.onAnswer = &TelegramApi::onMessagesGetInlineBotResultsAnswer;
    messagesGetInlineBotResultsMethods.onError = &TelegramApi::onMessagesGetInlineBotResultsError;
    messagesSetInlineBotResultsMethods.onAnswer = &TelegramApi::onMessagesSetInlineBotResultsAnswer;
    messagesSetInlineBotResultsMethods.onError = &TelegramApi::onMessagesSetInlineBotResultsError;
    messagesSendInlineBotResultMethods.onAnswer = &TelegramApi::onMessagesSendInlineBotResultAnswer;
    messagesSendInlineBotResultMethods.onError = &TelegramApi::onMessagesSendInlineBotResultError;
    
    photosUpdateProfilePhotoMethods.onAnswer = &TelegramApi::onPhotosUpdateProfilePhotoAnswer;
    photosUpdateProfilePhotoMethods.onError = &TelegramApi::onPhotosUpdateProfilePhotoError;
    photosUploadProfilePhotoMethods.onAnswer = &TelegramApi::onPhotosUploadProfilePhotoAnswer;
    photosUploadProfilePhotoMethods.onError = &TelegramApi::onPhotosUploadProfilePhotoError;
    photosDeletePhotosMethods.onAnswer = &TelegramApi::onPhotosDeletePhotosAnswer;
    photosDeletePhotosMethods.onError = &TelegramApi::onPhotosDeletePhotosError;
    photosGetUserPhotosMethods.onAnswer = &TelegramApi::onPhotosGetUserPhotosAnswer;
    photosGetUserPhotosMethods.onError = &TelegramApi::onPhotosGetUserPhotosError;
    
    updatesGetStateMethods.onAnswer = &TelegramApi::onUpdatesGetStateAnswer;
    updatesGetStateMethods.onError = &TelegramApi::onUpdatesGetStateError;
    updatesGetDifferenceMethods.onAnswer = &TelegramApi::onUpdatesGetDifferenceAnswer;
    updatesGetDifferenceMethods.onError = &TelegramApi::onUpdatesGetDifferenceError;
    updatesGetChannelDifferenceMethods.onAnswer = &TelegramApi::onUpdatesGetChannelDifferenceAnswer;
    updatesGetChannelDifferenceMethods.onError = &TelegramApi::onUpdatesGetChannelDifferenceError;
    
    uploadSaveFilePartMethods.onAnswer = &TelegramApi::onUploadSaveFilePartAnswer;
    uploadSaveFilePartMethods.onError = &TelegramApi::onUploadSaveFilePartError;
    uploadGetFileMethods.onAnswer = &TelegramApi::onUploadGetFileAnswer;
    uploadGetFileMethods.onError = &TelegramApi::onUploadGetFileError;
    uploadSaveBigFilePartMethods.onAnswer = &TelegramApi::onUploadSaveBigFilePartAnswer;
    uploadSaveBigFilePartMethods.onError = &TelegramApi::onUploadSaveBigFilePartError;
    
    usersGetUsersMethods.onAnswer = &TelegramApi::onUsersGetUsersAnswer;
    usersGetUsersMethods.onError = &TelegramApi::onUsersGetUsersError;
    usersGetFullUserMethods.onAnswer = &TelegramApi::onUsersGetFullUserAnswer;
    usersGetFullUserMethods.onError = &TelegramApi::onUsersGetFullUserError;

}

TelegramApi::~TelegramApi() {
}

qint64 TelegramApi::accountRegisterDevice(qint32 token_type, const QString &token, const QString &device_model, const QString &system_version, const QString &app_version, bool app_sandbox, const QString &lang_code, const QVariant &attachedData, Session *session) {
    if(!session) session = mMainSession;
    CHECK_SESSION(session)
    DEBUG_FUNCTION
    OutboundPkt p(mSettings);
    INIT_MAIN_CONNECTION(session)
    Functions::Account::registerDevice(&p, token_type, token, device_model, system_version, app_version, app_sandbox, lang_code);
    return session->sendQuery(p, &accountRegisterDeviceMethods, attachedData, "Account->registerDevice" );
}

void TelegramApi::onAccountRegisterDeviceAnswer(Query *q, InboundPkt &inboundPkt) {
    const bool result = Functions::Account::registerDeviceResult(&inboundPkt);
    Q_EMIT accountRegisterDeviceAnswer(q->mainMsgId(), result, q->extra());
}

void TelegramApi::onAccountRegisterDeviceError(Query *q, qint32 errorCode, const QString &errorText) {
    bool accepted = false;
    onError(q, errorCode, errorText, q->extra(), accepted);
    if(!accepted)
        Q_EMIT accountRegisterDeviceError(q->mainMsgId(), errorCode, errorText, q->extra());
}

qint64 TelegramApi::accountUnregisterDevice(qint32 token_type, const QString &token, const QVariant &attachedData, Session *session) {
    if(!session) session = mMainSession;
    CHECK_SESSION(session)
    DEBUG_FUNCTION
    OutboundPkt p(mSettings);
    INIT_MAIN_CONNECTION(session)
    Functions::Account::unregisterDevice(&p, token_type, token);
    return session->sendQuery(p, &accountUnregisterDeviceMethods, attachedData, "Account->unregisterDevice" );
}

void TelegramApi::onAccountUnregisterDeviceAnswer(Query *q, InboundPkt &inboundPkt) {
    const bool result = Functions::Account::unregisterDeviceResult(&inboundPkt);
    Q_EMIT accountUnregisterDeviceAnswer(q->mainMsgId(), result, q->extra());
}

void TelegramApi::onAccountUnregisterDeviceError(Query *q, qint32 errorCode, const QString &errorText) {
    bool accepted = false;
    onError(q, errorCode, errorText, q->extra(), accepted);
    if(!accepted)
        Q_EMIT accountUnregisterDeviceError(q->mainMsgId(), errorCode, errorText, q->extra());
}

qint64 TelegramApi::accountUpdateNotifySettings(const InputNotifyPeer &peer, const InputPeerNotifySettings &settings, const QVariant &attachedData, Session *session) {
    if(!session) session = mMainSession;
    CHECK_SESSION(session)
    DEBUG_FUNCTION
    OutboundPkt p(mSettings);
    INIT_MAIN_CONNECTION(session)
    Functions::Account::updateNotifySettings(&p, peer, settings);
    return session->sendQuery(p, &accountUpdateNotifySettingsMethods, attachedData, "Account->updateNotifySettings" );
}

void TelegramApi::onAccountUpdateNotifySettingsAnswer(Query *q, InboundPkt &inboundPkt) {
    const bool result = Functions::Account::updateNotifySettingsResult(&inboundPkt);
    Q_EMIT accountUpdateNotifySettingsAnswer(q->mainMsgId(), result, q->extra());
}

void TelegramApi::onAccountUpdateNotifySettingsError(Query *q, qint32 errorCode, const QString &errorText) {
    bool accepted = false;
    onError(q, errorCode, errorText, q->extra(), accepted);
    if(!accepted)
        Q_EMIT accountUpdateNotifySettingsError(q->mainMsgId(), errorCode, errorText, q->extra());
}

qint64 TelegramApi::accountGetNotifySettings(const InputNotifyPeer &peer, const QVariant &attachedData, Session *session) {
    if(!session) session = mMainSession;
    CHECK_SESSION(session)
    DEBUG_FUNCTION
    OutboundPkt p(mSettings);
    INIT_MAIN_CONNECTION(session)
    Functions::Account::getNotifySettings(&p, peer);
    return session->sendQuery(p, &accountGetNotifySettingsMethods, attachedData, "Account->getNotifySettings" );
}

void TelegramApi::onAccountGetNotifySettingsAnswer(Query *q, InboundPkt &inboundPkt) {
    const PeerNotifySettings &result = Functions::Account::getNotifySettingsResult(&inboundPkt);
    if(result.error())
        onAccountGetNotifySettingsError(q, -1, "LIBQTELEGRAM_INTERNAL_ERROR");
    else
        Q_EMIT accountGetNotifySettingsAnswer(q->mainMsgId(), result, q->extra());
}

void TelegramApi::onAccountGetNotifySettingsError(Query *q, qint32 errorCode, const QString &errorText) {
    bool accepted = false;
    onError(q, errorCode, errorText, q->extra(), accepted);
    if(!accepted)
        Q_EMIT accountGetNotifySettingsError(q->mainMsgId(), errorCode, errorText, q->extra());
}

qint64 TelegramApi::accountResetNotifySettings(const QVariant &attachedData, Session *session) {
    if(!session) session = mMainSession;
    CHECK_SESSION(session)
    DEBUG_FUNCTION
    OutboundPkt p(mSettings);
    INIT_MAIN_CONNECTION(session)
    Functions::Account::resetNotifySettings(&p);
    return session->sendQuery(p, &accountResetNotifySettingsMethods, attachedData, "Account->resetNotifySettings" );
}

void TelegramApi::onAccountResetNotifySettingsAnswer(Query *q, InboundPkt &inboundPkt) {
    const bool result = Functions::Account::resetNotifySettingsResult(&inboundPkt);
    Q_EMIT accountResetNotifySettingsAnswer(q->mainMsgId(), result, q->extra());
}

void TelegramApi::onAccountResetNotifySettingsError(Query *q, qint32 errorCode, const QString &errorText) {
    bool accepted = false;
    onError(q, errorCode, errorText, q->extra(), accepted);
    if(!accepted)
        Q_EMIT accountResetNotifySettingsError(q->mainMsgId(), errorCode, errorText, q->extra());
}

qint64 TelegramApi::accountUpdateProfile(const QString &first_name, const QString &last_name, const QString &about, const QVariant &attachedData, Session *session) {
    if(!session) session = mMainSession;
    CHECK_SESSION(session)
    DEBUG_FUNCTION
    OutboundPkt p(mSettings);
    INIT_MAIN_CONNECTION(session)
    Functions::Account::updateProfile(&p, first_name, last_name, about);
    return session->sendQuery(p, &accountUpdateProfileMethods, attachedData, "Account->updateProfile" );
}

void TelegramApi::onAccountUpdateProfileAnswer(Query *q, InboundPkt &inboundPkt) {
    const User &result = Functions::Account::updateProfileResult(&inboundPkt);
    if(result.error())
        onAccountUpdateProfileError(q, -1, "LIBQTELEGRAM_INTERNAL_ERROR");
    else
        Q_EMIT accountUpdateProfileAnswer(q->mainMsgId(), result, q->extra());
}

void TelegramApi::onAccountUpdateProfileError(Query *q, qint32 errorCode, const QString &errorText) {
    bool accepted = false;
    onError(q, errorCode, errorText, q->extra(), accepted);
    if(!accepted)
        Q_EMIT accountUpdateProfileError(q->mainMsgId(), errorCode, errorText, q->extra());
}

qint64 TelegramApi::accountUpdateStatus(bool offline, const QVariant &attachedData, Session *session) {
    if(!session) session = mMainSession;
    CHECK_SESSION(session)
    DEBUG_FUNCTION
    OutboundPkt p(mSettings);
    INIT_MAIN_CONNECTION(session)
    Functions::Account::updateStatus(&p, offline);
    return session->sendQuery(p, &accountUpdateStatusMethods, attachedData, "Account->updateStatus" );
}

void TelegramApi::onAccountUpdateStatusAnswer(Query *q, InboundPkt &inboundPkt) {
    const bool result = Functions::Account::updateStatusResult(&inboundPkt);
    Q_EMIT accountUpdateStatusAnswer(q->mainMsgId(), result, q->extra());
}

void TelegramApi::onAccountUpdateStatusError(Query *q, qint32 errorCode, const QString &errorText) {
    bool accepted = false;
    onError(q, errorCode, errorText, q->extra(), accepted);
    if(!accepted)
        Q_EMIT accountUpdateStatusError(q->mainMsgId(), errorCode, errorText, q->extra());
}

qint64 TelegramApi::accountGetWallPapers(const QVariant &attachedData, Session *session) {
    if(!session) session = mMainSession;
    CHECK_SESSION(session)
    DEBUG_FUNCTION
    OutboundPkt p(mSettings);
    INIT_MAIN_CONNECTION(session)
    Functions::Account::getWallPapers(&p);
    return session->sendQuery(p, &accountGetWallPapersMethods, attachedData, "Account->getWallPapers" );
}

void TelegramApi::onAccountGetWallPapersAnswer(Query *q, InboundPkt &inboundPkt) {
    const QList<WallPaper> &result = Functions::Account::getWallPapersResult(&inboundPkt);
    Q_EMIT accountGetWallPapersAnswer(q->mainMsgId(), result, q->extra());
}

void TelegramApi::onAccountGetWallPapersError(Query *q, qint32 errorCode, const QString &errorText) {
    bool accepted = false;
    onError(q, errorCode, errorText, q->extra(), accepted);
    if(!accepted)
        Q_EMIT accountGetWallPapersError(q->mainMsgId(), errorCode, errorText, q->extra());
}

qint64 TelegramApi::accountReportPeer(const InputPeer &peer, const ReportReason &reason, const QVariant &attachedData, Session *session) {
    if(!session) session = mMainSession;
    CHECK_SESSION(session)
    DEBUG_FUNCTION
    OutboundPkt p(mSettings);
    INIT_MAIN_CONNECTION(session)
    Functions::Account::reportPeer(&p, peer, reason);
    return session->sendQuery(p, &accountReportPeerMethods, attachedData, "Account->reportPeer" );
}

void TelegramApi::onAccountReportPeerAnswer(Query *q, InboundPkt &inboundPkt) {
    const bool result = Functions::Account::reportPeerResult(&inboundPkt);
    Q_EMIT accountReportPeerAnswer(q->mainMsgId(), result, q->extra());
}

void TelegramApi::onAccountReportPeerError(Query *q, qint32 errorCode, const QString &errorText) {
    bool accepted = false;
    onError(q, errorCode, errorText, q->extra(), accepted);
    if(!accepted)
        Q_EMIT accountReportPeerError(q->mainMsgId(), errorCode, errorText, q->extra());
}

qint64 TelegramApi::accountCheckUsername(const QString &username, const QVariant &attachedData, Session *session) {
    if(!session) session = mMainSession;
    CHECK_SESSION(session)
    DEBUG_FUNCTION
    OutboundPkt p(mSettings);
    INIT_MAIN_CONNECTION(session)
    Functions::Account::checkUsername(&p, username);
    return session->sendQuery(p, &accountCheckUsernameMethods, attachedData, "Account->checkUsername" );
}

void TelegramApi::onAccountCheckUsernameAnswer(Query *q, InboundPkt &inboundPkt) {
    const bool result = Functions::Account::checkUsernameResult(&inboundPkt);
    Q_EMIT accountCheckUsernameAnswer(q->mainMsgId(), result, q->extra());
}

void TelegramApi::onAccountCheckUsernameError(Query *q, qint32 errorCode, const QString &errorText) {
    bool accepted = false;
    onError(q, errorCode, errorText, q->extra(), accepted);
    if(!accepted)
        Q_EMIT accountCheckUsernameError(q->mainMsgId(), errorCode, errorText, q->extra());
}

qint64 TelegramApi::accountUpdateUsername(const QString &username, const QVariant &attachedData, Session *session) {
    if(!session) session = mMainSession;
    CHECK_SESSION(session)
    DEBUG_FUNCTION
    OutboundPkt p(mSettings);
    INIT_MAIN_CONNECTION(session)
    Functions::Account::updateUsername(&p, username);
    return session->sendQuery(p, &accountUpdateUsernameMethods, attachedData, "Account->updateUsername" );
}

void TelegramApi::onAccountUpdateUsernameAnswer(Query *q, InboundPkt &inboundPkt) {
    const User &result = Functions::Account::updateUsernameResult(&inboundPkt);
    if(result.error())
        onAccountUpdateUsernameError(q, -1, "LIBQTELEGRAM_INTERNAL_ERROR");
    else
        Q_EMIT accountUpdateUsernameAnswer(q->mainMsgId(), result, q->extra());
}

void TelegramApi::onAccountUpdateUsernameError(Query *q, qint32 errorCode, const QString &errorText) {
    bool accepted = false;
    onError(q, errorCode, errorText, q->extra(), accepted);
    if(!accepted)
        Q_EMIT accountUpdateUsernameError(q->mainMsgId(), errorCode, errorText, q->extra());
}

qint64 TelegramApi::accountGetPrivacy(const InputPrivacyKey &key, const QVariant &attachedData, Session *session) {
    if(!session) session = mMainSession;
    CHECK_SESSION(session)
    DEBUG_FUNCTION
    OutboundPkt p(mSettings);
    INIT_MAIN_CONNECTION(session)
    Functions::Account::getPrivacy(&p, key);
    return session->sendQuery(p, &accountGetPrivacyMethods, attachedData, "Account->getPrivacy" );
}

void TelegramApi::onAccountGetPrivacyAnswer(Query *q, InboundPkt &inboundPkt) {
    const AccountPrivacyRules &result = Functions::Account::getPrivacyResult(&inboundPkt);
    if(result.error())
        onAccountGetPrivacyError(q, -1, "LIBQTELEGRAM_INTERNAL_ERROR");
    else
        Q_EMIT accountGetPrivacyAnswer(q->mainMsgId(), result, q->extra());
}

void TelegramApi::onAccountGetPrivacyError(Query *q, qint32 errorCode, const QString &errorText) {
    bool accepted = false;
    onError(q, errorCode, errorText, q->extra(), accepted);
    if(!accepted)
        Q_EMIT accountGetPrivacyError(q->mainMsgId(), errorCode, errorText, q->extra());
}

qint64 TelegramApi::accountSetPrivacy(const InputPrivacyKey &key, const QList<InputPrivacyRule> &rules, const QVariant &attachedData, Session *session) {
    if(!session) session = mMainSession;
    CHECK_SESSION(session)
    DEBUG_FUNCTION
    OutboundPkt p(mSettings);
    INIT_MAIN_CONNECTION(session)
    Functions::Account::setPrivacy(&p, key, rules);
    return session->sendQuery(p, &accountSetPrivacyMethods, attachedData, "Account->setPrivacy" );
}

void TelegramApi::onAccountSetPrivacyAnswer(Query *q, InboundPkt &inboundPkt) {
    const AccountPrivacyRules &result = Functions::Account::setPrivacyResult(&inboundPkt);
    if(result.error())
        onAccountSetPrivacyError(q, -1, "LIBQTELEGRAM_INTERNAL_ERROR");
    else
        Q_EMIT accountSetPrivacyAnswer(q->mainMsgId(), result, q->extra());
}

void TelegramApi::onAccountSetPrivacyError(Query *q, qint32 errorCode, const QString &errorText) {
    bool accepted = false;
    onError(q, errorCode, errorText, q->extra(), accepted);
    if(!accepted)
        Q_EMIT accountSetPrivacyError(q->mainMsgId(), errorCode, errorText, q->extra());
}

qint64 TelegramApi::accountDeleteAccount(const QString &reason, const QVariant &attachedData, Session *session) {
    if(!session) session = mMainSession;
    CHECK_SESSION(session)
    DEBUG_FUNCTION
    OutboundPkt p(mSettings);
    INIT_MAIN_CONNECTION(session)
    Functions::Account::deleteAccount(&p, reason);
    return session->sendQuery(p, &accountDeleteAccountMethods, attachedData, "Account->deleteAccount" );
}

void TelegramApi::onAccountDeleteAccountAnswer(Query *q, InboundPkt &inboundPkt) {
    const bool result = Functions::Account::deleteAccountResult(&inboundPkt);
    Q_EMIT accountDeleteAccountAnswer(q->mainMsgId(), result, q->extra());
}

void TelegramApi::onAccountDeleteAccountError(Query *q, qint32 errorCode, const QString &errorText) {
    bool accepted = false;
    onError(q, errorCode, errorText, q->extra(), accepted);
    if(!accepted)
        Q_EMIT accountDeleteAccountError(q->mainMsgId(), errorCode, errorText, q->extra());
}

qint64 TelegramApi::accountGetAccountTTL(const QVariant &attachedData, Session *session) {
    if(!session) session = mMainSession;
    CHECK_SESSION(session)
    DEBUG_FUNCTION
    OutboundPkt p(mSettings);
    INIT_MAIN_CONNECTION(session)
    Functions::Account::getAccountTTL(&p);
    return session->sendQuery(p, &accountGetAccountTTLMethods, attachedData, "Account->getAccountTTL" );
}

void TelegramApi::onAccountGetAccountTTLAnswer(Query *q, InboundPkt &inboundPkt) {
    const AccountDaysTTL &result = Functions::Account::getAccountTTLResult(&inboundPkt);
    if(result.error())
        onAccountGetAccountTTLError(q, -1, "LIBQTELEGRAM_INTERNAL_ERROR");
    else
        Q_EMIT accountGetAccountTTLAnswer(q->mainMsgId(), result, q->extra());
}

void TelegramApi::onAccountGetAccountTTLError(Query *q, qint32 errorCode, const QString &errorText) {
    bool accepted = false;
    onError(q, errorCode, errorText, q->extra(), accepted);
    if(!accepted)
        Q_EMIT accountGetAccountTTLError(q->mainMsgId(), errorCode, errorText, q->extra());
}

qint64 TelegramApi::accountSetAccountTTL(const AccountDaysTTL &ttl, const QVariant &attachedData, Session *session) {
    if(!session) session = mMainSession;
    CHECK_SESSION(session)
    DEBUG_FUNCTION
    OutboundPkt p(mSettings);
    INIT_MAIN_CONNECTION(session)
    Functions::Account::setAccountTTL(&p, ttl);
    return session->sendQuery(p, &accountSetAccountTTLMethods, attachedData, "Account->setAccountTTL" );
}

void TelegramApi::onAccountSetAccountTTLAnswer(Query *q, InboundPkt &inboundPkt) {
    const bool result = Functions::Account::setAccountTTLResult(&inboundPkt);
    Q_EMIT accountSetAccountTTLAnswer(q->mainMsgId(), result, q->extra());
}

void TelegramApi::onAccountSetAccountTTLError(Query *q, qint32 errorCode, const QString &errorText) {
    bool accepted = false;
    onError(q, errorCode, errorText, q->extra(), accepted);
    if(!accepted)
        Q_EMIT accountSetAccountTTLError(q->mainMsgId(), errorCode, errorText, q->extra());
}

qint64 TelegramApi::accountSendChangePhoneCode(const QString &phone_number, const QVariant &attachedData, Session *session) {
    if(!session) session = mMainSession;
    CHECK_SESSION(session)
    DEBUG_FUNCTION
    OutboundPkt p(mSettings);
    INIT_MAIN_CONNECTION(session)
    Functions::Account::sendChangePhoneCode(&p, phone_number);
    return session->sendQuery(p, &accountSendChangePhoneCodeMethods, attachedData, "Account->sendChangePhoneCode" );
}

void TelegramApi::onAccountSendChangePhoneCodeAnswer(Query *q, InboundPkt &inboundPkt) {
    const AccountSentChangePhoneCode &result = Functions::Account::sendChangePhoneCodeResult(&inboundPkt);
    if(result.error())
        onAccountSendChangePhoneCodeError(q, -1, "LIBQTELEGRAM_INTERNAL_ERROR");
    else
        Q_EMIT accountSendChangePhoneCodeAnswer(q->mainMsgId(), result, q->extra());
}

void TelegramApi::onAccountSendChangePhoneCodeError(Query *q, qint32 errorCode, const QString &errorText) {
    bool accepted = false;
    onError(q, errorCode, errorText, q->extra(), accepted);
    if(!accepted)
        Q_EMIT accountSendChangePhoneCodeError(q->mainMsgId(), errorCode, errorText, q->extra());
}

qint64 TelegramApi::accountChangePhone(const QString &phone_number, const QString &phone_code_hash, const QString &phone_code, const QVariant &attachedData, Session *session) {
    if(!session) session = mMainSession;
    CHECK_SESSION(session)
    DEBUG_FUNCTION
    OutboundPkt p(mSettings);
    INIT_MAIN_CONNECTION(session)
    Functions::Account::changePhone(&p, phone_number, phone_code_hash, phone_code);
    return session->sendQuery(p, &accountChangePhoneMethods, attachedData, "Account->changePhone" );
}

void TelegramApi::onAccountChangePhoneAnswer(Query *q, InboundPkt &inboundPkt) {
    const User &result = Functions::Account::changePhoneResult(&inboundPkt);
    if(result.error())
        onAccountChangePhoneError(q, -1, "LIBQTELEGRAM_INTERNAL_ERROR");
    else
        Q_EMIT accountChangePhoneAnswer(q->mainMsgId(), result, q->extra());
}

void TelegramApi::onAccountChangePhoneError(Query *q, qint32 errorCode, const QString &errorText) {
    bool accepted = false;
    onError(q, errorCode, errorText, q->extra(), accepted);
    if(!accepted)
        Q_EMIT accountChangePhoneError(q->mainMsgId(), errorCode, errorText, q->extra());
}

qint64 TelegramApi::accountUpdateDeviceLocked(qint32 period, const QVariant &attachedData, Session *session) {
    if(!session) session = mMainSession;
    CHECK_SESSION(session)
    DEBUG_FUNCTION
    OutboundPkt p(mSettings);
    INIT_MAIN_CONNECTION(session)
    Functions::Account::updateDeviceLocked(&p, period);
    return session->sendQuery(p, &accountUpdateDeviceLockedMethods, attachedData, "Account->updateDeviceLocked" );
}

void TelegramApi::onAccountUpdateDeviceLockedAnswer(Query *q, InboundPkt &inboundPkt) {
    const bool result = Functions::Account::updateDeviceLockedResult(&inboundPkt);
    Q_EMIT accountUpdateDeviceLockedAnswer(q->mainMsgId(), result, q->extra());
}

void TelegramApi::onAccountUpdateDeviceLockedError(Query *q, qint32 errorCode, const QString &errorText) {
    bool accepted = false;
    onError(q, errorCode, errorText, q->extra(), accepted);
    if(!accepted)
        Q_EMIT accountUpdateDeviceLockedError(q->mainMsgId(), errorCode, errorText, q->extra());
}

qint64 TelegramApi::accountGetAuthorizations(const QVariant &attachedData, Session *session) {
    if(!session) session = mMainSession;
    CHECK_SESSION(session)
    DEBUG_FUNCTION
    OutboundPkt p(mSettings);
    INIT_MAIN_CONNECTION(session)
    Functions::Account::getAuthorizations(&p);
    return session->sendQuery(p, &accountGetAuthorizationsMethods, attachedData, "Account->getAuthorizations" );
}

void TelegramApi::onAccountGetAuthorizationsAnswer(Query *q, InboundPkt &inboundPkt) {
    const AccountAuthorizations &result = Functions::Account::getAuthorizationsResult(&inboundPkt);
    if(result.error())
        onAccountGetAuthorizationsError(q, -1, "LIBQTELEGRAM_INTERNAL_ERROR");
    else
        Q_EMIT accountGetAuthorizationsAnswer(q->mainMsgId(), result, q->extra());
}

void TelegramApi::onAccountGetAuthorizationsError(Query *q, qint32 errorCode, const QString &errorText) {
    bool accepted = false;
    onError(q, errorCode, errorText, q->extra(), accepted);
    if(!accepted)
        Q_EMIT accountGetAuthorizationsError(q->mainMsgId(), errorCode, errorText, q->extra());
}

qint64 TelegramApi::accountResetAuthorization(qint64 hash, const QVariant &attachedData, Session *session) {
    if(!session) session = mMainSession;
    CHECK_SESSION(session)
    DEBUG_FUNCTION
    OutboundPkt p(mSettings);
    INIT_MAIN_CONNECTION(session)
    Functions::Account::resetAuthorization(&p, hash);
    return session->sendQuery(p, &accountResetAuthorizationMethods, attachedData, "Account->resetAuthorization" );
}

void TelegramApi::onAccountResetAuthorizationAnswer(Query *q, InboundPkt &inboundPkt) {
    const bool result = Functions::Account::resetAuthorizationResult(&inboundPkt);
    Q_EMIT accountResetAuthorizationAnswer(q->mainMsgId(), result, q->extra());
}

void TelegramApi::onAccountResetAuthorizationError(Query *q, qint32 errorCode, const QString &errorText) {
    bool accepted = false;
    onError(q, errorCode, errorText, q->extra(), accepted);
    if(!accepted)
        Q_EMIT accountResetAuthorizationError(q->mainMsgId(), errorCode, errorText, q->extra());
}

qint64 TelegramApi::accountGetPassword(const QVariant &attachedData, Session *session) {
    if(!session) session = mMainSession;
    CHECK_SESSION(session)
    DEBUG_FUNCTION
    OutboundPkt p(mSettings);
    INIT_MAIN_CONNECTION(session)
    Functions::Account::getPassword(&p);
    return session->sendQuery(p, &accountGetPasswordMethods, attachedData, "Account->getPassword" );
}

void TelegramApi::onAccountGetPasswordAnswer(Query *q, InboundPkt &inboundPkt) {
    const AccountPassword &result = Functions::Account::getPasswordResult(&inboundPkt);
    if(result.error())
        onAccountGetPasswordError(q, -1, "LIBQTELEGRAM_INTERNAL_ERROR");
    else
        Q_EMIT accountGetPasswordAnswer(q->mainMsgId(), result, q->extra());
}

void TelegramApi::onAccountGetPasswordError(Query *q, qint32 errorCode, const QString &errorText) {
    bool accepted = false;
    onError(q, errorCode, errorText, q->extra(), accepted);
    if(!accepted)
        Q_EMIT accountGetPasswordError(q->mainMsgId(), errorCode, errorText, q->extra());
}

qint64 TelegramApi::accountGetPasswordSettings(const QByteArray &current_password_hash, const QVariant &attachedData, Session *session) {
    if(!session) session = mMainSession;
    CHECK_SESSION(session)
    DEBUG_FUNCTION
    OutboundPkt p(mSettings);
    INIT_MAIN_CONNECTION(session)
    Functions::Account::getPasswordSettings(&p, current_password_hash);
    return session->sendQuery(p, &accountGetPasswordSettingsMethods, attachedData, "Account->getPasswordSettings" );
}

void TelegramApi::onAccountGetPasswordSettingsAnswer(Query *q, InboundPkt &inboundPkt) {
    const AccountPasswordSettings &result = Functions::Account::getPasswordSettingsResult(&inboundPkt);
    if(result.error())
        onAccountGetPasswordSettingsError(q, -1, "LIBQTELEGRAM_INTERNAL_ERROR");
    else
        Q_EMIT accountGetPasswordSettingsAnswer(q->mainMsgId(), result, q->extra());
}

void TelegramApi::onAccountGetPasswordSettingsError(Query *q, qint32 errorCode, const QString &errorText) {
    bool accepted = false;
    onError(q, errorCode, errorText, q->extra(), accepted);
    if(!accepted)
        Q_EMIT accountGetPasswordSettingsError(q->mainMsgId(), errorCode, errorText, q->extra());
}

qint64 TelegramApi::accountUpdatePasswordSettings(const QByteArray &current_password_hash, const AccountPasswordInputSettings &new_settings, const QVariant &attachedData, Session *session) {
    if(!session) session = mMainSession;
    CHECK_SESSION(session)
    DEBUG_FUNCTION
    OutboundPkt p(mSettings);
    INIT_MAIN_CONNECTION(session)
    Functions::Account::updatePasswordSettings(&p, current_password_hash, new_settings);
    return session->sendQuery(p, &accountUpdatePasswordSettingsMethods, attachedData, "Account->updatePasswordSettings" );
}

void TelegramApi::onAccountUpdatePasswordSettingsAnswer(Query *q, InboundPkt &inboundPkt) {
    const bool result = Functions::Account::updatePasswordSettingsResult(&inboundPkt);
    Q_EMIT accountUpdatePasswordSettingsAnswer(q->mainMsgId(), result, q->extra());
}

void TelegramApi::onAccountUpdatePasswordSettingsError(Query *q, qint32 errorCode, const QString &errorText) {
    bool accepted = false;
    onError(q, errorCode, errorText, q->extra(), accepted);
    if(!accepted)
        Q_EMIT accountUpdatePasswordSettingsError(q->mainMsgId(), errorCode, errorText, q->extra());
}


qint64 TelegramApi::authCheckPhone(const QString &phone_number, const QVariant &attachedData, Session *session) {
    if(!session) session = mMainSession;
    CHECK_SESSION(session)
    DEBUG_FUNCTION
    OutboundPkt p(mSettings);
    INIT_MAIN_CONNECTION(session)
    Functions::Auth::checkPhone(&p, phone_number);
    return session->sendQuery(p, &authCheckPhoneMethods, attachedData, "Auth->checkPhone" );
}

void TelegramApi::onAuthCheckPhoneAnswer(Query *q, InboundPkt &inboundPkt) {
    const AuthCheckedPhone &result = Functions::Auth::checkPhoneResult(&inboundPkt);
    if(result.error())
        onAuthCheckPhoneError(q, -1, "LIBQTELEGRAM_INTERNAL_ERROR");
    else
        Q_EMIT authCheckPhoneAnswer(q->mainMsgId(), result, q->extra());
}

void TelegramApi::onAuthCheckPhoneError(Query *q, qint32 errorCode, const QString &errorText) {
    bool accepted = false;
    onError(q, errorCode, errorText, q->extra(), accepted);
    if(!accepted)
        Q_EMIT authCheckPhoneError(q->mainMsgId(), errorCode, errorText, q->extra());
}

qint64 TelegramApi::authSendCode(const QString &phone_number, qint32 sms_type, qint32 api_id, const QString &api_hash, const QString &lang_code, const QVariant &attachedData, Session *session) {
    if(!session) session = mMainSession;
    CHECK_SESSION(session)
    DEBUG_FUNCTION
    OutboundPkt p(mSettings);
    INIT_MAIN_CONNECTION(session)
    Functions::Auth::sendCode(&p, phone_number, sms_type, api_id, api_hash, lang_code);
    return session->sendQuery(p, &authSendCodeMethods, attachedData, "Auth->sendCode" );
}

void TelegramApi::onAuthSendCodeAnswer(Query *q, InboundPkt &inboundPkt) {
    const AuthSentCode &result = Functions::Auth::sendCodeResult(&inboundPkt);
    if(result.error())
        onAuthSendCodeError(q, -1, "LIBQTELEGRAM_INTERNAL_ERROR");
    else
        Q_EMIT authSendCodeAnswer(q->mainMsgId(), result, q->extra());
}

void TelegramApi::onAuthSendCodeError(Query *q, qint32 errorCode, const QString &errorText) {
    bool accepted = false;
    onError(q, errorCode, errorText, q->extra(), accepted);
    if(!accepted)
        Q_EMIT authSendCodeError(q->mainMsgId(), errorCode, errorText, q->extra());
}

qint64 TelegramApi::authSendCall(const QString &phone_number, const QString &phone_code_hash, const QVariant &attachedData, Session *session) {
    if(!session) session = mMainSession;
    CHECK_SESSION(session)
    DEBUG_FUNCTION
    OutboundPkt p(mSettings);
    INIT_MAIN_CONNECTION(session)
    Functions::Auth::sendCall(&p, phone_number, phone_code_hash);
    return session->sendQuery(p, &authSendCallMethods, attachedData, "Auth->sendCall" );
}

void TelegramApi::onAuthSendCallAnswer(Query *q, InboundPkt &inboundPkt) {
    const bool result = Functions::Auth::sendCallResult(&inboundPkt);
    Q_EMIT authSendCallAnswer(q->mainMsgId(), result, q->extra());
}

void TelegramApi::onAuthSendCallError(Query *q, qint32 errorCode, const QString &errorText) {
    bool accepted = false;
    onError(q, errorCode, errorText, q->extra(), accepted);
    if(!accepted)
        Q_EMIT authSendCallError(q->mainMsgId(), errorCode, errorText, q->extra());
}

qint64 TelegramApi::authSignUp(const QString &phone_number, const QString &phone_code_hash, const QString &phone_code, const QString &first_name, const QString &last_name, const QVariant &attachedData, Session *session) {
    if(!session) session = mMainSession;
    CHECK_SESSION(session)
    DEBUG_FUNCTION
    OutboundPkt p(mSettings);
    INIT_MAIN_CONNECTION(session)
    Functions::Auth::signUp(&p, phone_number, phone_code_hash, phone_code, first_name, last_name);
    return session->sendQuery(p, &authSignUpMethods, attachedData, "Auth->signUp" );
}

void TelegramApi::onAuthSignUpAnswer(Query *q, InboundPkt &inboundPkt) {
    const AuthAuthorization &result = Functions::Auth::signUpResult(&inboundPkt);
    if(result.error())
        onAuthSignUpError(q, -1, "LIBQTELEGRAM_INTERNAL_ERROR");
    else
        Q_EMIT authSignUpAnswer(q->mainMsgId(), result, q->extra());
}

void TelegramApi::onAuthSignUpError(Query *q, qint32 errorCode, const QString &errorText) {
    bool accepted = false;
    onError(q, errorCode, errorText, q->extra(), accepted);
    if(!accepted)
        Q_EMIT authSignUpError(q->mainMsgId(), errorCode, errorText, q->extra());
}

qint64 TelegramApi::authSignIn(const QString &phone_number, const QString &phone_code_hash, const QString &phone_code, const QVariant &attachedData, Session *session) {
    if(!session) session = mMainSession;
    CHECK_SESSION(session)
    DEBUG_FUNCTION
    OutboundPkt p(mSettings);
    INIT_MAIN_CONNECTION(session)
    Functions::Auth::signIn(&p, phone_number, phone_code_hash, phone_code);
    return session->sendQuery(p, &authSignInMethods, attachedData, "Auth->signIn" );
}

void TelegramApi::onAuthSignInAnswer(Query *q, InboundPkt &inboundPkt) {
    const AuthAuthorization &result = Functions::Auth::signInResult(&inboundPkt);
    if(result.error())
        onAuthSignInError(q, -1, "LIBQTELEGRAM_INTERNAL_ERROR");
    else
        Q_EMIT authSignInAnswer(q->mainMsgId(), result, q->extra());
}

void TelegramApi::onAuthSignInError(Query *q, qint32 errorCode, const QString &errorText) {
    bool accepted = false;
    onError(q, errorCode, errorText, q->extra(), accepted);
    if(!accepted)
        Q_EMIT authSignInError(q->mainMsgId(), errorCode, errorText, q->extra());
}

qint64 TelegramApi::authLogOut(const QVariant &attachedData, Session *session) {
    if(!session) session = mMainSession;
    CHECK_SESSION(session)
    DEBUG_FUNCTION
    OutboundPkt p(mSettings);
    INIT_MAIN_CONNECTION(session)
    Functions::Auth::logOut(&p);
    return session->sendQuery(p, &authLogOutMethods, attachedData, "Auth->logOut" );
}

void TelegramApi::onAuthLogOutAnswer(Query *q, InboundPkt &inboundPkt) {
    const bool result = Functions::Auth::logOutResult(&inboundPkt);
    Q_EMIT authLogOutAnswer(q->mainMsgId(), result, q->extra());
}

void TelegramApi::onAuthLogOutError(Query *q, qint32 errorCode, const QString &errorText) {
    bool accepted = false;
    onError(q, errorCode, errorText, q->extra(), accepted);
    if(!accepted)
        Q_EMIT authLogOutError(q->mainMsgId(), errorCode, errorText, q->extra());
}

qint64 TelegramApi::authResetAuthorizations(const QVariant &attachedData, Session *session) {
    if(!session) session = mMainSession;
    CHECK_SESSION(session)
    DEBUG_FUNCTION
    OutboundPkt p(mSettings);
    INIT_MAIN_CONNECTION(session)
    Functions::Auth::resetAuthorizations(&p);
    return session->sendQuery(p, &authResetAuthorizationsMethods, attachedData, "Auth->resetAuthorizations" );
}

void TelegramApi::onAuthResetAuthorizationsAnswer(Query *q, InboundPkt &inboundPkt) {
    const bool result = Functions::Auth::resetAuthorizationsResult(&inboundPkt);
    Q_EMIT authResetAuthorizationsAnswer(q->mainMsgId(), result, q->extra());
}

void TelegramApi::onAuthResetAuthorizationsError(Query *q, qint32 errorCode, const QString &errorText) {
    bool accepted = false;
    onError(q, errorCode, errorText, q->extra(), accepted);
    if(!accepted)
        Q_EMIT authResetAuthorizationsError(q->mainMsgId(), errorCode, errorText, q->extra());
}

qint64 TelegramApi::authSendInvites(const QList<QString> &phone_numbers, const QString &message, const QVariant &attachedData, Session *session) {
    if(!session) session = mMainSession;
    CHECK_SESSION(session)
    DEBUG_FUNCTION
    OutboundPkt p(mSettings);
    INIT_MAIN_CONNECTION(session)
    Functions::Auth::sendInvites(&p, phone_numbers, message);
    return session->sendQuery(p, &authSendInvitesMethods, attachedData, "Auth->sendInvites" );
}

void TelegramApi::onAuthSendInvitesAnswer(Query *q, InboundPkt &inboundPkt) {
    const bool result = Functions::Auth::sendInvitesResult(&inboundPkt);
    Q_EMIT authSendInvitesAnswer(q->mainMsgId(), result, q->extra());
}

void TelegramApi::onAuthSendInvitesError(Query *q, qint32 errorCode, const QString &errorText) {
    bool accepted = false;
    onError(q, errorCode, errorText, q->extra(), accepted);
    if(!accepted)
        Q_EMIT authSendInvitesError(q->mainMsgId(), errorCode, errorText, q->extra());
}

qint64 TelegramApi::authExportAuthorization(qint32 dc_id, const QVariant &attachedData, Session *session) {
    if(!session) session = mMainSession;
    CHECK_SESSION(session)
    DEBUG_FUNCTION
    OutboundPkt p(mSettings);
    INIT_MAIN_CONNECTION(session)
    Functions::Auth::exportAuthorization(&p, dc_id);
    return session->sendQuery(p, &authExportAuthorizationMethods, attachedData, "Auth->exportAuthorization" );
}

void TelegramApi::onAuthExportAuthorizationAnswer(Query *q, InboundPkt &inboundPkt) {
    const AuthExportedAuthorization &result = Functions::Auth::exportAuthorizationResult(&inboundPkt);
    if(result.error())
        onAuthExportAuthorizationError(q, -1, "LIBQTELEGRAM_INTERNAL_ERROR");
    else
        Q_EMIT authExportAuthorizationAnswer(q->mainMsgId(), result, q->extra());
}

void TelegramApi::onAuthExportAuthorizationError(Query *q, qint32 errorCode, const QString &errorText) {
    bool accepted = false;
    onError(q, errorCode, errorText, q->extra(), accepted);
    if(!accepted)
        Q_EMIT authExportAuthorizationError(q->mainMsgId(), errorCode, errorText, q->extra());
}

qint64 TelegramApi::authImportAuthorization(qint32 id, const QByteArray &bytes, const QVariant &attachedData, Session *session) {
    if(!session) session = mMainSession;
    CHECK_SESSION(session)
    DEBUG_FUNCTION
    OutboundPkt p(mSettings);
    INIT_MAIN_CONNECTION(session)
    Functions::Auth::importAuthorization(&p, id, bytes);
    return session->sendQuery(p, &authImportAuthorizationMethods, attachedData, "Auth->importAuthorization" );
}

void TelegramApi::onAuthImportAuthorizationAnswer(Query *q, InboundPkt &inboundPkt) {
    const AuthAuthorization &result = Functions::Auth::importAuthorizationResult(&inboundPkt);
    if(result.error())
        onAuthImportAuthorizationError(q, -1, "LIBQTELEGRAM_INTERNAL_ERROR");
    else
        Q_EMIT authImportAuthorizationAnswer(q->mainMsgId(), result, q->extra());
}

void TelegramApi::onAuthImportAuthorizationError(Query *q, qint32 errorCode, const QString &errorText) {
    bool accepted = false;
    onError(q, errorCode, errorText, q->extra(), accepted);
    if(!accepted)
        Q_EMIT authImportAuthorizationError(q->mainMsgId(), errorCode, errorText, q->extra());
}

qint64 TelegramApi::authBindTempAuthKey(qint64 perm_auth_key_id, qint64 nonce, qint32 expires_at, const QByteArray &encrypted_message, const QVariant &attachedData, Session *session) {
    if(!session) session = mMainSession;
    CHECK_SESSION(session)
    DEBUG_FUNCTION
    OutboundPkt p(mSettings);
    INIT_MAIN_CONNECTION(session)
    Functions::Auth::bindTempAuthKey(&p, perm_auth_key_id, nonce, expires_at, encrypted_message);
    return session->sendQuery(p, &authBindTempAuthKeyMethods, attachedData, "Auth->bindTempAuthKey" );
}

void TelegramApi::onAuthBindTempAuthKeyAnswer(Query *q, InboundPkt &inboundPkt) {
    const bool result = Functions::Auth::bindTempAuthKeyResult(&inboundPkt);
    Q_EMIT authBindTempAuthKeyAnswer(q->mainMsgId(), result, q->extra());
}

void TelegramApi::onAuthBindTempAuthKeyError(Query *q, qint32 errorCode, const QString &errorText) {
    bool accepted = false;
    onError(q, errorCode, errorText, q->extra(), accepted);
    if(!accepted)
        Q_EMIT authBindTempAuthKeyError(q->mainMsgId(), errorCode, errorText, q->extra());
}

qint64 TelegramApi::authSendSms(const QString &phone_number, const QString &phone_code_hash, const QVariant &attachedData, Session *session) {
    if(!session) session = mMainSession;
    CHECK_SESSION(session)
    DEBUG_FUNCTION
    OutboundPkt p(mSettings);
    INIT_MAIN_CONNECTION(session)
    Functions::Auth::sendSms(&p, phone_number, phone_code_hash);
    return session->sendQuery(p, &authSendSmsMethods, attachedData, "Auth->sendSms" );
}

void TelegramApi::onAuthSendSmsAnswer(Query *q, InboundPkt &inboundPkt) {
    const bool result = Functions::Auth::sendSmsResult(&inboundPkt);
    Q_EMIT authSendSmsAnswer(q->mainMsgId(), result, q->extra());
}

void TelegramApi::onAuthSendSmsError(Query *q, qint32 errorCode, const QString &errorText) {
    bool accepted = false;
    onError(q, errorCode, errorText, q->extra(), accepted);
    if(!accepted)
        Q_EMIT authSendSmsError(q->mainMsgId(), errorCode, errorText, q->extra());
}

qint64 TelegramApi::authImportBotAuthorization(qint32 flags, qint32 api_id, const QString &api_hash, const QString &bot_auth_token, const QVariant &attachedData, Session *session) {
    if(!session) session = mMainSession;
    CHECK_SESSION(session)
    DEBUG_FUNCTION
    OutboundPkt p(mSettings);
    INIT_MAIN_CONNECTION(session)
    Functions::Auth::importBotAuthorization(&p, flags, api_id, api_hash, bot_auth_token);
    return session->sendQuery(p, &authImportBotAuthorizationMethods, attachedData, "Auth->importBotAuthorization" );
}

void TelegramApi::onAuthImportBotAuthorizationAnswer(Query *q, InboundPkt &inboundPkt) {
    const AuthAuthorization &result = Functions::Auth::importBotAuthorizationResult(&inboundPkt);
    if(result.error())
        onAuthImportBotAuthorizationError(q, -1, "LIBQTELEGRAM_INTERNAL_ERROR");
    else
        Q_EMIT authImportBotAuthorizationAnswer(q->mainMsgId(), result, q->extra());
}

void TelegramApi::onAuthImportBotAuthorizationError(Query *q, qint32 errorCode, const QString &errorText) {
    bool accepted = false;
    onError(q, errorCode, errorText, q->extra(), accepted);
    if(!accepted)
        Q_EMIT authImportBotAuthorizationError(q->mainMsgId(), errorCode, errorText, q->extra());
}

qint64 TelegramApi::authCheckPassword(const QByteArray &password_hash, const QVariant &attachedData, Session *session) {
    if(!session) session = mMainSession;
    CHECK_SESSION(session)
    DEBUG_FUNCTION
    OutboundPkt p(mSettings);
    INIT_MAIN_CONNECTION(session)
    Functions::Auth::checkPassword(&p, password_hash);
    return session->sendQuery(p, &authCheckPasswordMethods, attachedData, "Auth->checkPassword" );
}

void TelegramApi::onAuthCheckPasswordAnswer(Query *q, InboundPkt &inboundPkt) {
    const AuthAuthorization &result = Functions::Auth::checkPasswordResult(&inboundPkt);
    if(result.error())
        onAuthCheckPasswordError(q, -1, "LIBQTELEGRAM_INTERNAL_ERROR");
    else
        Q_EMIT authCheckPasswordAnswer(q->mainMsgId(), result, q->extra());
}

void TelegramApi::onAuthCheckPasswordError(Query *q, qint32 errorCode, const QString &errorText) {
    bool accepted = false;
    onError(q, errorCode, errorText, q->extra(), accepted);
    if(!accepted)
        Q_EMIT authCheckPasswordError(q->mainMsgId(), errorCode, errorText, q->extra());
}

qint64 TelegramApi::authRequestPasswordRecovery(const QVariant &attachedData, Session *session) {
    if(!session) session = mMainSession;
    CHECK_SESSION(session)
    DEBUG_FUNCTION
    OutboundPkt p(mSettings);
    INIT_MAIN_CONNECTION(session)
    Functions::Auth::requestPasswordRecovery(&p);
    return session->sendQuery(p, &authRequestPasswordRecoveryMethods, attachedData, "Auth->requestPasswordRecovery" );
}

void TelegramApi::onAuthRequestPasswordRecoveryAnswer(Query *q, InboundPkt &inboundPkt) {
    const AuthPasswordRecovery &result = Functions::Auth::requestPasswordRecoveryResult(&inboundPkt);
    if(result.error())
        onAuthRequestPasswordRecoveryError(q, -1, "LIBQTELEGRAM_INTERNAL_ERROR");
    else
        Q_EMIT authRequestPasswordRecoveryAnswer(q->mainMsgId(), result, q->extra());
}

void TelegramApi::onAuthRequestPasswordRecoveryError(Query *q, qint32 errorCode, const QString &errorText) {
    bool accepted = false;
    onError(q, errorCode, errorText, q->extra(), accepted);
    if(!accepted)
        Q_EMIT authRequestPasswordRecoveryError(q->mainMsgId(), errorCode, errorText, q->extra());
}

qint64 TelegramApi::authRecoverPassword(const QString &code, const QVariant &attachedData, Session *session) {
    if(!session) session = mMainSession;
    CHECK_SESSION(session)
    DEBUG_FUNCTION
    OutboundPkt p(mSettings);
    INIT_MAIN_CONNECTION(session)
    Functions::Auth::recoverPassword(&p, code);
    return session->sendQuery(p, &authRecoverPasswordMethods, attachedData, "Auth->recoverPassword" );
}

void TelegramApi::onAuthRecoverPasswordAnswer(Query *q, InboundPkt &inboundPkt) {
    const AuthAuthorization &result = Functions::Auth::recoverPasswordResult(&inboundPkt);
    if(result.error())
        onAuthRecoverPasswordError(q, -1, "LIBQTELEGRAM_INTERNAL_ERROR");
    else
        Q_EMIT authRecoverPasswordAnswer(q->mainMsgId(), result, q->extra());
}

void TelegramApi::onAuthRecoverPasswordError(Query *q, qint32 errorCode, const QString &errorText) {
    bool accepted = false;
    onError(q, errorCode, errorText, q->extra(), accepted);
    if(!accepted)
        Q_EMIT authRecoverPasswordError(q->mainMsgId(), errorCode, errorText, q->extra());
}


qint64 TelegramApi::channelsGetDialogs(qint32 offset, qint32 limit, const QVariant &attachedData, Session *session) {
    if(!session) session = mMainSession;
    CHECK_SESSION(session)
    DEBUG_FUNCTION
    OutboundPkt p(mSettings);
    INIT_MAIN_CONNECTION(session)
    Functions::Channels::getDialogs(&p, offset, limit);
    return session->sendQuery(p, &channelsGetDialogsMethods, attachedData, "Channels->getDialogs" );
}

void TelegramApi::onChannelsGetDialogsAnswer(Query *q, InboundPkt &inboundPkt) {
    const MessagesDialogs &result = Functions::Channels::getDialogsResult(&inboundPkt);
    if(result.error())
        onChannelsGetDialogsError(q, -1, "LIBQTELEGRAM_INTERNAL_ERROR");
    else
        Q_EMIT channelsGetDialogsAnswer(q->mainMsgId(), result, q->extra());
}

void TelegramApi::onChannelsGetDialogsError(Query *q, qint32 errorCode, const QString &errorText) {
    bool accepted = false;
    onError(q, errorCode, errorText, q->extra(), accepted);
    if(!accepted)
        Q_EMIT channelsGetDialogsError(q->mainMsgId(), errorCode, errorText, q->extra());
}

qint64 TelegramApi::channelsGetImportantHistory(const InputChannel &channel, qint32 offset_id, qint32 offset_date, qint32 add_offset, qint32 limit, qint32 max_id, qint32 min_id, const QVariant &attachedData, Session *session) {
    if(!session) session = mMainSession;
    CHECK_SESSION(session)
    DEBUG_FUNCTION
    OutboundPkt p(mSettings);
    INIT_MAIN_CONNECTION(session)
    Functions::Channels::getImportantHistory(&p, channel, offset_id, offset_date, add_offset, limit, max_id, min_id);
    return session->sendQuery(p, &channelsGetImportantHistoryMethods, attachedData, "Channels->getImportantHistory" );
}

void TelegramApi::onChannelsGetImportantHistoryAnswer(Query *q, InboundPkt &inboundPkt) {
    const MessagesMessages &result = Functions::Channels::getImportantHistoryResult(&inboundPkt);
    if(result.error())
        onChannelsGetImportantHistoryError(q, -1, "LIBQTELEGRAM_INTERNAL_ERROR");
    else
        Q_EMIT channelsGetImportantHistoryAnswer(q->mainMsgId(), result, q->extra());
}

void TelegramApi::onChannelsGetImportantHistoryError(Query *q, qint32 errorCode, const QString &errorText) {
    bool accepted = false;
    onError(q, errorCode, errorText, q->extra(), accepted);
    if(!accepted)
        Q_EMIT channelsGetImportantHistoryError(q->mainMsgId(), errorCode, errorText, q->extra());
}

qint64 TelegramApi::channelsReadHistory(const InputChannel &channel, qint32 max_id, const QVariant &attachedData, Session *session) {
    if(!session) session = mMainSession;
    CHECK_SESSION(session)
    DEBUG_FUNCTION
    OutboundPkt p(mSettings);
    INIT_MAIN_CONNECTION(session)
    Functions::Channels::readHistory(&p, channel, max_id);
    return session->sendQuery(p, &channelsReadHistoryMethods, attachedData, "Channels->readHistory" );
}

void TelegramApi::onChannelsReadHistoryAnswer(Query *q, InboundPkt &inboundPkt) {
    const bool result = Functions::Channels::readHistoryResult(&inboundPkt);
    Q_EMIT channelsReadHistoryAnswer(q->mainMsgId(), result, q->extra());
}

void TelegramApi::onChannelsReadHistoryError(Query *q, qint32 errorCode, const QString &errorText) {
    bool accepted = false;
    onError(q, errorCode, errorText, q->extra(), accepted);
    if(!accepted)
        Q_EMIT channelsReadHistoryError(q->mainMsgId(), errorCode, errorText, q->extra());
}

qint64 TelegramApi::channelsDeleteMessages(const InputChannel &channel, const QList<qint32> &id, const QVariant &attachedData, Session *session) {
    if(!session) session = mMainSession;
    CHECK_SESSION(session)
    DEBUG_FUNCTION
    OutboundPkt p(mSettings);
    INIT_MAIN_CONNECTION(session)
    Functions::Channels::deleteMessages(&p, channel, id);
    return session->sendQuery(p, &channelsDeleteMessagesMethods, attachedData, "Channels->deleteMessages" );
}

void TelegramApi::onChannelsDeleteMessagesAnswer(Query *q, InboundPkt &inboundPkt) {
    const MessagesAffectedMessages &result = Functions::Channels::deleteMessagesResult(&inboundPkt);
    if(result.error())
        onChannelsDeleteMessagesError(q, -1, "LIBQTELEGRAM_INTERNAL_ERROR");
    else
        Q_EMIT channelsDeleteMessagesAnswer(q->mainMsgId(), result, q->extra());
}

void TelegramApi::onChannelsDeleteMessagesError(Query *q, qint32 errorCode, const QString &errorText) {
    bool accepted = false;
    onError(q, errorCode, errorText, q->extra(), accepted);
    if(!accepted)
        Q_EMIT channelsDeleteMessagesError(q->mainMsgId(), errorCode, errorText, q->extra());
}

qint64 TelegramApi::channelsDeleteUserHistory(const InputChannel &channel, const InputUser &user_id, const QVariant &attachedData, Session *session) {
    if(!session) session = mMainSession;
    CHECK_SESSION(session)
    DEBUG_FUNCTION
    OutboundPkt p(mSettings);
    INIT_MAIN_CONNECTION(session)
    Functions::Channels::deleteUserHistory(&p, channel, user_id);
    return session->sendQuery(p, &channelsDeleteUserHistoryMethods, attachedData, "Channels->deleteUserHistory" );
}

void TelegramApi::onChannelsDeleteUserHistoryAnswer(Query *q, InboundPkt &inboundPkt) {
    const MessagesAffectedHistory &result = Functions::Channels::deleteUserHistoryResult(&inboundPkt);
    if(result.error())
        onChannelsDeleteUserHistoryError(q, -1, "LIBQTELEGRAM_INTERNAL_ERROR");
    else
        Q_EMIT channelsDeleteUserHistoryAnswer(q->mainMsgId(), result, q->extra());
}

void TelegramApi::onChannelsDeleteUserHistoryError(Query *q, qint32 errorCode, const QString &errorText) {
    bool accepted = false;
    onError(q, errorCode, errorText, q->extra(), accepted);
    if(!accepted)
        Q_EMIT channelsDeleteUserHistoryError(q->mainMsgId(), errorCode, errorText, q->extra());
}

qint64 TelegramApi::channelsReportSpam(const InputChannel &channel, const InputUser &user_id, const QList<qint32> &id, const QVariant &attachedData, Session *session) {
    if(!session) session = mMainSession;
    CHECK_SESSION(session)
    DEBUG_FUNCTION
    OutboundPkt p(mSettings);
    INIT_MAIN_CONNECTION(session)
    Functions::Channels::reportSpam(&p, channel, user_id, id);
    return session->sendQuery(p, &channelsReportSpamMethods, attachedData, "Channels->reportSpam" );
}

void TelegramApi::onChannelsReportSpamAnswer(Query *q, InboundPkt &inboundPkt) {
    const bool result = Functions::Channels::reportSpamResult(&inboundPkt);
    Q_EMIT channelsReportSpamAnswer(q->mainMsgId(), result, q->extra());
}

void TelegramApi::onChannelsReportSpamError(Query *q, qint32 errorCode, const QString &errorText) {
    bool accepted = false;
    onError(q, errorCode, errorText, q->extra(), accepted);
    if(!accepted)
        Q_EMIT channelsReportSpamError(q->mainMsgId(), errorCode, errorText, q->extra());
}

qint64 TelegramApi::channelsGetMessages(const InputChannel &channel, const QList<qint32> &id, const QVariant &attachedData, Session *session) {
    if(!session) session = mMainSession;
    CHECK_SESSION(session)
    DEBUG_FUNCTION
    OutboundPkt p(mSettings);
    INIT_MAIN_CONNECTION(session)
    Functions::Channels::getMessages(&p, channel, id);
    return session->sendQuery(p, &channelsGetMessagesMethods, attachedData, "Channels->getMessages" );
}

void TelegramApi::onChannelsGetMessagesAnswer(Query *q, InboundPkt &inboundPkt) {
    const MessagesMessages &result = Functions::Channels::getMessagesResult(&inboundPkt);
    if(result.error())
        onChannelsGetMessagesError(q, -1, "LIBQTELEGRAM_INTERNAL_ERROR");
    else
        Q_EMIT channelsGetMessagesAnswer(q->mainMsgId(), result, q->extra());
}

void TelegramApi::onChannelsGetMessagesError(Query *q, qint32 errorCode, const QString &errorText) {
    bool accepted = false;
    onError(q, errorCode, errorText, q->extra(), accepted);
    if(!accepted)
        Q_EMIT channelsGetMessagesError(q->mainMsgId(), errorCode, errorText, q->extra());
}

qint64 TelegramApi::channelsGetParticipants(const InputChannel &channel, const ChannelParticipantsFilter &filter, qint32 offset, qint32 limit, const QVariant &attachedData, Session *session) {
    if(!session) session = mMainSession;
    CHECK_SESSION(session)
    DEBUG_FUNCTION
    OutboundPkt p(mSettings);
    INIT_MAIN_CONNECTION(session)
    Functions::Channels::getParticipants(&p, channel, filter, offset, limit);
    return session->sendQuery(p, &channelsGetParticipantsMethods, attachedData, "Channels->getParticipants" );
}

void TelegramApi::onChannelsGetParticipantsAnswer(Query *q, InboundPkt &inboundPkt) {
    const ChannelsChannelParticipants &result = Functions::Channels::getParticipantsResult(&inboundPkt);
    if(result.error())
        onChannelsGetParticipantsError(q, -1, "LIBQTELEGRAM_INTERNAL_ERROR");
    else
        Q_EMIT channelsGetParticipantsAnswer(q->mainMsgId(), result, q->extra());
}

void TelegramApi::onChannelsGetParticipantsError(Query *q, qint32 errorCode, const QString &errorText) {
    bool accepted = false;
    onError(q, errorCode, errorText, q->extra(), accepted);
    if(!accepted)
        Q_EMIT channelsGetParticipantsError(q->mainMsgId(), errorCode, errorText, q->extra());
}

qint64 TelegramApi::channelsGetParticipant(const InputChannel &channel, const InputUser &user_id, const QVariant &attachedData, Session *session) {
    if(!session) session = mMainSession;
    CHECK_SESSION(session)
    DEBUG_FUNCTION
    OutboundPkt p(mSettings);
    INIT_MAIN_CONNECTION(session)
    Functions::Channels::getParticipant(&p, channel, user_id);
    return session->sendQuery(p, &channelsGetParticipantMethods, attachedData, "Channels->getParticipant" );
}

void TelegramApi::onChannelsGetParticipantAnswer(Query *q, InboundPkt &inboundPkt) {
    const ChannelsChannelParticipant &result = Functions::Channels::getParticipantResult(&inboundPkt);
    if(result.error())
        onChannelsGetParticipantError(q, -1, "LIBQTELEGRAM_INTERNAL_ERROR");
    else
        Q_EMIT channelsGetParticipantAnswer(q->mainMsgId(), result, q->extra());
}

void TelegramApi::onChannelsGetParticipantError(Query *q, qint32 errorCode, const QString &errorText) {
    bool accepted = false;
    onError(q, errorCode, errorText, q->extra(), accepted);
    if(!accepted)
        Q_EMIT channelsGetParticipantError(q->mainMsgId(), errorCode, errorText, q->extra());
}

qint64 TelegramApi::channelsGetChannels(const QList<InputChannel> &id, const QVariant &attachedData, Session *session) {
    if(!session) session = mMainSession;
    CHECK_SESSION(session)
    DEBUG_FUNCTION
    OutboundPkt p(mSettings);
    INIT_MAIN_CONNECTION(session)
    Functions::Channels::getChannels(&p, id);
    return session->sendQuery(p, &channelsGetChannelsMethods, attachedData, "Channels->getChannels" );
}

void TelegramApi::onChannelsGetChannelsAnswer(Query *q, InboundPkt &inboundPkt) {
    const MessagesChats &result = Functions::Channels::getChannelsResult(&inboundPkt);
    if(result.error())
        onChannelsGetChannelsError(q, -1, "LIBQTELEGRAM_INTERNAL_ERROR");
    else
        Q_EMIT channelsGetChannelsAnswer(q->mainMsgId(), result, q->extra());
}

void TelegramApi::onChannelsGetChannelsError(Query *q, qint32 errorCode, const QString &errorText) {
    bool accepted = false;
    onError(q, errorCode, errorText, q->extra(), accepted);
    if(!accepted)
        Q_EMIT channelsGetChannelsError(q->mainMsgId(), errorCode, errorText, q->extra());
}

qint64 TelegramApi::channelsGetFullChannel(const InputChannel &channel, const QVariant &attachedData, Session *session) {
    if(!session) session = mMainSession;
    CHECK_SESSION(session)
    DEBUG_FUNCTION
    OutboundPkt p(mSettings);
    INIT_MAIN_CONNECTION(session)
    Functions::Channels::getFullChannel(&p, channel);
    return session->sendQuery(p, &channelsGetFullChannelMethods, attachedData, "Channels->getFullChannel" );
}

void TelegramApi::onChannelsGetFullChannelAnswer(Query *q, InboundPkt &inboundPkt) {
    const MessagesChatFull &result = Functions::Channels::getFullChannelResult(&inboundPkt);
    if(result.error())
        onChannelsGetFullChannelError(q, -1, "LIBQTELEGRAM_INTERNAL_ERROR");
    else
        Q_EMIT channelsGetFullChannelAnswer(q->mainMsgId(), result, q->extra());
}

void TelegramApi::onChannelsGetFullChannelError(Query *q, qint32 errorCode, const QString &errorText) {
    bool accepted = false;
    onError(q, errorCode, errorText, q->extra(), accepted);
    if(!accepted)
        Q_EMIT channelsGetFullChannelError(q->mainMsgId(), errorCode, errorText, q->extra());
}

qint64 TelegramApi::channelsCreateChannel(bool broadcast, bool megagroup, const QString &title, const QString &about, const QVariant &attachedData, Session *session) {
    if(!session) session = mMainSession;
    CHECK_SESSION(session)
    DEBUG_FUNCTION
    OutboundPkt p(mSettings);
    INIT_MAIN_CONNECTION(session)
    Functions::Channels::createChannel(&p, broadcast, megagroup, title, about);
    return session->sendQuery(p, &channelsCreateChannelMethods, attachedData, "Channels->createChannel" );
}

void TelegramApi::onChannelsCreateChannelAnswer(Query *q, InboundPkt &inboundPkt) {
    const UpdatesType &result = Functions::Channels::createChannelResult(&inboundPkt);
    if(result.error())
        onChannelsCreateChannelError(q, -1, "LIBQTELEGRAM_INTERNAL_ERROR");
    else
        Q_EMIT channelsCreateChannelAnswer(q->mainMsgId(), result, q->extra());
}

void TelegramApi::onChannelsCreateChannelError(Query *q, qint32 errorCode, const QString &errorText) {
    bool accepted = false;
    onError(q, errorCode, errorText, q->extra(), accepted);
    if(!accepted)
        Q_EMIT channelsCreateChannelError(q->mainMsgId(), errorCode, errorText, q->extra());
}

qint64 TelegramApi::channelsEditAbout(const InputChannel &channel, const QString &about, const QVariant &attachedData, Session *session) {
    if(!session) session = mMainSession;
    CHECK_SESSION(session)
    DEBUG_FUNCTION
    OutboundPkt p(mSettings);
    INIT_MAIN_CONNECTION(session)
    Functions::Channels::editAbout(&p, channel, about);
    return session->sendQuery(p, &channelsEditAboutMethods, attachedData, "Channels->editAbout" );
}

void TelegramApi::onChannelsEditAboutAnswer(Query *q, InboundPkt &inboundPkt) {
    const bool result = Functions::Channels::editAboutResult(&inboundPkt);
    Q_EMIT channelsEditAboutAnswer(q->mainMsgId(), result, q->extra());
}

void TelegramApi::onChannelsEditAboutError(Query *q, qint32 errorCode, const QString &errorText) {
    bool accepted = false;
    onError(q, errorCode, errorText, q->extra(), accepted);
    if(!accepted)
        Q_EMIT channelsEditAboutError(q->mainMsgId(), errorCode, errorText, q->extra());
}

qint64 TelegramApi::channelsEditAdmin(const InputChannel &channel, const InputUser &user_id, const ChannelParticipantRole &role, const QVariant &attachedData, Session *session) {
    if(!session) session = mMainSession;
    CHECK_SESSION(session)
    DEBUG_FUNCTION
    OutboundPkt p(mSettings);
    INIT_MAIN_CONNECTION(session)
    Functions::Channels::editAdmin(&p, channel, user_id, role);
    return session->sendQuery(p, &channelsEditAdminMethods, attachedData, "Channels->editAdmin" );
}

void TelegramApi::onChannelsEditAdminAnswer(Query *q, InboundPkt &inboundPkt) {
    const UpdatesType &result = Functions::Channels::editAdminResult(&inboundPkt);
    if(result.error())
        onChannelsEditAdminError(q, -1, "LIBQTELEGRAM_INTERNAL_ERROR");
    else
        Q_EMIT channelsEditAdminAnswer(q->mainMsgId(), result, q->extra());
}

void TelegramApi::onChannelsEditAdminError(Query *q, qint32 errorCode, const QString &errorText) {
    bool accepted = false;
    onError(q, errorCode, errorText, q->extra(), accepted);
    if(!accepted)
        Q_EMIT channelsEditAdminError(q->mainMsgId(), errorCode, errorText, q->extra());
}

qint64 TelegramApi::channelsEditTitle(const InputChannel &channel, const QString &title, const QVariant &attachedData, Session *session) {
    if(!session) session = mMainSession;
    CHECK_SESSION(session)
    DEBUG_FUNCTION
    OutboundPkt p(mSettings);
    INIT_MAIN_CONNECTION(session)
    Functions::Channels::editTitle(&p, channel, title);
    return session->sendQuery(p, &channelsEditTitleMethods, attachedData, "Channels->editTitle" );
}

void TelegramApi::onChannelsEditTitleAnswer(Query *q, InboundPkt &inboundPkt) {
    const UpdatesType &result = Functions::Channels::editTitleResult(&inboundPkt);
    if(result.error())
        onChannelsEditTitleError(q, -1, "LIBQTELEGRAM_INTERNAL_ERROR");
    else
        Q_EMIT channelsEditTitleAnswer(q->mainMsgId(), result, q->extra());
}

void TelegramApi::onChannelsEditTitleError(Query *q, qint32 errorCode, const QString &errorText) {
    bool accepted = false;
    onError(q, errorCode, errorText, q->extra(), accepted);
    if(!accepted)
        Q_EMIT channelsEditTitleError(q->mainMsgId(), errorCode, errorText, q->extra());
}

qint64 TelegramApi::channelsEditPhoto(const InputChannel &channel, const InputChatPhoto &photo, const QVariant &attachedData, Session *session) {
    if(!session) session = mMainSession;
    CHECK_SESSION(session)
    DEBUG_FUNCTION
    OutboundPkt p(mSettings);
    INIT_MAIN_CONNECTION(session)
    Functions::Channels::editPhoto(&p, channel, photo);
    return session->sendQuery(p, &channelsEditPhotoMethods, attachedData, "Channels->editPhoto" );
}

void TelegramApi::onChannelsEditPhotoAnswer(Query *q, InboundPkt &inboundPkt) {
    const UpdatesType &result = Functions::Channels::editPhotoResult(&inboundPkt);
    if(result.error())
        onChannelsEditPhotoError(q, -1, "LIBQTELEGRAM_INTERNAL_ERROR");
    else
        Q_EMIT channelsEditPhotoAnswer(q->mainMsgId(), result, q->extra());
}

void TelegramApi::onChannelsEditPhotoError(Query *q, qint32 errorCode, const QString &errorText) {
    bool accepted = false;
    onError(q, errorCode, errorText, q->extra(), accepted);
    if(!accepted)
        Q_EMIT channelsEditPhotoError(q->mainMsgId(), errorCode, errorText, q->extra());
}

qint64 TelegramApi::channelsToggleComments(const InputChannel &channel, bool enabled, const QVariant &attachedData, Session *session) {
    if(!session) session = mMainSession;
    CHECK_SESSION(session)
    DEBUG_FUNCTION
    OutboundPkt p(mSettings);
    INIT_MAIN_CONNECTION(session)
    Functions::Channels::toggleComments(&p, channel, enabled);
    return session->sendQuery(p, &channelsToggleCommentsMethods, attachedData, "Channels->toggleComments" );
}

void TelegramApi::onChannelsToggleCommentsAnswer(Query *q, InboundPkt &inboundPkt) {
    const UpdatesType &result = Functions::Channels::toggleCommentsResult(&inboundPkt);
    if(result.error())
        onChannelsToggleCommentsError(q, -1, "LIBQTELEGRAM_INTERNAL_ERROR");
    else
        Q_EMIT channelsToggleCommentsAnswer(q->mainMsgId(), result, q->extra());
}

void TelegramApi::onChannelsToggleCommentsError(Query *q, qint32 errorCode, const QString &errorText) {
    bool accepted = false;
    onError(q, errorCode, errorText, q->extra(), accepted);
    if(!accepted)
        Q_EMIT channelsToggleCommentsError(q->mainMsgId(), errorCode, errorText, q->extra());
}

qint64 TelegramApi::channelsCheckUsername(const InputChannel &channel, const QString &username, const QVariant &attachedData, Session *session) {
    if(!session) session = mMainSession;
    CHECK_SESSION(session)
    DEBUG_FUNCTION
    OutboundPkt p(mSettings);
    INIT_MAIN_CONNECTION(session)
    Functions::Channels::checkUsername(&p, channel, username);
    return session->sendQuery(p, &channelsCheckUsernameMethods, attachedData, "Channels->checkUsername" );
}

void TelegramApi::onChannelsCheckUsernameAnswer(Query *q, InboundPkt &inboundPkt) {
    const bool result = Functions::Channels::checkUsernameResult(&inboundPkt);
    Q_EMIT channelsCheckUsernameAnswer(q->mainMsgId(), result, q->extra());
}

void TelegramApi::onChannelsCheckUsernameError(Query *q, qint32 errorCode, const QString &errorText) {
    bool accepted = false;
    onError(q, errorCode, errorText, q->extra(), accepted);
    if(!accepted)
        Q_EMIT channelsCheckUsernameError(q->mainMsgId(), errorCode, errorText, q->extra());
}

qint64 TelegramApi::channelsUpdateUsername(const InputChannel &channel, const QString &username, const QVariant &attachedData, Session *session) {
    if(!session) session = mMainSession;
    CHECK_SESSION(session)
    DEBUG_FUNCTION
    OutboundPkt p(mSettings);
    INIT_MAIN_CONNECTION(session)
    Functions::Channels::updateUsername(&p, channel, username);
    return session->sendQuery(p, &channelsUpdateUsernameMethods, attachedData, "Channels->updateUsername" );
}

void TelegramApi::onChannelsUpdateUsernameAnswer(Query *q, InboundPkt &inboundPkt) {
    const bool result = Functions::Channels::updateUsernameResult(&inboundPkt);
    Q_EMIT channelsUpdateUsernameAnswer(q->mainMsgId(), result, q->extra());
}

void TelegramApi::onChannelsUpdateUsernameError(Query *q, qint32 errorCode, const QString &errorText) {
    bool accepted = false;
    onError(q, errorCode, errorText, q->extra(), accepted);
    if(!accepted)
        Q_EMIT channelsUpdateUsernameError(q->mainMsgId(), errorCode, errorText, q->extra());
}

qint64 TelegramApi::channelsJoinChannel(const InputChannel &channel, const QVariant &attachedData, Session *session) {
    if(!session) session = mMainSession;
    CHECK_SESSION(session)
    DEBUG_FUNCTION
    OutboundPkt p(mSettings);
    INIT_MAIN_CONNECTION(session)
    Functions::Channels::joinChannel(&p, channel);
    return session->sendQuery(p, &channelsJoinChannelMethods, attachedData, "Channels->joinChannel" );
}

void TelegramApi::onChannelsJoinChannelAnswer(Query *q, InboundPkt &inboundPkt) {
    const UpdatesType &result = Functions::Channels::joinChannelResult(&inboundPkt);
    if(result.error())
        onChannelsJoinChannelError(q, -1, "LIBQTELEGRAM_INTERNAL_ERROR");
    else
        Q_EMIT channelsJoinChannelAnswer(q->mainMsgId(), result, q->extra());
}

void TelegramApi::onChannelsJoinChannelError(Query *q, qint32 errorCode, const QString &errorText) {
    bool accepted = false;
    onError(q, errorCode, errorText, q->extra(), accepted);
    if(!accepted)
        Q_EMIT channelsJoinChannelError(q->mainMsgId(), errorCode, errorText, q->extra());
}

qint64 TelegramApi::channelsLeaveChannel(const InputChannel &channel, const QVariant &attachedData, Session *session) {
    if(!session) session = mMainSession;
    CHECK_SESSION(session)
    DEBUG_FUNCTION
    OutboundPkt p(mSettings);
    INIT_MAIN_CONNECTION(session)
    Functions::Channels::leaveChannel(&p, channel);
    return session->sendQuery(p, &channelsLeaveChannelMethods, attachedData, "Channels->leaveChannel" );
}

void TelegramApi::onChannelsLeaveChannelAnswer(Query *q, InboundPkt &inboundPkt) {
    const UpdatesType &result = Functions::Channels::leaveChannelResult(&inboundPkt);
    if(result.error())
        onChannelsLeaveChannelError(q, -1, "LIBQTELEGRAM_INTERNAL_ERROR");
    else
        Q_EMIT channelsLeaveChannelAnswer(q->mainMsgId(), result, q->extra());
}

void TelegramApi::onChannelsLeaveChannelError(Query *q, qint32 errorCode, const QString &errorText) {
    bool accepted = false;
    onError(q, errorCode, errorText, q->extra(), accepted);
    if(!accepted)
        Q_EMIT channelsLeaveChannelError(q->mainMsgId(), errorCode, errorText, q->extra());
}

qint64 TelegramApi::channelsInviteToChannel(const InputChannel &channel, const QList<InputUser> &users, const QVariant &attachedData, Session *session) {
    if(!session) session = mMainSession;
    CHECK_SESSION(session)
    DEBUG_FUNCTION
    OutboundPkt p(mSettings);
    INIT_MAIN_CONNECTION(session)
    Functions::Channels::inviteToChannel(&p, channel, users);
    return session->sendQuery(p, &channelsInviteToChannelMethods, attachedData, "Channels->inviteToChannel" );
}

void TelegramApi::onChannelsInviteToChannelAnswer(Query *q, InboundPkt &inboundPkt) {
    const UpdatesType &result = Functions::Channels::inviteToChannelResult(&inboundPkt);
    if(result.error())
        onChannelsInviteToChannelError(q, -1, "LIBQTELEGRAM_INTERNAL_ERROR");
    else
        Q_EMIT channelsInviteToChannelAnswer(q->mainMsgId(), result, q->extra());
}

void TelegramApi::onChannelsInviteToChannelError(Query *q, qint32 errorCode, const QString &errorText) {
    bool accepted = false;
    onError(q, errorCode, errorText, q->extra(), accepted);
    if(!accepted)
        Q_EMIT channelsInviteToChannelError(q->mainMsgId(), errorCode, errorText, q->extra());
}

qint64 TelegramApi::channelsKickFromChannel(const InputChannel &channel, const InputUser &user_id, bool kicked, const QVariant &attachedData, Session *session) {
    if(!session) session = mMainSession;
    CHECK_SESSION(session)
    DEBUG_FUNCTION
    OutboundPkt p(mSettings);
    INIT_MAIN_CONNECTION(session)
    Functions::Channels::kickFromChannel(&p, channel, user_id, kicked);
    return session->sendQuery(p, &channelsKickFromChannelMethods, attachedData, "Channels->kickFromChannel" );
}

void TelegramApi::onChannelsKickFromChannelAnswer(Query *q, InboundPkt &inboundPkt) {
    const UpdatesType &result = Functions::Channels::kickFromChannelResult(&inboundPkt);
    if(result.error())
        onChannelsKickFromChannelError(q, -1, "LIBQTELEGRAM_INTERNAL_ERROR");
    else
        Q_EMIT channelsKickFromChannelAnswer(q->mainMsgId(), result, q->extra());
}

void TelegramApi::onChannelsKickFromChannelError(Query *q, qint32 errorCode, const QString &errorText) {
    bool accepted = false;
    onError(q, errorCode, errorText, q->extra(), accepted);
    if(!accepted)
        Q_EMIT channelsKickFromChannelError(q->mainMsgId(), errorCode, errorText, q->extra());
}

qint64 TelegramApi::channelsExportInvite(const InputChannel &channel, const QVariant &attachedData, Session *session) {
    if(!session) session = mMainSession;
    CHECK_SESSION(session)
    DEBUG_FUNCTION
    OutboundPkt p(mSettings);
    INIT_MAIN_CONNECTION(session)
    Functions::Channels::exportInvite(&p, channel);
    return session->sendQuery(p, &channelsExportInviteMethods, attachedData, "Channels->exportInvite" );
}

void TelegramApi::onChannelsExportInviteAnswer(Query *q, InboundPkt &inboundPkt) {
    const ExportedChatInvite &result = Functions::Channels::exportInviteResult(&inboundPkt);
    if(result.error())
        onChannelsExportInviteError(q, -1, "LIBQTELEGRAM_INTERNAL_ERROR");
    else
        Q_EMIT channelsExportInviteAnswer(q->mainMsgId(), result, q->extra());
}

void TelegramApi::onChannelsExportInviteError(Query *q, qint32 errorCode, const QString &errorText) {
    bool accepted = false;
    onError(q, errorCode, errorText, q->extra(), accepted);
    if(!accepted)
        Q_EMIT channelsExportInviteError(q->mainMsgId(), errorCode, errorText, q->extra());
}

qint64 TelegramApi::channelsDeleteChannel(const InputChannel &channel, const QVariant &attachedData, Session *session) {
    if(!session) session = mMainSession;
    CHECK_SESSION(session)
    DEBUG_FUNCTION
    OutboundPkt p(mSettings);
    INIT_MAIN_CONNECTION(session)
    Functions::Channels::deleteChannel(&p, channel);
    return session->sendQuery(p, &channelsDeleteChannelMethods, attachedData, "Channels->deleteChannel" );
}

void TelegramApi::onChannelsDeleteChannelAnswer(Query *q, InboundPkt &inboundPkt) {
    const UpdatesType &result = Functions::Channels::deleteChannelResult(&inboundPkt);
    if(result.error())
        onChannelsDeleteChannelError(q, -1, "LIBQTELEGRAM_INTERNAL_ERROR");
    else
        Q_EMIT channelsDeleteChannelAnswer(q->mainMsgId(), result, q->extra());
}

void TelegramApi::onChannelsDeleteChannelError(Query *q, qint32 errorCode, const QString &errorText) {
    bool accepted = false;
    onError(q, errorCode, errorText, q->extra(), accepted);
    if(!accepted)
        Q_EMIT channelsDeleteChannelError(q->mainMsgId(), errorCode, errorText, q->extra());
}

qint64 TelegramApi::channelsToggleInvites(const InputChannel &channel, bool enabled, const QVariant &attachedData, Session *session) {
    if(!session) session = mMainSession;
    CHECK_SESSION(session)
    DEBUG_FUNCTION
    OutboundPkt p(mSettings);
    INIT_MAIN_CONNECTION(session)
    Functions::Channels::toggleInvites(&p, channel, enabled);
    return session->sendQuery(p, &channelsToggleInvitesMethods, attachedData, "Channels->toggleInvites" );
}

void TelegramApi::onChannelsToggleInvitesAnswer(Query *q, InboundPkt &inboundPkt) {
    const UpdatesType &result = Functions::Channels::toggleInvitesResult(&inboundPkt);
    if(result.error())
        onChannelsToggleInvitesError(q, -1, "LIBQTELEGRAM_INTERNAL_ERROR");
    else
        Q_EMIT channelsToggleInvitesAnswer(q->mainMsgId(), result, q->extra());
}

void TelegramApi::onChannelsToggleInvitesError(Query *q, qint32 errorCode, const QString &errorText) {
    bool accepted = false;
    onError(q, errorCode, errorText, q->extra(), accepted);
    if(!accepted)
        Q_EMIT channelsToggleInvitesError(q->mainMsgId(), errorCode, errorText, q->extra());
}

qint64 TelegramApi::channelsExportMessageLink(const InputChannel &channel, qint32 id, const QVariant &attachedData, Session *session) {
    if(!session) session = mMainSession;
    CHECK_SESSION(session)
    DEBUG_FUNCTION
    OutboundPkt p(mSettings);
    INIT_MAIN_CONNECTION(session)
    Functions::Channels::exportMessageLink(&p, channel, id);
    return session->sendQuery(p, &channelsExportMessageLinkMethods, attachedData, "Channels->exportMessageLink" );
}

void TelegramApi::onChannelsExportMessageLinkAnswer(Query *q, InboundPkt &inboundPkt) {
    const ExportedMessageLink &result = Functions::Channels::exportMessageLinkResult(&inboundPkt);
    if(result.error())
        onChannelsExportMessageLinkError(q, -1, "LIBQTELEGRAM_INTERNAL_ERROR");
    else
        Q_EMIT channelsExportMessageLinkAnswer(q->mainMsgId(), result, q->extra());
}

void TelegramApi::onChannelsExportMessageLinkError(Query *q, qint32 errorCode, const QString &errorText) {
    bool accepted = false;
    onError(q, errorCode, errorText, q->extra(), accepted);
    if(!accepted)
        Q_EMIT channelsExportMessageLinkError(q->mainMsgId(), errorCode, errorText, q->extra());
}

qint64 TelegramApi::channelsToggleSignatures(const InputChannel &channel, bool enabled, const QVariant &attachedData, Session *session) {
    if(!session) session = mMainSession;
    CHECK_SESSION(session)
    DEBUG_FUNCTION
    OutboundPkt p(mSettings);
    INIT_MAIN_CONNECTION(session)
    Functions::Channels::toggleSignatures(&p, channel, enabled);
    return session->sendQuery(p, &channelsToggleSignaturesMethods, attachedData, "Channels->toggleSignatures" );
}

void TelegramApi::onChannelsToggleSignaturesAnswer(Query *q, InboundPkt &inboundPkt) {
    const UpdatesType &result = Functions::Channels::toggleSignaturesResult(&inboundPkt);
    if(result.error())
        onChannelsToggleSignaturesError(q, -1, "LIBQTELEGRAM_INTERNAL_ERROR");
    else
        Q_EMIT channelsToggleSignaturesAnswer(q->mainMsgId(), result, q->extra());
}

void TelegramApi::onChannelsToggleSignaturesError(Query *q, qint32 errorCode, const QString &errorText) {
    bool accepted = false;
    onError(q, errorCode, errorText, q->extra(), accepted);
    if(!accepted)
        Q_EMIT channelsToggleSignaturesError(q->mainMsgId(), errorCode, errorText, q->extra());
}

qint64 TelegramApi::channelsGetMessageEditData(const InputChannel &channel, qint32 id, const QVariant &attachedData, Session *session) {
    if(!session) session = mMainSession;
    CHECK_SESSION(session)
    DEBUG_FUNCTION
    OutboundPkt p(mSettings);
    INIT_MAIN_CONNECTION(session)
    Functions::Channels::getMessageEditData(&p, channel, id);
    return session->sendQuery(p, &channelsGetMessageEditDataMethods, attachedData, "Channels->getMessageEditData" );
}

void TelegramApi::onChannelsGetMessageEditDataAnswer(Query *q, InboundPkt &inboundPkt) {
    const ChannelsMessageEditData &result = Functions::Channels::getMessageEditDataResult(&inboundPkt);
    if(result.error())
        onChannelsGetMessageEditDataError(q, -1, "LIBQTELEGRAM_INTERNAL_ERROR");
    else
        Q_EMIT channelsGetMessageEditDataAnswer(q->mainMsgId(), result, q->extra());
}

void TelegramApi::onChannelsGetMessageEditDataError(Query *q, qint32 errorCode, const QString &errorText) {
    bool accepted = false;
    onError(q, errorCode, errorText, q->extra(), accepted);
    if(!accepted)
        Q_EMIT channelsGetMessageEditDataError(q->mainMsgId(), errorCode, errorText, q->extra());
}

qint64 TelegramApi::channelsEditMessage(bool no_webpage, const InputChannel &channel, qint32 id, const QString &message, const QList<MessageEntity> &entities, const QVariant &attachedData, Session *session) {
    if(!session) session = mMainSession;
    CHECK_SESSION(session)
    DEBUG_FUNCTION
    OutboundPkt p(mSettings);
    INIT_MAIN_CONNECTION(session)
    Functions::Channels::editMessage(&p, no_webpage, channel, id, message, entities);
    return session->sendQuery(p, &channelsEditMessageMethods, attachedData, "Channels->editMessage" );
}

void TelegramApi::onChannelsEditMessageAnswer(Query *q, InboundPkt &inboundPkt) {
    const UpdatesType &result = Functions::Channels::editMessageResult(&inboundPkt);
    if(result.error())
        onChannelsEditMessageError(q, -1, "LIBQTELEGRAM_INTERNAL_ERROR");
    else
        Q_EMIT channelsEditMessageAnswer(q->mainMsgId(), result, q->extra());
}

void TelegramApi::onChannelsEditMessageError(Query *q, qint32 errorCode, const QString &errorText) {
    bool accepted = false;
    onError(q, errorCode, errorText, q->extra(), accepted);
    if(!accepted)
        Q_EMIT channelsEditMessageError(q->mainMsgId(), errorCode, errorText, q->extra());
}

qint64 TelegramApi::channelsUpdatePinnedMessage(bool silent, const InputChannel &channel, qint32 id, const QVariant &attachedData, Session *session) {
    if(!session) session = mMainSession;
    CHECK_SESSION(session)
    DEBUG_FUNCTION
    OutboundPkt p(mSettings);
    INIT_MAIN_CONNECTION(session)
    Functions::Channels::updatePinnedMessage(&p, silent, channel, id);
    return session->sendQuery(p, &channelsUpdatePinnedMessageMethods, attachedData, "Channels->updatePinnedMessage" );
}

void TelegramApi::onChannelsUpdatePinnedMessageAnswer(Query *q, InboundPkt &inboundPkt) {
    const UpdatesType &result = Functions::Channels::updatePinnedMessageResult(&inboundPkt);
    if(result.error())
        onChannelsUpdatePinnedMessageError(q, -1, "LIBQTELEGRAM_INTERNAL_ERROR");
    else
        Q_EMIT channelsUpdatePinnedMessageAnswer(q->mainMsgId(), result, q->extra());
}

void TelegramApi::onChannelsUpdatePinnedMessageError(Query *q, qint32 errorCode, const QString &errorText) {
    bool accepted = false;
    onError(q, errorCode, errorText, q->extra(), accepted);
    if(!accepted)
        Q_EMIT channelsUpdatePinnedMessageError(q->mainMsgId(), errorCode, errorText, q->extra());
}


qint64 TelegramApi::contactsGetStatuses(const QVariant &attachedData, Session *session) {
    if(!session) session = mMainSession;
    CHECK_SESSION(session)
    DEBUG_FUNCTION
    OutboundPkt p(mSettings);
    INIT_MAIN_CONNECTION(session)
    Functions::Contacts::getStatuses(&p);
    return session->sendQuery(p, &contactsGetStatusesMethods, attachedData, "Contacts->getStatuses" );
}

void TelegramApi::onContactsGetStatusesAnswer(Query *q, InboundPkt &inboundPkt) {
    const QList<ContactStatus> &result = Functions::Contacts::getStatusesResult(&inboundPkt);
    Q_EMIT contactsGetStatusesAnswer(q->mainMsgId(), result, q->extra());
}

void TelegramApi::onContactsGetStatusesError(Query *q, qint32 errorCode, const QString &errorText) {
    bool accepted = false;
    onError(q, errorCode, errorText, q->extra(), accepted);
    if(!accepted)
        Q_EMIT contactsGetStatusesError(q->mainMsgId(), errorCode, errorText, q->extra());
}

qint64 TelegramApi::contactsGetContacts(const QString &hash, const QVariant &attachedData, Session *session) {
    if(!session) session = mMainSession;
    CHECK_SESSION(session)
    DEBUG_FUNCTION
    OutboundPkt p(mSettings);
    INIT_MAIN_CONNECTION(session)
    Functions::Contacts::getContacts(&p, hash);
    return session->sendQuery(p, &contactsGetContactsMethods, attachedData, "Contacts->getContacts" );
}

void TelegramApi::onContactsGetContactsAnswer(Query *q, InboundPkt &inboundPkt) {
    const ContactsContacts &result = Functions::Contacts::getContactsResult(&inboundPkt);
    if(result.error())
        onContactsGetContactsError(q, -1, "LIBQTELEGRAM_INTERNAL_ERROR");
    else
        Q_EMIT contactsGetContactsAnswer(q->mainMsgId(), result, q->extra());
}

void TelegramApi::onContactsGetContactsError(Query *q, qint32 errorCode, const QString &errorText) {
    bool accepted = false;
    onError(q, errorCode, errorText, q->extra(), accepted);
    if(!accepted)
        Q_EMIT contactsGetContactsError(q->mainMsgId(), errorCode, errorText, q->extra());
}

qint64 TelegramApi::contactsImportContacts(const QList<InputContact> &contacts, bool replace, const QVariant &attachedData, Session *session) {
    if(!session) session = mMainSession;
    CHECK_SESSION(session)
    DEBUG_FUNCTION
    OutboundPkt p(mSettings);
    INIT_MAIN_CONNECTION(session)
    Functions::Contacts::importContacts(&p, contacts, replace);
    return session->sendQuery(p, &contactsImportContactsMethods, attachedData, "Contacts->importContacts" );
}

void TelegramApi::onContactsImportContactsAnswer(Query *q, InboundPkt &inboundPkt) {
    const ContactsImportedContacts &result = Functions::Contacts::importContactsResult(&inboundPkt);
    if(result.error())
        onContactsImportContactsError(q, -1, "LIBQTELEGRAM_INTERNAL_ERROR");
    else
        Q_EMIT contactsImportContactsAnswer(q->mainMsgId(), result, q->extra());
}

void TelegramApi::onContactsImportContactsError(Query *q, qint32 errorCode, const QString &errorText) {
    bool accepted = false;
    onError(q, errorCode, errorText, q->extra(), accepted);
    if(!accepted)
        Q_EMIT contactsImportContactsError(q->mainMsgId(), errorCode, errorText, q->extra());
}

qint64 TelegramApi::contactsDeleteContact(const InputUser &id, const QVariant &attachedData, Session *session) {
    if(!session) session = mMainSession;
    CHECK_SESSION(session)
    DEBUG_FUNCTION
    OutboundPkt p(mSettings);
    INIT_MAIN_CONNECTION(session)
    Functions::Contacts::deleteContact(&p, id);
    return session->sendQuery(p, &contactsDeleteContactMethods, attachedData, "Contacts->deleteContact" );
}

void TelegramApi::onContactsDeleteContactAnswer(Query *q, InboundPkt &inboundPkt) {
    const ContactsLink &result = Functions::Contacts::deleteContactResult(&inboundPkt);
    if(result.error())
        onContactsDeleteContactError(q, -1, "LIBQTELEGRAM_INTERNAL_ERROR");
    else
        Q_EMIT contactsDeleteContactAnswer(q->mainMsgId(), result, q->extra());
}

void TelegramApi::onContactsDeleteContactError(Query *q, qint32 errorCode, const QString &errorText) {
    bool accepted = false;
    onError(q, errorCode, errorText, q->extra(), accepted);
    if(!accepted)
        Q_EMIT contactsDeleteContactError(q->mainMsgId(), errorCode, errorText, q->extra());
}

qint64 TelegramApi::contactsDeleteContacts(const QList<InputUser> &id, const QVariant &attachedData, Session *session) {
    if(!session) session = mMainSession;
    CHECK_SESSION(session)
    DEBUG_FUNCTION
    OutboundPkt p(mSettings);
    INIT_MAIN_CONNECTION(session)
    Functions::Contacts::deleteContacts(&p, id);
    return session->sendQuery(p, &contactsDeleteContactsMethods, attachedData, "Contacts->deleteContacts" );
}

void TelegramApi::onContactsDeleteContactsAnswer(Query *q, InboundPkt &inboundPkt) {
    const bool result = Functions::Contacts::deleteContactsResult(&inboundPkt);
    Q_EMIT contactsDeleteContactsAnswer(q->mainMsgId(), result, q->extra());
}

void TelegramApi::onContactsDeleteContactsError(Query *q, qint32 errorCode, const QString &errorText) {
    bool accepted = false;
    onError(q, errorCode, errorText, q->extra(), accepted);
    if(!accepted)
        Q_EMIT contactsDeleteContactsError(q->mainMsgId(), errorCode, errorText, q->extra());
}

qint64 TelegramApi::contactsBlock(const InputUser &id, const QVariant &attachedData, Session *session) {
    if(!session) session = mMainSession;
    CHECK_SESSION(session)
    DEBUG_FUNCTION
    OutboundPkt p(mSettings);
    INIT_MAIN_CONNECTION(session)
    Functions::Contacts::block(&p, id);
    return session->sendQuery(p, &contactsBlockMethods, attachedData, "Contacts->block" );
}

void TelegramApi::onContactsBlockAnswer(Query *q, InboundPkt &inboundPkt) {
    const bool result = Functions::Contacts::blockResult(&inboundPkt);
    Q_EMIT contactsBlockAnswer(q->mainMsgId(), result, q->extra());
}

void TelegramApi::onContactsBlockError(Query *q, qint32 errorCode, const QString &errorText) {
    bool accepted = false;
    onError(q, errorCode, errorText, q->extra(), accepted);
    if(!accepted)
        Q_EMIT contactsBlockError(q->mainMsgId(), errorCode, errorText, q->extra());
}

qint64 TelegramApi::contactsUnblock(const InputUser &id, const QVariant &attachedData, Session *session) {
    if(!session) session = mMainSession;
    CHECK_SESSION(session)
    DEBUG_FUNCTION
    OutboundPkt p(mSettings);
    INIT_MAIN_CONNECTION(session)
    Functions::Contacts::unblock(&p, id);
    return session->sendQuery(p, &contactsUnblockMethods, attachedData, "Contacts->unblock" );
}

void TelegramApi::onContactsUnblockAnswer(Query *q, InboundPkt &inboundPkt) {
    const bool result = Functions::Contacts::unblockResult(&inboundPkt);
    Q_EMIT contactsUnblockAnswer(q->mainMsgId(), result, q->extra());
}

void TelegramApi::onContactsUnblockError(Query *q, qint32 errorCode, const QString &errorText) {
    bool accepted = false;
    onError(q, errorCode, errorText, q->extra(), accepted);
    if(!accepted)
        Q_EMIT contactsUnblockError(q->mainMsgId(), errorCode, errorText, q->extra());
}

qint64 TelegramApi::contactsGetBlocked(qint32 offset, qint32 limit, const QVariant &attachedData, Session *session) {
    if(!session) session = mMainSession;
    CHECK_SESSION(session)
    DEBUG_FUNCTION
    OutboundPkt p(mSettings);
    INIT_MAIN_CONNECTION(session)
    Functions::Contacts::getBlocked(&p, offset, limit);
    return session->sendQuery(p, &contactsGetBlockedMethods, attachedData, "Contacts->getBlocked" );
}

void TelegramApi::onContactsGetBlockedAnswer(Query *q, InboundPkt &inboundPkt) {
    const ContactsBlocked &result = Functions::Contacts::getBlockedResult(&inboundPkt);
    if(result.error())
        onContactsGetBlockedError(q, -1, "LIBQTELEGRAM_INTERNAL_ERROR");
    else
        Q_EMIT contactsGetBlockedAnswer(q->mainMsgId(), result, q->extra());
}

void TelegramApi::onContactsGetBlockedError(Query *q, qint32 errorCode, const QString &errorText) {
    bool accepted = false;
    onError(q, errorCode, errorText, q->extra(), accepted);
    if(!accepted)
        Q_EMIT contactsGetBlockedError(q->mainMsgId(), errorCode, errorText, q->extra());
}

qint64 TelegramApi::contactsExportCard(const QVariant &attachedData, Session *session) {
    if(!session) session = mMainSession;
    CHECK_SESSION(session)
    DEBUG_FUNCTION
    OutboundPkt p(mSettings);
    INIT_MAIN_CONNECTION(session)
    Functions::Contacts::exportCard(&p);
    return session->sendQuery(p, &contactsExportCardMethods, attachedData, "Contacts->exportCard" );
}

void TelegramApi::onContactsExportCardAnswer(Query *q, InboundPkt &inboundPkt) {
    const QList<qint32> &result = Functions::Contacts::exportCardResult(&inboundPkt);
    Q_EMIT contactsExportCardAnswer(q->mainMsgId(), result, q->extra());
}

void TelegramApi::onContactsExportCardError(Query *q, qint32 errorCode, const QString &errorText) {
    bool accepted = false;
    onError(q, errorCode, errorText, q->extra(), accepted);
    if(!accepted)
        Q_EMIT contactsExportCardError(q->mainMsgId(), errorCode, errorText, q->extra());
}

qint64 TelegramApi::contactsImportCard(const QList<qint32> &export_card, const QVariant &attachedData, Session *session) {
    if(!session) session = mMainSession;
    CHECK_SESSION(session)
    DEBUG_FUNCTION
    OutboundPkt p(mSettings);
    INIT_MAIN_CONNECTION(session)
    Functions::Contacts::importCard(&p, export_card);
    return session->sendQuery(p, &contactsImportCardMethods, attachedData, "Contacts->importCard" );
}

void TelegramApi::onContactsImportCardAnswer(Query *q, InboundPkt &inboundPkt) {
    const User &result = Functions::Contacts::importCardResult(&inboundPkt);
    if(result.error())
        onContactsImportCardError(q, -1, "LIBQTELEGRAM_INTERNAL_ERROR");
    else
        Q_EMIT contactsImportCardAnswer(q->mainMsgId(), result, q->extra());
}

void TelegramApi::onContactsImportCardError(Query *q, qint32 errorCode, const QString &errorText) {
    bool accepted = false;
    onError(q, errorCode, errorText, q->extra(), accepted);
    if(!accepted)
        Q_EMIT contactsImportCardError(q->mainMsgId(), errorCode, errorText, q->extra());
}

qint64 TelegramApi::contactsSearch(const QString &q, qint32 limit, const QVariant &attachedData, Session *session) {
    if(!session) session = mMainSession;
    CHECK_SESSION(session)
    DEBUG_FUNCTION
    OutboundPkt p(mSettings);
    INIT_MAIN_CONNECTION(session)
    Functions::Contacts::search(&p, q, limit);
    return session->sendQuery(p, &contactsSearchMethods, attachedData, "Contacts->search" );
}

void TelegramApi::onContactsSearchAnswer(Query *q, InboundPkt &inboundPkt) {
    const ContactsFound &result = Functions::Contacts::searchResult(&inboundPkt);
    if(result.error())
        onContactsSearchError(q, -1, "LIBQTELEGRAM_INTERNAL_ERROR");
    else
        Q_EMIT contactsSearchAnswer(q->mainMsgId(), result, q->extra());
}

void TelegramApi::onContactsSearchError(Query *q, qint32 errorCode, const QString &errorText) {
    bool accepted = false;
    onError(q, errorCode, errorText, q->extra(), accepted);
    if(!accepted)
        Q_EMIT contactsSearchError(q->mainMsgId(), errorCode, errorText, q->extra());
}

qint64 TelegramApi::contactsResolveUsername(const QString &username, const QVariant &attachedData, Session *session) {
    if(!session) session = mMainSession;
    CHECK_SESSION(session)
    DEBUG_FUNCTION
    OutboundPkt p(mSettings);
    INIT_MAIN_CONNECTION(session)
    Functions::Contacts::resolveUsername(&p, username);
    return session->sendQuery(p, &contactsResolveUsernameMethods, attachedData, "Contacts->resolveUsername" );
}

void TelegramApi::onContactsResolveUsernameAnswer(Query *q, InboundPkt &inboundPkt) {
    const ContactsResolvedPeer &result = Functions::Contacts::resolveUsernameResult(&inboundPkt);
    if(result.error())
        onContactsResolveUsernameError(q, -1, "LIBQTELEGRAM_INTERNAL_ERROR");
    else
        Q_EMIT contactsResolveUsernameAnswer(q->mainMsgId(), result, q->extra());
}

void TelegramApi::onContactsResolveUsernameError(Query *q, qint32 errorCode, const QString &errorText) {
    bool accepted = false;
    onError(q, errorCode, errorText, q->extra(), accepted);
    if(!accepted)
        Q_EMIT contactsResolveUsernameError(q->mainMsgId(), errorCode, errorText, q->extra());
}


qint64 TelegramApi::helpGetConfig(const QVariant &attachedData, Session *session) {
    if(!session) session = mMainSession;
    CHECK_SESSION(session)
    DEBUG_FUNCTION
    OutboundPkt p(mSettings);
    INIT_MAIN_CONNECTION(session)
    Functions::Help::getConfig(&p);
    return session->sendQuery(p, &helpGetConfigMethods, attachedData, "Help->getConfig" );
}

void TelegramApi::onHelpGetConfigAnswer(Query *q, InboundPkt &inboundPkt) {
    const Config &result = Functions::Help::getConfigResult(&inboundPkt);
    if(result.error())
        onHelpGetConfigError(q, -1, "LIBQTELEGRAM_INTERNAL_ERROR");
    else
        Q_EMIT helpGetConfigAnswer(q->mainMsgId(), result, q->extra());
}

void TelegramApi::onHelpGetConfigError(Query *q, qint32 errorCode, const QString &errorText) {
    bool accepted = false;
    onError(q, errorCode, errorText, q->extra(), accepted);
    if(!accepted)
        Q_EMIT helpGetConfigError(q->mainMsgId(), errorCode, errorText, q->extra());
}

qint64 TelegramApi::helpGetNearestDc(const QVariant &attachedData, Session *session) {
    if(!session) session = mMainSession;
    CHECK_SESSION(session)
    DEBUG_FUNCTION
    OutboundPkt p(mSettings);
    INIT_MAIN_CONNECTION(session)
    Functions::Help::getNearestDc(&p);
    return session->sendQuery(p, &helpGetNearestDcMethods, attachedData, "Help->getNearestDc" );
}

void TelegramApi::onHelpGetNearestDcAnswer(Query *q, InboundPkt &inboundPkt) {
    const NearestDc &result = Functions::Help::getNearestDcResult(&inboundPkt);
    if(result.error())
        onHelpGetNearestDcError(q, -1, "LIBQTELEGRAM_INTERNAL_ERROR");
    else
        Q_EMIT helpGetNearestDcAnswer(q->mainMsgId(), result, q->extra());
}

void TelegramApi::onHelpGetNearestDcError(Query *q, qint32 errorCode, const QString &errorText) {
    bool accepted = false;
    onError(q, errorCode, errorText, q->extra(), accepted);
    if(!accepted)
        Q_EMIT helpGetNearestDcError(q->mainMsgId(), errorCode, errorText, q->extra());
}

qint64 TelegramApi::helpGetAppUpdate(const QString &device_model, const QString &system_version, const QString &app_version, const QString &lang_code, const QVariant &attachedData, Session *session) {
    if(!session) session = mMainSession;
    CHECK_SESSION(session)
    DEBUG_FUNCTION
    OutboundPkt p(mSettings);
    INIT_MAIN_CONNECTION(session)
    Functions::Help::getAppUpdate(&p, device_model, system_version, app_version, lang_code);
    return session->sendQuery(p, &helpGetAppUpdateMethods, attachedData, "Help->getAppUpdate" );
}

void TelegramApi::onHelpGetAppUpdateAnswer(Query *q, InboundPkt &inboundPkt) {
    const HelpAppUpdate &result = Functions::Help::getAppUpdateResult(&inboundPkt);
    if(result.error())
        onHelpGetAppUpdateError(q, -1, "LIBQTELEGRAM_INTERNAL_ERROR");
    else
        Q_EMIT helpGetAppUpdateAnswer(q->mainMsgId(), result, q->extra());
}

void TelegramApi::onHelpGetAppUpdateError(Query *q, qint32 errorCode, const QString &errorText) {
    bool accepted = false;
    onError(q, errorCode, errorText, q->extra(), accepted);
    if(!accepted)
        Q_EMIT helpGetAppUpdateError(q->mainMsgId(), errorCode, errorText, q->extra());
}

qint64 TelegramApi::helpSaveAppLog(const QList<InputAppEvent> &events, const QVariant &attachedData, Session *session) {
    if(!session) session = mMainSession;
    CHECK_SESSION(session)
    DEBUG_FUNCTION
    OutboundPkt p(mSettings);
    INIT_MAIN_CONNECTION(session)
    Functions::Help::saveAppLog(&p, events);
    return session->sendQuery(p, &helpSaveAppLogMethods, attachedData, "Help->saveAppLog" );
}

void TelegramApi::onHelpSaveAppLogAnswer(Query *q, InboundPkt &inboundPkt) {
    const bool result = Functions::Help::saveAppLogResult(&inboundPkt);
    Q_EMIT helpSaveAppLogAnswer(q->mainMsgId(), result, q->extra());
}

void TelegramApi::onHelpSaveAppLogError(Query *q, qint32 errorCode, const QString &errorText) {
    bool accepted = false;
    onError(q, errorCode, errorText, q->extra(), accepted);
    if(!accepted)
        Q_EMIT helpSaveAppLogError(q->mainMsgId(), errorCode, errorText, q->extra());
}

qint64 TelegramApi::helpGetInviteText(const QString &lang_code, const QVariant &attachedData, Session *session) {
    if(!session) session = mMainSession;
    CHECK_SESSION(session)
    DEBUG_FUNCTION
    OutboundPkt p(mSettings);
    INIT_MAIN_CONNECTION(session)
    Functions::Help::getInviteText(&p, lang_code);
    return session->sendQuery(p, &helpGetInviteTextMethods, attachedData, "Help->getInviteText" );
}

void TelegramApi::onHelpGetInviteTextAnswer(Query *q, InboundPkt &inboundPkt) {
    const HelpInviteText &result = Functions::Help::getInviteTextResult(&inboundPkt);
    if(result.error())
        onHelpGetInviteTextError(q, -1, "LIBQTELEGRAM_INTERNAL_ERROR");
    else
        Q_EMIT helpGetInviteTextAnswer(q->mainMsgId(), result, q->extra());
}

void TelegramApi::onHelpGetInviteTextError(Query *q, qint32 errorCode, const QString &errorText) {
    bool accepted = false;
    onError(q, errorCode, errorText, q->extra(), accepted);
    if(!accepted)
        Q_EMIT helpGetInviteTextError(q->mainMsgId(), errorCode, errorText, q->extra());
}

qint64 TelegramApi::helpGetSupport(const QVariant &attachedData, Session *session) {
    if(!session) session = mMainSession;
    CHECK_SESSION(session)
    DEBUG_FUNCTION
    OutboundPkt p(mSettings);
    INIT_MAIN_CONNECTION(session)
    Functions::Help::getSupport(&p);
    return session->sendQuery(p, &helpGetSupportMethods, attachedData, "Help->getSupport" );
}

void TelegramApi::onHelpGetSupportAnswer(Query *q, InboundPkt &inboundPkt) {
    const HelpSupport &result = Functions::Help::getSupportResult(&inboundPkt);
    if(result.error())
        onHelpGetSupportError(q, -1, "LIBQTELEGRAM_INTERNAL_ERROR");
    else
        Q_EMIT helpGetSupportAnswer(q->mainMsgId(), result, q->extra());
}

void TelegramApi::onHelpGetSupportError(Query *q, qint32 errorCode, const QString &errorText) {
    bool accepted = false;
    onError(q, errorCode, errorText, q->extra(), accepted);
    if(!accepted)
        Q_EMIT helpGetSupportError(q->mainMsgId(), errorCode, errorText, q->extra());
}

qint64 TelegramApi::helpGetAppChangelog(const QString &device_model, const QString &system_version, const QString &app_version, const QString &lang_code, const QVariant &attachedData, Session *session) {
    if(!session) session = mMainSession;
    CHECK_SESSION(session)
    DEBUG_FUNCTION
    OutboundPkt p(mSettings);
    INIT_MAIN_CONNECTION(session)
    Functions::Help::getAppChangelog(&p, device_model, system_version, app_version, lang_code);
    return session->sendQuery(p, &helpGetAppChangelogMethods, attachedData, "Help->getAppChangelog" );
}

void TelegramApi::onHelpGetAppChangelogAnswer(Query *q, InboundPkt &inboundPkt) {
    const HelpAppChangelog &result = Functions::Help::getAppChangelogResult(&inboundPkt);
    if(result.error())
        onHelpGetAppChangelogError(q, -1, "LIBQTELEGRAM_INTERNAL_ERROR");
    else
        Q_EMIT helpGetAppChangelogAnswer(q->mainMsgId(), result, q->extra());
}

void TelegramApi::onHelpGetAppChangelogError(Query *q, qint32 errorCode, const QString &errorText) {
    bool accepted = false;
    onError(q, errorCode, errorText, q->extra(), accepted);
    if(!accepted)
        Q_EMIT helpGetAppChangelogError(q->mainMsgId(), errorCode, errorText, q->extra());
}

qint64 TelegramApi::helpGetTermsOfService(const QString &lang_code, const QVariant &attachedData, Session *session) {
    if(!session) session = mMainSession;
    CHECK_SESSION(session)
    DEBUG_FUNCTION
    OutboundPkt p(mSettings);
    INIT_MAIN_CONNECTION(session)
    Functions::Help::getTermsOfService(&p, lang_code);
    return session->sendQuery(p, &helpGetTermsOfServiceMethods, attachedData, "Help->getTermsOfService" );
}

void TelegramApi::onHelpGetTermsOfServiceAnswer(Query *q, InboundPkt &inboundPkt) {
    const HelpTermsOfService &result = Functions::Help::getTermsOfServiceResult(&inboundPkt);
    if(result.error())
        onHelpGetTermsOfServiceError(q, -1, "LIBQTELEGRAM_INTERNAL_ERROR");
    else
        Q_EMIT helpGetTermsOfServiceAnswer(q->mainMsgId(), result, q->extra());
}

void TelegramApi::onHelpGetTermsOfServiceError(Query *q, qint32 errorCode, const QString &errorText) {
    bool accepted = false;
    onError(q, errorCode, errorText, q->extra(), accepted);
    if(!accepted)
        Q_EMIT helpGetTermsOfServiceError(q->mainMsgId(), errorCode, errorText, q->extra());
}


qint64 TelegramApi::messagesGetMessages(const QList<qint32> &id, const QVariant &attachedData, Session *session) {
    if(!session) session = mMainSession;
    CHECK_SESSION(session)
    DEBUG_FUNCTION
    OutboundPkt p(mSettings);
    INIT_MAIN_CONNECTION(session)
    Functions::Messages::getMessages(&p, id);
    return session->sendQuery(p, &messagesGetMessagesMethods, attachedData, "Messages->getMessages" );
}

void TelegramApi::onMessagesGetMessagesAnswer(Query *q, InboundPkt &inboundPkt) {
    const MessagesMessages &result = Functions::Messages::getMessagesResult(&inboundPkt);
    if(result.error())
        onMessagesGetMessagesError(q, -1, "LIBQTELEGRAM_INTERNAL_ERROR");
    else
        Q_EMIT messagesGetMessagesAnswer(q->mainMsgId(), result, q->extra());
}

void TelegramApi::onMessagesGetMessagesError(Query *q, qint32 errorCode, const QString &errorText) {
    bool accepted = false;
    onError(q, errorCode, errorText, q->extra(), accepted);
    if(!accepted)
        Q_EMIT messagesGetMessagesError(q->mainMsgId(), errorCode, errorText, q->extra());
}

qint64 TelegramApi::messagesGetDialogs(qint32 offset_date, qint32 offset_id, const InputPeer &offset_peer, qint32 limit, const QVariant &attachedData, Session *session) {
    if(!session) session = mMainSession;
    CHECK_SESSION(session)
    DEBUG_FUNCTION
    OutboundPkt p(mSettings);
    INIT_MAIN_CONNECTION(session)
    Functions::Messages::getDialogs(&p, offset_date, offset_id, offset_peer, limit);
    return session->sendQuery(p, &messagesGetDialogsMethods, attachedData, "Messages->getDialogs" );
}

void TelegramApi::onMessagesGetDialogsAnswer(Query *q, InboundPkt &inboundPkt) {
    const MessagesDialogs &result = Functions::Messages::getDialogsResult(&inboundPkt);
    if(result.error())
        onMessagesGetDialogsError(q, -1, "LIBQTELEGRAM_INTERNAL_ERROR");
    else
        Q_EMIT messagesGetDialogsAnswer(q->mainMsgId(), result, q->extra());
}

void TelegramApi::onMessagesGetDialogsError(Query *q, qint32 errorCode, const QString &errorText) {
    bool accepted = false;
    onError(q, errorCode, errorText, q->extra(), accepted);
    if(!accepted)
        Q_EMIT messagesGetDialogsError(q->mainMsgId(), errorCode, errorText, q->extra());
}

qint64 TelegramApi::messagesGetHistory(const InputPeer &peer, qint32 offset_id, qint32 offset_date, qint32 add_offset, qint32 limit, qint32 max_id, qint32 min_id, const QVariant &attachedData, Session *session) {
    if(!session) session = mMainSession;
    CHECK_SESSION(session)
    DEBUG_FUNCTION
    OutboundPkt p(mSettings);
    INIT_MAIN_CONNECTION(session)
    Functions::Messages::getHistory(&p, peer, offset_id, offset_date, add_offset, limit, max_id, min_id);
    return session->sendQuery(p, &messagesGetHistoryMethods, attachedData, "Messages->getHistory" );
}

void TelegramApi::onMessagesGetHistoryAnswer(Query *q, InboundPkt &inboundPkt) {
    const MessagesMessages &result = Functions::Messages::getHistoryResult(&inboundPkt);
    if(result.error())
        onMessagesGetHistoryError(q, -1, "LIBQTELEGRAM_INTERNAL_ERROR");
    else
        Q_EMIT messagesGetHistoryAnswer(q->mainMsgId(), result, q->extra());
}

void TelegramApi::onMessagesGetHistoryError(Query *q, qint32 errorCode, const QString &errorText) {
    bool accepted = false;
    onError(q, errorCode, errorText, q->extra(), accepted);
    if(!accepted)
        Q_EMIT messagesGetHistoryError(q->mainMsgId(), errorCode, errorText, q->extra());
}

qint64 TelegramApi::messagesSearch(bool important_only, const InputPeer &peer, const QString &q, const MessagesFilter &filter, qint32 min_date, qint32 max_date, qint32 offset, qint32 max_id, qint32 limit, const QVariant &attachedData, Session *session) {
    if(!session) session = mMainSession;
    CHECK_SESSION(session)
    DEBUG_FUNCTION
    OutboundPkt p(mSettings);
    INIT_MAIN_CONNECTION(session)
    Functions::Messages::search(&p, important_only, peer, q, filter, min_date, max_date, offset, max_id, limit);
    return session->sendQuery(p, &messagesSearchMethods, attachedData, "Messages->search" );
}

void TelegramApi::onMessagesSearchAnswer(Query *q, InboundPkt &inboundPkt) {
    const MessagesMessages &result = Functions::Messages::searchResult(&inboundPkt);
    if(result.error())
        onMessagesSearchError(q, -1, "LIBQTELEGRAM_INTERNAL_ERROR");
    else
        Q_EMIT messagesSearchAnswer(q->mainMsgId(), result, q->extra());
}

void TelegramApi::onMessagesSearchError(Query *q, qint32 errorCode, const QString &errorText) {
    bool accepted = false;
    onError(q, errorCode, errorText, q->extra(), accepted);
    if(!accepted)
        Q_EMIT messagesSearchError(q->mainMsgId(), errorCode, errorText, q->extra());
}

qint64 TelegramApi::messagesReadHistory(const InputPeer &peer, qint32 max_id, const QVariant &attachedData, Session *session) {
    if(!session) session = mMainSession;
    CHECK_SESSION(session)
    DEBUG_FUNCTION
    OutboundPkt p(mSettings);
    INIT_MAIN_CONNECTION(session)
    Functions::Messages::readHistory(&p, peer, max_id);
    return session->sendQuery(p, &messagesReadHistoryMethods, attachedData, "Messages->readHistory" );
}

void TelegramApi::onMessagesReadHistoryAnswer(Query *q, InboundPkt &inboundPkt) {
    const MessagesAffectedMessages &result = Functions::Messages::readHistoryResult(&inboundPkt);
    if(result.error())
        onMessagesReadHistoryError(q, -1, "LIBQTELEGRAM_INTERNAL_ERROR");
    else
        Q_EMIT messagesReadHistoryAnswer(q->mainMsgId(), result, q->extra());
}

void TelegramApi::onMessagesReadHistoryError(Query *q, qint32 errorCode, const QString &errorText) {
    bool accepted = false;
    onError(q, errorCode, errorText, q->extra(), accepted);
    if(!accepted)
        Q_EMIT messagesReadHistoryError(q->mainMsgId(), errorCode, errorText, q->extra());
}

qint64 TelegramApi::messagesDeleteHistory(const InputPeer &peer, qint32 max_id, const QVariant &attachedData, Session *session) {
    if(!session) session = mMainSession;
    CHECK_SESSION(session)
    DEBUG_FUNCTION
    OutboundPkt p(mSettings);
    INIT_MAIN_CONNECTION(session)
    Functions::Messages::deleteHistory(&p, peer, max_id);
    return session->sendQuery(p, &messagesDeleteHistoryMethods, attachedData, "Messages->deleteHistory" );
}

void TelegramApi::onMessagesDeleteHistoryAnswer(Query *q, InboundPkt &inboundPkt) {
    const MessagesAffectedHistory &result = Functions::Messages::deleteHistoryResult(&inboundPkt);
    if(result.error())
        onMessagesDeleteHistoryError(q, -1, "LIBQTELEGRAM_INTERNAL_ERROR");
    else
        Q_EMIT messagesDeleteHistoryAnswer(q->mainMsgId(), result, q->extra());
}

void TelegramApi::onMessagesDeleteHistoryError(Query *q, qint32 errorCode, const QString &errorText) {
    bool accepted = false;
    onError(q, errorCode, errorText, q->extra(), accepted);
    if(!accepted)
        Q_EMIT messagesDeleteHistoryError(q->mainMsgId(), errorCode, errorText, q->extra());
}

qint64 TelegramApi::messagesDeleteMessages(const QList<qint32> &id, const QVariant &attachedData, Session *session) {
    if(!session) session = mMainSession;
    CHECK_SESSION(session)
    DEBUG_FUNCTION
    OutboundPkt p(mSettings);
    INIT_MAIN_CONNECTION(session)
    Functions::Messages::deleteMessages(&p, id);
    return session->sendQuery(p, &messagesDeleteMessagesMethods, attachedData, "Messages->deleteMessages" );
}

void TelegramApi::onMessagesDeleteMessagesAnswer(Query *q, InboundPkt &inboundPkt) {
    const MessagesAffectedMessages &result = Functions::Messages::deleteMessagesResult(&inboundPkt);
    if(result.error())
        onMessagesDeleteMessagesError(q, -1, "LIBQTELEGRAM_INTERNAL_ERROR");
    else
        Q_EMIT messagesDeleteMessagesAnswer(q->mainMsgId(), result, q->extra());
}

void TelegramApi::onMessagesDeleteMessagesError(Query *q, qint32 errorCode, const QString &errorText) {
    bool accepted = false;
    onError(q, errorCode, errorText, q->extra(), accepted);
    if(!accepted)
        Q_EMIT messagesDeleteMessagesError(q->mainMsgId(), errorCode, errorText, q->extra());
}

qint64 TelegramApi::messagesReceivedMessages(qint32 max_id, const QVariant &attachedData, Session *session) {
    if(!session) session = mMainSession;
    CHECK_SESSION(session)
    DEBUG_FUNCTION
    OutboundPkt p(mSettings);
    INIT_MAIN_CONNECTION(session)
    Functions::Messages::receivedMessages(&p, max_id);
    return session->sendQuery(p, &messagesReceivedMessagesMethods, attachedData, "Messages->receivedMessages" );
}

void TelegramApi::onMessagesReceivedMessagesAnswer(Query *q, InboundPkt &inboundPkt) {
    const QList<ReceivedNotifyMessage> &result = Functions::Messages::receivedMessagesResult(&inboundPkt);
    Q_EMIT messagesReceivedMessagesAnswer(q->mainMsgId(), result, q->extra());
}

void TelegramApi::onMessagesReceivedMessagesError(Query *q, qint32 errorCode, const QString &errorText) {
    bool accepted = false;
    onError(q, errorCode, errorText, q->extra(), accepted);
    if(!accepted)
        Q_EMIT messagesReceivedMessagesError(q->mainMsgId(), errorCode, errorText, q->extra());
}

qint64 TelegramApi::messagesSetTyping(const InputPeer &peer, const SendMessageAction &action, const QVariant &attachedData, Session *session) {
    if(!session) session = mMainSession;
    CHECK_SESSION(session)
    DEBUG_FUNCTION
    OutboundPkt p(mSettings);
    INIT_MAIN_CONNECTION(session)
    Functions::Messages::setTyping(&p, peer, action);
    return session->sendQuery(p, &messagesSetTypingMethods, attachedData, "Messages->setTyping" );
}

void TelegramApi::onMessagesSetTypingAnswer(Query *q, InboundPkt &inboundPkt) {
    const bool result = Functions::Messages::setTypingResult(&inboundPkt);
    Q_EMIT messagesSetTypingAnswer(q->mainMsgId(), result, q->extra());
}

void TelegramApi::onMessagesSetTypingError(Query *q, qint32 errorCode, const QString &errorText) {
    bool accepted = false;
    onError(q, errorCode, errorText, q->extra(), accepted);
    if(!accepted)
        Q_EMIT messagesSetTypingError(q->mainMsgId(), errorCode, errorText, q->extra());
}

qint64 TelegramApi::messagesSendMessage(bool no_webpage, bool broadcast, bool silent, bool background, const InputPeer &peer, qint32 reply_to_msg_id, const QString &message, qint64 random_id, const ReplyMarkup &reply_markup, const QList<MessageEntity> &entities, const QVariant &attachedData, Session *session) {
    if(!session) session = mMainSession;
    CHECK_SESSION(session)
    DEBUG_FUNCTION
    OutboundPkt p(mSettings);
    INIT_MAIN_CONNECTION(session)
    Functions::Messages::sendMessage(&p, no_webpage, broadcast, silent, background, peer, reply_to_msg_id, message, random_id, reply_markup, entities);
    return session->sendQuery(p, &messagesSendMessageMethods, attachedData, "Messages->sendMessage" );
}

void TelegramApi::onMessagesSendMessageAnswer(Query *q, InboundPkt &inboundPkt) {
    const UpdatesType &result = Functions::Messages::sendMessageResult(&inboundPkt);
    if(result.error())
        onMessagesSendMessageError(q, -1, "LIBQTELEGRAM_INTERNAL_ERROR");
    else
        Q_EMIT messagesSendMessageAnswer(q->mainMsgId(), result, q->extra());
}

void TelegramApi::onMessagesSendMessageError(Query *q, qint32 errorCode, const QString &errorText) {
    bool accepted = false;
    onError(q, errorCode, errorText, q->extra(), accepted);
    if(!accepted)
        Q_EMIT messagesSendMessageError(q->mainMsgId(), errorCode, errorText, q->extra());
}

qint64 TelegramApi::messagesSendMedia(bool broadcast, bool silent, bool background, const InputPeer &peer, qint32 reply_to_msg_id, const InputMedia &media, qint64 random_id, const ReplyMarkup &reply_markup, const QVariant &attachedData, Session *session) {
    if(!session) session = mMainSession;
    CHECK_SESSION(session)
    DEBUG_FUNCTION
    OutboundPkt p(mSettings);
    INIT_MAIN_CONNECTION(session)
    Functions::Messages::sendMedia(&p, broadcast, silent, background, peer, reply_to_msg_id, media, random_id, reply_markup);
    return session->sendQuery(p, &messagesSendMediaMethods, attachedData, "Messages->sendMedia" );
}

void TelegramApi::onMessagesSendMediaAnswer(Query *q, InboundPkt &inboundPkt) {
    const UpdatesType &result = Functions::Messages::sendMediaResult(&inboundPkt);
    if(result.error())
        onMessagesSendMediaError(q, -1, "LIBQTELEGRAM_INTERNAL_ERROR");
    else
        Q_EMIT messagesSendMediaAnswer(q->mainMsgId(), result, q->extra());
}

void TelegramApi::onMessagesSendMediaError(Query *q, qint32 errorCode, const QString &errorText) {
    bool accepted = false;
    onError(q, errorCode, errorText, q->extra(), accepted);
    if(!accepted)
        Q_EMIT messagesSendMediaError(q->mainMsgId(), errorCode, errorText, q->extra());
}

qint64 TelegramApi::messagesForwardMessages(bool broadcast, bool silent, bool background, const InputPeer &from_peer, const QList<qint32> &id, const QList<qint64> &random_id, const InputPeer &to_peer, const QVariant &attachedData, Session *session) {
    if(!session) session = mMainSession;
    CHECK_SESSION(session)
    DEBUG_FUNCTION
    OutboundPkt p(mSettings);
    INIT_MAIN_CONNECTION(session)
    Functions::Messages::forwardMessages(&p, broadcast, silent, background, from_peer, id, random_id, to_peer);
    return session->sendQuery(p, &messagesForwardMessagesMethods, attachedData, "Messages->forwardMessages" );
}

void TelegramApi::onMessagesForwardMessagesAnswer(Query *q, InboundPkt &inboundPkt) {
    const UpdatesType &result = Functions::Messages::forwardMessagesResult(&inboundPkt);
    if(result.error())
        onMessagesForwardMessagesError(q, -1, "LIBQTELEGRAM_INTERNAL_ERROR");
    else
        Q_EMIT messagesForwardMessagesAnswer(q->mainMsgId(), result, q->extra());
}

void TelegramApi::onMessagesForwardMessagesError(Query *q, qint32 errorCode, const QString &errorText) {
    bool accepted = false;
    onError(q, errorCode, errorText, q->extra(), accepted);
    if(!accepted)
        Q_EMIT messagesForwardMessagesError(q->mainMsgId(), errorCode, errorText, q->extra());
}

qint64 TelegramApi::messagesReportSpam(const InputPeer &peer, const QVariant &attachedData, Session *session) {
    if(!session) session = mMainSession;
    CHECK_SESSION(session)
    DEBUG_FUNCTION
    OutboundPkt p(mSettings);
    INIT_MAIN_CONNECTION(session)
    Functions::Messages::reportSpam(&p, peer);
    return session->sendQuery(p, &messagesReportSpamMethods, attachedData, "Messages->reportSpam" );
}

void TelegramApi::onMessagesReportSpamAnswer(Query *q, InboundPkt &inboundPkt) {
    const bool result = Functions::Messages::reportSpamResult(&inboundPkt);
    Q_EMIT messagesReportSpamAnswer(q->mainMsgId(), result, q->extra());
}

void TelegramApi::onMessagesReportSpamError(Query *q, qint32 errorCode, const QString &errorText) {
    bool accepted = false;
    onError(q, errorCode, errorText, q->extra(), accepted);
    if(!accepted)
        Q_EMIT messagesReportSpamError(q->mainMsgId(), errorCode, errorText, q->extra());
}

qint64 TelegramApi::messagesHideReportSpam(const InputPeer &peer, const QVariant &attachedData, Session *session) {
    if(!session) session = mMainSession;
    CHECK_SESSION(session)
    DEBUG_FUNCTION
    OutboundPkt p(mSettings);
    INIT_MAIN_CONNECTION(session)
    Functions::Messages::hideReportSpam(&p, peer);
    return session->sendQuery(p, &messagesHideReportSpamMethods, attachedData, "Messages->hideReportSpam" );
}

void TelegramApi::onMessagesHideReportSpamAnswer(Query *q, InboundPkt &inboundPkt) {
    const bool result = Functions::Messages::hideReportSpamResult(&inboundPkt);
    Q_EMIT messagesHideReportSpamAnswer(q->mainMsgId(), result, q->extra());
}

void TelegramApi::onMessagesHideReportSpamError(Query *q, qint32 errorCode, const QString &errorText) {
    bool accepted = false;
    onError(q, errorCode, errorText, q->extra(), accepted);
    if(!accepted)
        Q_EMIT messagesHideReportSpamError(q->mainMsgId(), errorCode, errorText, q->extra());
}

qint64 TelegramApi::messagesGetPeerSettings(const InputPeer &peer, const QVariant &attachedData, Session *session) {
    if(!session) session = mMainSession;
    CHECK_SESSION(session)
    DEBUG_FUNCTION
    OutboundPkt p(mSettings);
    INIT_MAIN_CONNECTION(session)
    Functions::Messages::getPeerSettings(&p, peer);
    return session->sendQuery(p, &messagesGetPeerSettingsMethods, attachedData, "Messages->getPeerSettings" );
}

void TelegramApi::onMessagesGetPeerSettingsAnswer(Query *q, InboundPkt &inboundPkt) {
    const PeerSettings &result = Functions::Messages::getPeerSettingsResult(&inboundPkt);
    if(result.error())
        onMessagesGetPeerSettingsError(q, -1, "LIBQTELEGRAM_INTERNAL_ERROR");
    else
        Q_EMIT messagesGetPeerSettingsAnswer(q->mainMsgId(), result, q->extra());
}

void TelegramApi::onMessagesGetPeerSettingsError(Query *q, qint32 errorCode, const QString &errorText) {
    bool accepted = false;
    onError(q, errorCode, errorText, q->extra(), accepted);
    if(!accepted)
        Q_EMIT messagesGetPeerSettingsError(q->mainMsgId(), errorCode, errorText, q->extra());
}

qint64 TelegramApi::messagesGetChats(const QList<qint32> &id, const QVariant &attachedData, Session *session) {
    if(!session) session = mMainSession;
    CHECK_SESSION(session)
    DEBUG_FUNCTION
    OutboundPkt p(mSettings);
    INIT_MAIN_CONNECTION(session)
    Functions::Messages::getChats(&p, id);
    return session->sendQuery(p, &messagesGetChatsMethods, attachedData, "Messages->getChats" );
}

void TelegramApi::onMessagesGetChatsAnswer(Query *q, InboundPkt &inboundPkt) {
    const MessagesChats &result = Functions::Messages::getChatsResult(&inboundPkt);
    if(result.error())
        onMessagesGetChatsError(q, -1, "LIBQTELEGRAM_INTERNAL_ERROR");
    else
        Q_EMIT messagesGetChatsAnswer(q->mainMsgId(), result, q->extra());
}

void TelegramApi::onMessagesGetChatsError(Query *q, qint32 errorCode, const QString &errorText) {
    bool accepted = false;
    onError(q, errorCode, errorText, q->extra(), accepted);
    if(!accepted)
        Q_EMIT messagesGetChatsError(q->mainMsgId(), errorCode, errorText, q->extra());
}

qint64 TelegramApi::messagesGetFullChat(qint32 chat_id, const QVariant &attachedData, Session *session) {
    if(!session) session = mMainSession;
    CHECK_SESSION(session)
    DEBUG_FUNCTION
    OutboundPkt p(mSettings);
    INIT_MAIN_CONNECTION(session)
    Functions::Messages::getFullChat(&p, chat_id);
    return session->sendQuery(p, &messagesGetFullChatMethods, attachedData, "Messages->getFullChat" );
}

void TelegramApi::onMessagesGetFullChatAnswer(Query *q, InboundPkt &inboundPkt) {
    const MessagesChatFull &result = Functions::Messages::getFullChatResult(&inboundPkt);
    if(result.error())
        onMessagesGetFullChatError(q, -1, "LIBQTELEGRAM_INTERNAL_ERROR");
    else
        Q_EMIT messagesGetFullChatAnswer(q->mainMsgId(), result, q->extra());
}

void TelegramApi::onMessagesGetFullChatError(Query *q, qint32 errorCode, const QString &errorText) {
    bool accepted = false;
    onError(q, errorCode, errorText, q->extra(), accepted);
    if(!accepted)
        Q_EMIT messagesGetFullChatError(q->mainMsgId(), errorCode, errorText, q->extra());
}

qint64 TelegramApi::messagesEditChatTitle(qint32 chat_id, const QString &title, const QVariant &attachedData, Session *session) {
    if(!session) session = mMainSession;
    CHECK_SESSION(session)
    DEBUG_FUNCTION
    OutboundPkt p(mSettings);
    INIT_MAIN_CONNECTION(session)
    Functions::Messages::editChatTitle(&p, chat_id, title);
    return session->sendQuery(p, &messagesEditChatTitleMethods, attachedData, "Messages->editChatTitle" );
}

void TelegramApi::onMessagesEditChatTitleAnswer(Query *q, InboundPkt &inboundPkt) {
    const UpdatesType &result = Functions::Messages::editChatTitleResult(&inboundPkt);
    if(result.error())
        onMessagesEditChatTitleError(q, -1, "LIBQTELEGRAM_INTERNAL_ERROR");
    else
        Q_EMIT messagesEditChatTitleAnswer(q->mainMsgId(), result, q->extra());
}

void TelegramApi::onMessagesEditChatTitleError(Query *q, qint32 errorCode, const QString &errorText) {
    bool accepted = false;
    onError(q, errorCode, errorText, q->extra(), accepted);
    if(!accepted)
        Q_EMIT messagesEditChatTitleError(q->mainMsgId(), errorCode, errorText, q->extra());
}

qint64 TelegramApi::messagesEditChatPhoto(qint32 chat_id, const InputChatPhoto &photo, const QVariant &attachedData, Session *session) {
    if(!session) session = mMainSession;
    CHECK_SESSION(session)
    DEBUG_FUNCTION
    OutboundPkt p(mSettings);
    INIT_MAIN_CONNECTION(session)
    Functions::Messages::editChatPhoto(&p, chat_id, photo);
    return session->sendQuery(p, &messagesEditChatPhotoMethods, attachedData, "Messages->editChatPhoto" );
}

void TelegramApi::onMessagesEditChatPhotoAnswer(Query *q, InboundPkt &inboundPkt) {
    const UpdatesType &result = Functions::Messages::editChatPhotoResult(&inboundPkt);
    if(result.error())
        onMessagesEditChatPhotoError(q, -1, "LIBQTELEGRAM_INTERNAL_ERROR");
    else
        Q_EMIT messagesEditChatPhotoAnswer(q->mainMsgId(), result, q->extra());
}

void TelegramApi::onMessagesEditChatPhotoError(Query *q, qint32 errorCode, const QString &errorText) {
    bool accepted = false;
    onError(q, errorCode, errorText, q->extra(), accepted);
    if(!accepted)
        Q_EMIT messagesEditChatPhotoError(q->mainMsgId(), errorCode, errorText, q->extra());
}

qint64 TelegramApi::messagesAddChatUser(qint32 chat_id, const InputUser &user_id, qint32 fwd_limit, const QVariant &attachedData, Session *session) {
    if(!session) session = mMainSession;
    CHECK_SESSION(session)
    DEBUG_FUNCTION
    OutboundPkt p(mSettings);
    INIT_MAIN_CONNECTION(session)
    Functions::Messages::addChatUser(&p, chat_id, user_id, fwd_limit);
    return session->sendQuery(p, &messagesAddChatUserMethods, attachedData, "Messages->addChatUser" );
}

void TelegramApi::onMessagesAddChatUserAnswer(Query *q, InboundPkt &inboundPkt) {
    const UpdatesType &result = Functions::Messages::addChatUserResult(&inboundPkt);
    if(result.error())
        onMessagesAddChatUserError(q, -1, "LIBQTELEGRAM_INTERNAL_ERROR");
    else
        Q_EMIT messagesAddChatUserAnswer(q->mainMsgId(), result, q->extra());
}

void TelegramApi::onMessagesAddChatUserError(Query *q, qint32 errorCode, const QString &errorText) {
    bool accepted = false;
    onError(q, errorCode, errorText, q->extra(), accepted);
    if(!accepted)
        Q_EMIT messagesAddChatUserError(q->mainMsgId(), errorCode, errorText, q->extra());
}

qint64 TelegramApi::messagesDeleteChatUser(qint32 chat_id, const InputUser &user_id, const QVariant &attachedData, Session *session) {
    if(!session) session = mMainSession;
    CHECK_SESSION(session)
    DEBUG_FUNCTION
    OutboundPkt p(mSettings);
    INIT_MAIN_CONNECTION(session)
    Functions::Messages::deleteChatUser(&p, chat_id, user_id);
    return session->sendQuery(p, &messagesDeleteChatUserMethods, attachedData, "Messages->deleteChatUser" );
}

void TelegramApi::onMessagesDeleteChatUserAnswer(Query *q, InboundPkt &inboundPkt) {
    const UpdatesType &result = Functions::Messages::deleteChatUserResult(&inboundPkt);
    if(result.error())
        onMessagesDeleteChatUserError(q, -1, "LIBQTELEGRAM_INTERNAL_ERROR");
    else
        Q_EMIT messagesDeleteChatUserAnswer(q->mainMsgId(), result, q->extra());
}

void TelegramApi::onMessagesDeleteChatUserError(Query *q, qint32 errorCode, const QString &errorText) {
    bool accepted = false;
    onError(q, errorCode, errorText, q->extra(), accepted);
    if(!accepted)
        Q_EMIT messagesDeleteChatUserError(q->mainMsgId(), errorCode, errorText, q->extra());
}

qint64 TelegramApi::messagesCreateChat(const QList<InputUser> &users, const QString &title, const QVariant &attachedData, Session *session) {
    if(!session) session = mMainSession;
    CHECK_SESSION(session)
    DEBUG_FUNCTION
    OutboundPkt p(mSettings);
    INIT_MAIN_CONNECTION(session)
    Functions::Messages::createChat(&p, users, title);
    return session->sendQuery(p, &messagesCreateChatMethods, attachedData, "Messages->createChat" );
}

void TelegramApi::onMessagesCreateChatAnswer(Query *q, InboundPkt &inboundPkt) {
    const UpdatesType &result = Functions::Messages::createChatResult(&inboundPkt);
    if(result.error())
        onMessagesCreateChatError(q, -1, "LIBQTELEGRAM_INTERNAL_ERROR");
    else
        Q_EMIT messagesCreateChatAnswer(q->mainMsgId(), result, q->extra());
}

void TelegramApi::onMessagesCreateChatError(Query *q, qint32 errorCode, const QString &errorText) {
    bool accepted = false;
    onError(q, errorCode, errorText, q->extra(), accepted);
    if(!accepted)
        Q_EMIT messagesCreateChatError(q->mainMsgId(), errorCode, errorText, q->extra());
}

qint64 TelegramApi::messagesForwardMessage(const InputPeer &peer, qint32 id, qint64 random_id, const QVariant &attachedData, Session *session) {
    if(!session) session = mMainSession;
    CHECK_SESSION(session)
    DEBUG_FUNCTION
    OutboundPkt p(mSettings);
    INIT_MAIN_CONNECTION(session)
    Functions::Messages::forwardMessage(&p, peer, id, random_id);
    return session->sendQuery(p, &messagesForwardMessageMethods, attachedData, "Messages->forwardMessage" );
}

void TelegramApi::onMessagesForwardMessageAnswer(Query *q, InboundPkt &inboundPkt) {
    const UpdatesType &result = Functions::Messages::forwardMessageResult(&inboundPkt);
    if(result.error())
        onMessagesForwardMessageError(q, -1, "LIBQTELEGRAM_INTERNAL_ERROR");
    else
        Q_EMIT messagesForwardMessageAnswer(q->mainMsgId(), result, q->extra());
}

void TelegramApi::onMessagesForwardMessageError(Query *q, qint32 errorCode, const QString &errorText) {
    bool accepted = false;
    onError(q, errorCode, errorText, q->extra(), accepted);
    if(!accepted)
        Q_EMIT messagesForwardMessageError(q->mainMsgId(), errorCode, errorText, q->extra());
}

qint64 TelegramApi::messagesSendBroadcast(const QList<InputUser> &contacts, const QList<qint64> &random_id, const QString &message, const InputMedia &media, const QVariant &attachedData, Session *session) {
    if(!session) session = mMainSession;
    CHECK_SESSION(session)
    DEBUG_FUNCTION
    OutboundPkt p(mSettings);
    INIT_MAIN_CONNECTION(session)
    Functions::Messages::sendBroadcast(&p, contacts, random_id, message, media);
    return session->sendQuery(p, &messagesSendBroadcastMethods, attachedData, "Messages->sendBroadcast" );
}

void TelegramApi::onMessagesSendBroadcastAnswer(Query *q, InboundPkt &inboundPkt) {
    const UpdatesType &result = Functions::Messages::sendBroadcastResult(&inboundPkt);
    if(result.error())
        onMessagesSendBroadcastError(q, -1, "LIBQTELEGRAM_INTERNAL_ERROR");
    else
        Q_EMIT messagesSendBroadcastAnswer(q->mainMsgId(), result, q->extra());
}

void TelegramApi::onMessagesSendBroadcastError(Query *q, qint32 errorCode, const QString &errorText) {
    bool accepted = false;
    onError(q, errorCode, errorText, q->extra(), accepted);
    if(!accepted)
        Q_EMIT messagesSendBroadcastError(q->mainMsgId(), errorCode, errorText, q->extra());
}

qint64 TelegramApi::messagesGetDhConfig(qint32 version, qint32 random_length, const QVariant &attachedData, Session *session) {
    if(!session) session = mMainSession;
    CHECK_SESSION(session)
    DEBUG_FUNCTION
    OutboundPkt p(mSettings);
    INIT_MAIN_CONNECTION(session)
    Functions::Messages::getDhConfig(&p, version, random_length);
    return session->sendQuery(p, &messagesGetDhConfigMethods, attachedData, "Messages->getDhConfig" );
}

void TelegramApi::onMessagesGetDhConfigAnswer(Query *q, InboundPkt &inboundPkt) {
    const MessagesDhConfig &result = Functions::Messages::getDhConfigResult(&inboundPkt);
    if(result.error())
        onMessagesGetDhConfigError(q, -1, "LIBQTELEGRAM_INTERNAL_ERROR");
    else
        Q_EMIT messagesGetDhConfigAnswer(q->mainMsgId(), result, q->extra());
}

void TelegramApi::onMessagesGetDhConfigError(Query *q, qint32 errorCode, const QString &errorText) {
    bool accepted = false;
    onError(q, errorCode, errorText, q->extra(), accepted);
    if(!accepted)
        Q_EMIT messagesGetDhConfigError(q->mainMsgId(), errorCode, errorText, q->extra());
}

qint64 TelegramApi::messagesRequestEncryption(const InputUser &user_id, qint32 random_id, const QByteArray &g_a, const QVariant &attachedData, Session *session) {
    if(!session) session = mMainSession;
    CHECK_SESSION(session)
    DEBUG_FUNCTION
    OutboundPkt p(mSettings);
    INIT_MAIN_CONNECTION(session)
    Functions::Messages::requestEncryption(&p, user_id, random_id, g_a);
    return session->sendQuery(p, &messagesRequestEncryptionMethods, attachedData, "Messages->requestEncryption" );
}

void TelegramApi::onMessagesRequestEncryptionAnswer(Query *q, InboundPkt &inboundPkt) {
    const EncryptedChat &result = Functions::Messages::requestEncryptionResult(&inboundPkt);
    if(result.error())
        onMessagesRequestEncryptionError(q, -1, "LIBQTELEGRAM_INTERNAL_ERROR");
    else
        Q_EMIT messagesRequestEncryptionAnswer(q->mainMsgId(), result, q->extra());
}

void TelegramApi::onMessagesRequestEncryptionError(Query *q, qint32 errorCode, const QString &errorText) {
    bool accepted = false;
    onError(q, errorCode, errorText, q->extra(), accepted);
    if(!accepted)
        Q_EMIT messagesRequestEncryptionError(q->mainMsgId(), errorCode, errorText, q->extra());
}

qint64 TelegramApi::messagesAcceptEncryption(const InputEncryptedChat &peer, const QByteArray &g_b, qint64 key_fingerprint, const QVariant &attachedData, Session *session) {
    if(!session) session = mMainSession;
    CHECK_SESSION(session)
    DEBUG_FUNCTION
    OutboundPkt p(mSettings);
    INIT_MAIN_CONNECTION(session)
    Functions::Messages::acceptEncryption(&p, peer, g_b, key_fingerprint);
    return session->sendQuery(p, &messagesAcceptEncryptionMethods, attachedData, "Messages->acceptEncryption" );
}

void TelegramApi::onMessagesAcceptEncryptionAnswer(Query *q, InboundPkt &inboundPkt) {
    const EncryptedChat &result = Functions::Messages::acceptEncryptionResult(&inboundPkt);
    if(result.error())
        onMessagesAcceptEncryptionError(q, -1, "LIBQTELEGRAM_INTERNAL_ERROR");
    else
        Q_EMIT messagesAcceptEncryptionAnswer(q->mainMsgId(), result, q->extra());
}

void TelegramApi::onMessagesAcceptEncryptionError(Query *q, qint32 errorCode, const QString &errorText) {
    bool accepted = false;
    onError(q, errorCode, errorText, q->extra(), accepted);
    if(!accepted)
        Q_EMIT messagesAcceptEncryptionError(q->mainMsgId(), errorCode, errorText, q->extra());
}

qint64 TelegramApi::messagesDiscardEncryption(qint32 chat_id, const QVariant &attachedData, Session *session) {
    if(!session) session = mMainSession;
    CHECK_SESSION(session)
    DEBUG_FUNCTION
    OutboundPkt p(mSettings);
    INIT_MAIN_CONNECTION(session)
    Functions::Messages::discardEncryption(&p, chat_id);
    return session->sendQuery(p, &messagesDiscardEncryptionMethods, attachedData, "Messages->discardEncryption" );
}

void TelegramApi::onMessagesDiscardEncryptionAnswer(Query *q, InboundPkt &inboundPkt) {
    const bool result = Functions::Messages::discardEncryptionResult(&inboundPkt);
    Q_EMIT messagesDiscardEncryptionAnswer(q->mainMsgId(), result, q->extra());
}

void TelegramApi::onMessagesDiscardEncryptionError(Query *q, qint32 errorCode, const QString &errorText) {
    bool accepted = false;
    onError(q, errorCode, errorText, q->extra(), accepted);
    if(!accepted)
        Q_EMIT messagesDiscardEncryptionError(q->mainMsgId(), errorCode, errorText, q->extra());
}

qint64 TelegramApi::messagesSetEncryptedTyping(const InputEncryptedChat &peer, bool typing, const QVariant &attachedData, Session *session) {
    if(!session) session = mMainSession;
    CHECK_SESSION(session)
    DEBUG_FUNCTION
    OutboundPkt p(mSettings);
    INIT_MAIN_CONNECTION(session)
    Functions::Messages::setEncryptedTyping(&p, peer, typing);
    return session->sendQuery(p, &messagesSetEncryptedTypingMethods, attachedData, "Messages->setEncryptedTyping" );
}

void TelegramApi::onMessagesSetEncryptedTypingAnswer(Query *q, InboundPkt &inboundPkt) {
    const bool result = Functions::Messages::setEncryptedTypingResult(&inboundPkt);
    Q_EMIT messagesSetEncryptedTypingAnswer(q->mainMsgId(), result, q->extra());
}

void TelegramApi::onMessagesSetEncryptedTypingError(Query *q, qint32 errorCode, const QString &errorText) {
    bool accepted = false;
    onError(q, errorCode, errorText, q->extra(), accepted);
    if(!accepted)
        Q_EMIT messagesSetEncryptedTypingError(q->mainMsgId(), errorCode, errorText, q->extra());
}

qint64 TelegramApi::messagesReadEncryptedHistory(const InputEncryptedChat &peer, qint32 max_date, const QVariant &attachedData, Session *session) {
    if(!session) session = mMainSession;
    CHECK_SESSION(session)
    DEBUG_FUNCTION
    OutboundPkt p(mSettings);
    INIT_MAIN_CONNECTION(session)
    Functions::Messages::readEncryptedHistory(&p, peer, max_date);
    return session->sendQuery(p, &messagesReadEncryptedHistoryMethods, attachedData, "Messages->readEncryptedHistory" );
}

void TelegramApi::onMessagesReadEncryptedHistoryAnswer(Query *q, InboundPkt &inboundPkt) {
    const bool result = Functions::Messages::readEncryptedHistoryResult(&inboundPkt);
    Q_EMIT messagesReadEncryptedHistoryAnswer(q->mainMsgId(), result, q->extra());
}

void TelegramApi::onMessagesReadEncryptedHistoryError(Query *q, qint32 errorCode, const QString &errorText) {
    bool accepted = false;
    onError(q, errorCode, errorText, q->extra(), accepted);
    if(!accepted)
        Q_EMIT messagesReadEncryptedHistoryError(q->mainMsgId(), errorCode, errorText, q->extra());
}

qint64 TelegramApi::messagesSendEncrypted(const InputEncryptedChat &peer, qint64 random_id, const QByteArray &data, const QVariant &attachedData, Session *session) {
    if(!session) session = mMainSession;
    CHECK_SESSION(session)
    DEBUG_FUNCTION
    OutboundPkt p(mSettings);
    INIT_MAIN_CONNECTION(session)
    Functions::Messages::sendEncrypted(&p, peer, random_id, data);
    return session->sendQuery(p, &messagesSendEncryptedMethods, attachedData, "Messages->sendEncrypted" );
}

void TelegramApi::onMessagesSendEncryptedAnswer(Query *q, InboundPkt &inboundPkt) {
    const MessagesSentEncryptedMessage &result = Functions::Messages::sendEncryptedResult(&inboundPkt);
    if(result.error())
        onMessagesSendEncryptedError(q, -1, "LIBQTELEGRAM_INTERNAL_ERROR");
    else
        Q_EMIT messagesSendEncryptedAnswer(q->mainMsgId(), result, q->extra());
}

void TelegramApi::onMessagesSendEncryptedError(Query *q, qint32 errorCode, const QString &errorText) {
    bool accepted = false;
    onError(q, errorCode, errorText, q->extra(), accepted);
    if(!accepted)
        Q_EMIT messagesSendEncryptedError(q->mainMsgId(), errorCode, errorText, q->extra());
}

qint64 TelegramApi::messagesSendEncryptedFile(const InputEncryptedChat &peer, qint64 random_id, const QByteArray &data, const InputEncryptedFile &file, const QVariant &attachedData, Session *session) {
    if(!session) session = mMainSession;
    CHECK_SESSION(session)
    DEBUG_FUNCTION
    OutboundPkt p(mSettings);
    INIT_MAIN_CONNECTION(session)
    Functions::Messages::sendEncryptedFile(&p, peer, random_id, data, file);
    return session->sendQuery(p, &messagesSendEncryptedFileMethods, attachedData, "Messages->sendEncryptedFile" );
}

void TelegramApi::onMessagesSendEncryptedFileAnswer(Query *q, InboundPkt &inboundPkt) {
    const MessagesSentEncryptedMessage &result = Functions::Messages::sendEncryptedFileResult(&inboundPkt);
    if(result.error())
        onMessagesSendEncryptedFileError(q, -1, "LIBQTELEGRAM_INTERNAL_ERROR");
    else
        Q_EMIT messagesSendEncryptedFileAnswer(q->mainMsgId(), result, q->extra());
}

void TelegramApi::onMessagesSendEncryptedFileError(Query *q, qint32 errorCode, const QString &errorText) {
    bool accepted = false;
    onError(q, errorCode, errorText, q->extra(), accepted);
    if(!accepted)
        Q_EMIT messagesSendEncryptedFileError(q->mainMsgId(), errorCode, errorText, q->extra());
}

qint64 TelegramApi::messagesSendEncryptedService(const InputEncryptedChat &peer, qint64 random_id, const QByteArray &data, const QVariant &attachedData, Session *session) {
    if(!session) session = mMainSession;
    CHECK_SESSION(session)
    DEBUG_FUNCTION
    OutboundPkt p(mSettings);
    INIT_MAIN_CONNECTION(session)
    Functions::Messages::sendEncryptedService(&p, peer, random_id, data);
    return session->sendQuery(p, &messagesSendEncryptedServiceMethods, attachedData, "Messages->sendEncryptedService" );
}

void TelegramApi::onMessagesSendEncryptedServiceAnswer(Query *q, InboundPkt &inboundPkt) {
    const MessagesSentEncryptedMessage &result = Functions::Messages::sendEncryptedServiceResult(&inboundPkt);
    if(result.error())
        onMessagesSendEncryptedServiceError(q, -1, "LIBQTELEGRAM_INTERNAL_ERROR");
    else
        Q_EMIT messagesSendEncryptedServiceAnswer(q->mainMsgId(), result, q->extra());
}

void TelegramApi::onMessagesSendEncryptedServiceError(Query *q, qint32 errorCode, const QString &errorText) {
    bool accepted = false;
    onError(q, errorCode, errorText, q->extra(), accepted);
    if(!accepted)
        Q_EMIT messagesSendEncryptedServiceError(q->mainMsgId(), errorCode, errorText, q->extra());
}

qint64 TelegramApi::messagesReceivedQueue(qint32 max_qts, const QVariant &attachedData, Session *session) {
    if(!session) session = mMainSession;
    CHECK_SESSION(session)
    DEBUG_FUNCTION
    OutboundPkt p(mSettings);
    INIT_MAIN_CONNECTION(session)
    Functions::Messages::receivedQueue(&p, max_qts);
    return session->sendQuery(p, &messagesReceivedQueueMethods, attachedData, "Messages->receivedQueue" );
}

void TelegramApi::onMessagesReceivedQueueAnswer(Query *q, InboundPkt &inboundPkt) {
    const QList<qint64> &result = Functions::Messages::receivedQueueResult(&inboundPkt);
    Q_EMIT messagesReceivedQueueAnswer(q->mainMsgId(), result, q->extra());
}

void TelegramApi::onMessagesReceivedQueueError(Query *q, qint32 errorCode, const QString &errorText) {
    bool accepted = false;
    onError(q, errorCode, errorText, q->extra(), accepted);
    if(!accepted)
        Q_EMIT messagesReceivedQueueError(q->mainMsgId(), errorCode, errorText, q->extra());
}

qint64 TelegramApi::messagesReadMessageContents(const QList<qint32> &id, const QVariant &attachedData, Session *session) {
    if(!session) session = mMainSession;
    CHECK_SESSION(session)
    DEBUG_FUNCTION
    OutboundPkt p(mSettings);
    INIT_MAIN_CONNECTION(session)
    Functions::Messages::readMessageContents(&p, id);
    return session->sendQuery(p, &messagesReadMessageContentsMethods, attachedData, "Messages->readMessageContents" );
}

void TelegramApi::onMessagesReadMessageContentsAnswer(Query *q, InboundPkt &inboundPkt) {
    const MessagesAffectedMessages &result = Functions::Messages::readMessageContentsResult(&inboundPkt);
    if(result.error())
        onMessagesReadMessageContentsError(q, -1, "LIBQTELEGRAM_INTERNAL_ERROR");
    else
        Q_EMIT messagesReadMessageContentsAnswer(q->mainMsgId(), result, q->extra());
}

void TelegramApi::onMessagesReadMessageContentsError(Query *q, qint32 errorCode, const QString &errorText) {
    bool accepted = false;
    onError(q, errorCode, errorText, q->extra(), accepted);
    if(!accepted)
        Q_EMIT messagesReadMessageContentsError(q->mainMsgId(), errorCode, errorText, q->extra());
}

qint64 TelegramApi::messagesGetStickers(const QString &emoticon, const QString &hash, const QVariant &attachedData, Session *session) {
    if(!session) session = mMainSession;
    CHECK_SESSION(session)
    DEBUG_FUNCTION
    OutboundPkt p(mSettings);
    INIT_MAIN_CONNECTION(session)
    Functions::Messages::getStickers(&p, emoticon, hash);
    return session->sendQuery(p, &messagesGetStickersMethods, attachedData, "Messages->getStickers" );
}

void TelegramApi::onMessagesGetStickersAnswer(Query *q, InboundPkt &inboundPkt) {
    const MessagesStickers &result = Functions::Messages::getStickersResult(&inboundPkt);
    if(result.error())
        onMessagesGetStickersError(q, -1, "LIBQTELEGRAM_INTERNAL_ERROR");
    else
        Q_EMIT messagesGetStickersAnswer(q->mainMsgId(), result, q->extra());
}

void TelegramApi::onMessagesGetStickersError(Query *q, qint32 errorCode, const QString &errorText) {
    bool accepted = false;
    onError(q, errorCode, errorText, q->extra(), accepted);
    if(!accepted)
        Q_EMIT messagesGetStickersError(q->mainMsgId(), errorCode, errorText, q->extra());
}

qint64 TelegramApi::messagesGetAllStickers(qint32 hash, const QVariant &attachedData, Session *session) {
    if(!session) session = mMainSession;
    CHECK_SESSION(session)
    DEBUG_FUNCTION
    OutboundPkt p(mSettings);
    INIT_MAIN_CONNECTION(session)
    Functions::Messages::getAllStickers(&p, hash);
    return session->sendQuery(p, &messagesGetAllStickersMethods, attachedData, "Messages->getAllStickers" );
}

void TelegramApi::onMessagesGetAllStickersAnswer(Query *q, InboundPkt &inboundPkt) {
    const MessagesAllStickers &result = Functions::Messages::getAllStickersResult(&inboundPkt);
    if(result.error())
        onMessagesGetAllStickersError(q, -1, "LIBQTELEGRAM_INTERNAL_ERROR");
    else
        Q_EMIT messagesGetAllStickersAnswer(q->mainMsgId(), result, q->extra());
}

void TelegramApi::onMessagesGetAllStickersError(Query *q, qint32 errorCode, const QString &errorText) {
    bool accepted = false;
    onError(q, errorCode, errorText, q->extra(), accepted);
    if(!accepted)
        Q_EMIT messagesGetAllStickersError(q->mainMsgId(), errorCode, errorText, q->extra());
}

qint64 TelegramApi::messagesGetWebPagePreview(const QString &message, const QVariant &attachedData, Session *session) {
    if(!session) session = mMainSession;
    CHECK_SESSION(session)
    DEBUG_FUNCTION
    OutboundPkt p(mSettings);
    INIT_MAIN_CONNECTION(session)
    Functions::Messages::getWebPagePreview(&p, message);
    return session->sendQuery(p, &messagesGetWebPagePreviewMethods, attachedData, "Messages->getWebPagePreview" );
}

void TelegramApi::onMessagesGetWebPagePreviewAnswer(Query *q, InboundPkt &inboundPkt) {
    const MessageMedia &result = Functions::Messages::getWebPagePreviewResult(&inboundPkt);
    if(result.error())
        onMessagesGetWebPagePreviewError(q, -1, "LIBQTELEGRAM_INTERNAL_ERROR");
    else
        Q_EMIT messagesGetWebPagePreviewAnswer(q->mainMsgId(), result, q->extra());
}

void TelegramApi::onMessagesGetWebPagePreviewError(Query *q, qint32 errorCode, const QString &errorText) {
    bool accepted = false;
    onError(q, errorCode, errorText, q->extra(), accepted);
    if(!accepted)
        Q_EMIT messagesGetWebPagePreviewError(q->mainMsgId(), errorCode, errorText, q->extra());
}

qint64 TelegramApi::messagesExportChatInvite(qint32 chat_id, const QVariant &attachedData, Session *session) {
    if(!session) session = mMainSession;
    CHECK_SESSION(session)
    DEBUG_FUNCTION
    OutboundPkt p(mSettings);
    INIT_MAIN_CONNECTION(session)
    Functions::Messages::exportChatInvite(&p, chat_id);
    return session->sendQuery(p, &messagesExportChatInviteMethods, attachedData, "Messages->exportChatInvite" );
}

void TelegramApi::onMessagesExportChatInviteAnswer(Query *q, InboundPkt &inboundPkt) {
    const ExportedChatInvite &result = Functions::Messages::exportChatInviteResult(&inboundPkt);
    if(result.error())
        onMessagesExportChatInviteError(q, -1, "LIBQTELEGRAM_INTERNAL_ERROR");
    else
        Q_EMIT messagesExportChatInviteAnswer(q->mainMsgId(), result, q->extra());
}

void TelegramApi::onMessagesExportChatInviteError(Query *q, qint32 errorCode, const QString &errorText) {
    bool accepted = false;
    onError(q, errorCode, errorText, q->extra(), accepted);
    if(!accepted)
        Q_EMIT messagesExportChatInviteError(q->mainMsgId(), errorCode, errorText, q->extra());
}

qint64 TelegramApi::messagesCheckChatInvite(const QString &hash, const QVariant &attachedData, Session *session) {
    if(!session) session = mMainSession;
    CHECK_SESSION(session)
    DEBUG_FUNCTION
    OutboundPkt p(mSettings);
    INIT_MAIN_CONNECTION(session)
    Functions::Messages::checkChatInvite(&p, hash);
    return session->sendQuery(p, &messagesCheckChatInviteMethods, attachedData, "Messages->checkChatInvite" );
}

void TelegramApi::onMessagesCheckChatInviteAnswer(Query *q, InboundPkt &inboundPkt) {
    const ChatInvite &result = Functions::Messages::checkChatInviteResult(&inboundPkt);
    if(result.error())
        onMessagesCheckChatInviteError(q, -1, "LIBQTELEGRAM_INTERNAL_ERROR");
    else
        Q_EMIT messagesCheckChatInviteAnswer(q->mainMsgId(), result, q->extra());
}

void TelegramApi::onMessagesCheckChatInviteError(Query *q, qint32 errorCode, const QString &errorText) {
    bool accepted = false;
    onError(q, errorCode, errorText, q->extra(), accepted);
    if(!accepted)
        Q_EMIT messagesCheckChatInviteError(q->mainMsgId(), errorCode, errorText, q->extra());
}

qint64 TelegramApi::messagesImportChatInvite(const QString &hash, const QVariant &attachedData, Session *session) {
    if(!session) session = mMainSession;
    CHECK_SESSION(session)
    DEBUG_FUNCTION
    OutboundPkt p(mSettings);
    INIT_MAIN_CONNECTION(session)
    Functions::Messages::importChatInvite(&p, hash);
    return session->sendQuery(p, &messagesImportChatInviteMethods, attachedData, "Messages->importChatInvite" );
}

void TelegramApi::onMessagesImportChatInviteAnswer(Query *q, InboundPkt &inboundPkt) {
    const UpdatesType &result = Functions::Messages::importChatInviteResult(&inboundPkt);
    if(result.error())
        onMessagesImportChatInviteError(q, -1, "LIBQTELEGRAM_INTERNAL_ERROR");
    else
        Q_EMIT messagesImportChatInviteAnswer(q->mainMsgId(), result, q->extra());
}

void TelegramApi::onMessagesImportChatInviteError(Query *q, qint32 errorCode, const QString &errorText) {
    bool accepted = false;
    onError(q, errorCode, errorText, q->extra(), accepted);
    if(!accepted)
        Q_EMIT messagesImportChatInviteError(q->mainMsgId(), errorCode, errorText, q->extra());
}

qint64 TelegramApi::messagesGetStickerSet(const InputStickerSet &stickerset, const QVariant &attachedData, Session *session) {
    if(!session) session = mMainSession;
    CHECK_SESSION(session)
    DEBUG_FUNCTION
    OutboundPkt p(mSettings);
    INIT_MAIN_CONNECTION(session)
    Functions::Messages::getStickerSet(&p, stickerset);
    return session->sendQuery(p, &messagesGetStickerSetMethods, attachedData, "Messages->getStickerSet" );
}

void TelegramApi::onMessagesGetStickerSetAnswer(Query *q, InboundPkt &inboundPkt) {
    const MessagesStickerSet &result = Functions::Messages::getStickerSetResult(&inboundPkt);
    if(result.error())
        onMessagesGetStickerSetError(q, -1, "LIBQTELEGRAM_INTERNAL_ERROR");
    else
        Q_EMIT messagesGetStickerSetAnswer(q->mainMsgId(), result, q->extra());
}

void TelegramApi::onMessagesGetStickerSetError(Query *q, qint32 errorCode, const QString &errorText) {
    bool accepted = false;
    onError(q, errorCode, errorText, q->extra(), accepted);
    if(!accepted)
        Q_EMIT messagesGetStickerSetError(q->mainMsgId(), errorCode, errorText, q->extra());
}

qint64 TelegramApi::messagesInstallStickerSet(const InputStickerSet &stickerset, bool disabled, const QVariant &attachedData, Session *session) {
    if(!session) session = mMainSession;
    CHECK_SESSION(session)
    DEBUG_FUNCTION
    OutboundPkt p(mSettings);
    INIT_MAIN_CONNECTION(session)
    Functions::Messages::installStickerSet(&p, stickerset, disabled);
    return session->sendQuery(p, &messagesInstallStickerSetMethods, attachedData, "Messages->installStickerSet" );
}

void TelegramApi::onMessagesInstallStickerSetAnswer(Query *q, InboundPkt &inboundPkt) {
    const bool result = Functions::Messages::installStickerSetResult(&inboundPkt);
    Q_EMIT messagesInstallStickerSetAnswer(q->mainMsgId(), result, q->extra());
}

void TelegramApi::onMessagesInstallStickerSetError(Query *q, qint32 errorCode, const QString &errorText) {
    bool accepted = false;
    onError(q, errorCode, errorText, q->extra(), accepted);
    if(!accepted)
        Q_EMIT messagesInstallStickerSetError(q->mainMsgId(), errorCode, errorText, q->extra());
}

qint64 TelegramApi::messagesUninstallStickerSet(const InputStickerSet &stickerset, const QVariant &attachedData, Session *session) {
    if(!session) session = mMainSession;
    CHECK_SESSION(session)
    DEBUG_FUNCTION
    OutboundPkt p(mSettings);
    INIT_MAIN_CONNECTION(session)
    Functions::Messages::uninstallStickerSet(&p, stickerset);
    return session->sendQuery(p, &messagesUninstallStickerSetMethods, attachedData, "Messages->uninstallStickerSet" );
}

void TelegramApi::onMessagesUninstallStickerSetAnswer(Query *q, InboundPkt &inboundPkt) {
    const bool result = Functions::Messages::uninstallStickerSetResult(&inboundPkt);
    Q_EMIT messagesUninstallStickerSetAnswer(q->mainMsgId(), result, q->extra());
}

void TelegramApi::onMessagesUninstallStickerSetError(Query *q, qint32 errorCode, const QString &errorText) {
    bool accepted = false;
    onError(q, errorCode, errorText, q->extra(), accepted);
    if(!accepted)
        Q_EMIT messagesUninstallStickerSetError(q->mainMsgId(), errorCode, errorText, q->extra());
}

qint64 TelegramApi::messagesStartBot(const InputUser &bot, const InputPeer &peer, qint64 random_id, const QString &start_param, const QVariant &attachedData, Session *session) {
    if(!session) session = mMainSession;
    CHECK_SESSION(session)
    DEBUG_FUNCTION
    OutboundPkt p(mSettings);
    INIT_MAIN_CONNECTION(session)
    Functions::Messages::startBot(&p, bot, peer, random_id, start_param);
    return session->sendQuery(p, &messagesStartBotMethods, attachedData, "Messages->startBot" );
}

void TelegramApi::onMessagesStartBotAnswer(Query *q, InboundPkt &inboundPkt) {
    const UpdatesType &result = Functions::Messages::startBotResult(&inboundPkt);
    if(result.error())
        onMessagesStartBotError(q, -1, "LIBQTELEGRAM_INTERNAL_ERROR");
    else
        Q_EMIT messagesStartBotAnswer(q->mainMsgId(), result, q->extra());
}

void TelegramApi::onMessagesStartBotError(Query *q, qint32 errorCode, const QString &errorText) {
    bool accepted = false;
    onError(q, errorCode, errorText, q->extra(), accepted);
    if(!accepted)
        Q_EMIT messagesStartBotError(q->mainMsgId(), errorCode, errorText, q->extra());
}

qint64 TelegramApi::messagesGetMessagesViews(const InputPeer &peer, const QList<qint32> &id, bool increment, const QVariant &attachedData, Session *session) {
    if(!session) session = mMainSession;
    CHECK_SESSION(session)
    DEBUG_FUNCTION
    OutboundPkt p(mSettings);
    INIT_MAIN_CONNECTION(session)
    Functions::Messages::getMessagesViews(&p, peer, id, increment);
    return session->sendQuery(p, &messagesGetMessagesViewsMethods, attachedData, "Messages->getMessagesViews" );
}

void TelegramApi::onMessagesGetMessagesViewsAnswer(Query *q, InboundPkt &inboundPkt) {
    const QList<qint32> &result = Functions::Messages::getMessagesViewsResult(&inboundPkt);
    Q_EMIT messagesGetMessagesViewsAnswer(q->mainMsgId(), result, q->extra());
}

void TelegramApi::onMessagesGetMessagesViewsError(Query *q, qint32 errorCode, const QString &errorText) {
    bool accepted = false;
    onError(q, errorCode, errorText, q->extra(), accepted);
    if(!accepted)
        Q_EMIT messagesGetMessagesViewsError(q->mainMsgId(), errorCode, errorText, q->extra());
}

qint64 TelegramApi::messagesToggleChatAdmins(qint32 chat_id, bool enabled, const QVariant &attachedData, Session *session) {
    if(!session) session = mMainSession;
    CHECK_SESSION(session)
    DEBUG_FUNCTION
    OutboundPkt p(mSettings);
    INIT_MAIN_CONNECTION(session)
    Functions::Messages::toggleChatAdmins(&p, chat_id, enabled);
    return session->sendQuery(p, &messagesToggleChatAdminsMethods, attachedData, "Messages->toggleChatAdmins" );
}

void TelegramApi::onMessagesToggleChatAdminsAnswer(Query *q, InboundPkt &inboundPkt) {
    const UpdatesType &result = Functions::Messages::toggleChatAdminsResult(&inboundPkt);
    if(result.error())
        onMessagesToggleChatAdminsError(q, -1, "LIBQTELEGRAM_INTERNAL_ERROR");
    else
        Q_EMIT messagesToggleChatAdminsAnswer(q->mainMsgId(), result, q->extra());
}

void TelegramApi::onMessagesToggleChatAdminsError(Query *q, qint32 errorCode, const QString &errorText) {
    bool accepted = false;
    onError(q, errorCode, errorText, q->extra(), accepted);
    if(!accepted)
        Q_EMIT messagesToggleChatAdminsError(q->mainMsgId(), errorCode, errorText, q->extra());
}

qint64 TelegramApi::messagesEditChatAdmin(qint32 chat_id, const InputUser &user_id, bool is_admin, const QVariant &attachedData, Session *session) {
    if(!session) session = mMainSession;
    CHECK_SESSION(session)
    DEBUG_FUNCTION
    OutboundPkt p(mSettings);
    INIT_MAIN_CONNECTION(session)
    Functions::Messages::editChatAdmin(&p, chat_id, user_id, is_admin);
    return session->sendQuery(p, &messagesEditChatAdminMethods, attachedData, "Messages->editChatAdmin" );
}

void TelegramApi::onMessagesEditChatAdminAnswer(Query *q, InboundPkt &inboundPkt) {
    const bool result = Functions::Messages::editChatAdminResult(&inboundPkt);
    Q_EMIT messagesEditChatAdminAnswer(q->mainMsgId(), result, q->extra());
}

void TelegramApi::onMessagesEditChatAdminError(Query *q, qint32 errorCode, const QString &errorText) {
    bool accepted = false;
    onError(q, errorCode, errorText, q->extra(), accepted);
    if(!accepted)
        Q_EMIT messagesEditChatAdminError(q->mainMsgId(), errorCode, errorText, q->extra());
}

qint64 TelegramApi::messagesMigrateChat(qint32 chat_id, const QVariant &attachedData, Session *session) {
    if(!session) session = mMainSession;
    CHECK_SESSION(session)
    DEBUG_FUNCTION
    OutboundPkt p(mSettings);
    INIT_MAIN_CONNECTION(session)
    Functions::Messages::migrateChat(&p, chat_id);
    return session->sendQuery(p, &messagesMigrateChatMethods, attachedData, "Messages->migrateChat" );
}

void TelegramApi::onMessagesMigrateChatAnswer(Query *q, InboundPkt &inboundPkt) {
    const UpdatesType &result = Functions::Messages::migrateChatResult(&inboundPkt);
    if(result.error())
        onMessagesMigrateChatError(q, -1, "LIBQTELEGRAM_INTERNAL_ERROR");
    else
        Q_EMIT messagesMigrateChatAnswer(q->mainMsgId(), result, q->extra());
}

void TelegramApi::onMessagesMigrateChatError(Query *q, qint32 errorCode, const QString &errorText) {
    bool accepted = false;
    onError(q, errorCode, errorText, q->extra(), accepted);
    if(!accepted)
        Q_EMIT messagesMigrateChatError(q->mainMsgId(), errorCode, errorText, q->extra());
}

qint64 TelegramApi::messagesSearchGlobal(const QString &q, qint32 offset_date, const InputPeer &offset_peer, qint32 offset_id, qint32 limit, const QVariant &attachedData, Session *session) {
    if(!session) session = mMainSession;
    CHECK_SESSION(session)
    DEBUG_FUNCTION
    OutboundPkt p(mSettings);
    INIT_MAIN_CONNECTION(session)
    Functions::Messages::searchGlobal(&p, q, offset_date, offset_peer, offset_id, limit);
    return session->sendQuery(p, &messagesSearchGlobalMethods, attachedData, "Messages->searchGlobal" );
}

void TelegramApi::onMessagesSearchGlobalAnswer(Query *q, InboundPkt &inboundPkt) {
    const MessagesMessages &result = Functions::Messages::searchGlobalResult(&inboundPkt);
    if(result.error())
        onMessagesSearchGlobalError(q, -1, "LIBQTELEGRAM_INTERNAL_ERROR");
    else
        Q_EMIT messagesSearchGlobalAnswer(q->mainMsgId(), result, q->extra());
}

void TelegramApi::onMessagesSearchGlobalError(Query *q, qint32 errorCode, const QString &errorText) {
    bool accepted = false;
    onError(q, errorCode, errorText, q->extra(), accepted);
    if(!accepted)
        Q_EMIT messagesSearchGlobalError(q->mainMsgId(), errorCode, errorText, q->extra());
}

qint64 TelegramApi::messagesReorderStickerSets(const QList<qint64> &order, const QVariant &attachedData, Session *session) {
    if(!session) session = mMainSession;
    CHECK_SESSION(session)
    DEBUG_FUNCTION
    OutboundPkt p(mSettings);
    INIT_MAIN_CONNECTION(session)
    Functions::Messages::reorderStickerSets(&p, order);
    return session->sendQuery(p, &messagesReorderStickerSetsMethods, attachedData, "Messages->reorderStickerSets" );
}

void TelegramApi::onMessagesReorderStickerSetsAnswer(Query *q, InboundPkt &inboundPkt) {
    const bool result = Functions::Messages::reorderStickerSetsResult(&inboundPkt);
    Q_EMIT messagesReorderStickerSetsAnswer(q->mainMsgId(), result, q->extra());
}

void TelegramApi::onMessagesReorderStickerSetsError(Query *q, qint32 errorCode, const QString &errorText) {
    bool accepted = false;
    onError(q, errorCode, errorText, q->extra(), accepted);
    if(!accepted)
        Q_EMIT messagesReorderStickerSetsError(q->mainMsgId(), errorCode, errorText, q->extra());
}

qint64 TelegramApi::messagesGetDocumentByHash(const QByteArray &sha256, qint32 size, const QString &mime_type, const QVariant &attachedData, Session *session) {
    if(!session) session = mMainSession;
    CHECK_SESSION(session)
    DEBUG_FUNCTION
    OutboundPkt p(mSettings);
    INIT_MAIN_CONNECTION(session)
    Functions::Messages::getDocumentByHash(&p, sha256, size, mime_type);
    return session->sendQuery(p, &messagesGetDocumentByHashMethods, attachedData, "Messages->getDocumentByHash" );
}

void TelegramApi::onMessagesGetDocumentByHashAnswer(Query *q, InboundPkt &inboundPkt) {
    const Document &result = Functions::Messages::getDocumentByHashResult(&inboundPkt);
    if(result.error())
        onMessagesGetDocumentByHashError(q, -1, "LIBQTELEGRAM_INTERNAL_ERROR");
    else
        Q_EMIT messagesGetDocumentByHashAnswer(q->mainMsgId(), result, q->extra());
}

void TelegramApi::onMessagesGetDocumentByHashError(Query *q, qint32 errorCode, const QString &errorText) {
    bool accepted = false;
    onError(q, errorCode, errorText, q->extra(), accepted);
    if(!accepted)
        Q_EMIT messagesGetDocumentByHashError(q->mainMsgId(), errorCode, errorText, q->extra());
}

qint64 TelegramApi::messagesSearchGifs(const QString &q, qint32 offset, const QVariant &attachedData, Session *session) {
    if(!session) session = mMainSession;
    CHECK_SESSION(session)
    DEBUG_FUNCTION
    OutboundPkt p(mSettings);
    INIT_MAIN_CONNECTION(session)
    Functions::Messages::searchGifs(&p, q, offset);
    return session->sendQuery(p, &messagesSearchGifsMethods, attachedData, "Messages->searchGifs" );
}

void TelegramApi::onMessagesSearchGifsAnswer(Query *q, InboundPkt &inboundPkt) {
    const MessagesFoundGifs &result = Functions::Messages::searchGifsResult(&inboundPkt);
    if(result.error())
        onMessagesSearchGifsError(q, -1, "LIBQTELEGRAM_INTERNAL_ERROR");
    else
        Q_EMIT messagesSearchGifsAnswer(q->mainMsgId(), result, q->extra());
}

void TelegramApi::onMessagesSearchGifsError(Query *q, qint32 errorCode, const QString &errorText) {
    bool accepted = false;
    onError(q, errorCode, errorText, q->extra(), accepted);
    if(!accepted)
        Q_EMIT messagesSearchGifsError(q->mainMsgId(), errorCode, errorText, q->extra());
}

qint64 TelegramApi::messagesGetSavedGifs(qint32 hash, const QVariant &attachedData, Session *session) {
    if(!session) session = mMainSession;
    CHECK_SESSION(session)
    DEBUG_FUNCTION
    OutboundPkt p(mSettings);
    INIT_MAIN_CONNECTION(session)
    Functions::Messages::getSavedGifs(&p, hash);
    return session->sendQuery(p, &messagesGetSavedGifsMethods, attachedData, "Messages->getSavedGifs" );
}

void TelegramApi::onMessagesGetSavedGifsAnswer(Query *q, InboundPkt &inboundPkt) {
    const MessagesSavedGifs &result = Functions::Messages::getSavedGifsResult(&inboundPkt);
    if(result.error())
        onMessagesGetSavedGifsError(q, -1, "LIBQTELEGRAM_INTERNAL_ERROR");
    else
        Q_EMIT messagesGetSavedGifsAnswer(q->mainMsgId(), result, q->extra());
}

void TelegramApi::onMessagesGetSavedGifsError(Query *q, qint32 errorCode, const QString &errorText) {
    bool accepted = false;
    onError(q, errorCode, errorText, q->extra(), accepted);
    if(!accepted)
        Q_EMIT messagesGetSavedGifsError(q->mainMsgId(), errorCode, errorText, q->extra());
}

qint64 TelegramApi::messagesSaveGif(const InputDocument &id, bool unsave, const QVariant &attachedData, Session *session) {
    if(!session) session = mMainSession;
    CHECK_SESSION(session)
    DEBUG_FUNCTION
    OutboundPkt p(mSettings);
    INIT_MAIN_CONNECTION(session)
    Functions::Messages::saveGif(&p, id, unsave);
    return session->sendQuery(p, &messagesSaveGifMethods, attachedData, "Messages->saveGif" );
}

void TelegramApi::onMessagesSaveGifAnswer(Query *q, InboundPkt &inboundPkt) {
    const bool result = Functions::Messages::saveGifResult(&inboundPkt);
    Q_EMIT messagesSaveGifAnswer(q->mainMsgId(), result, q->extra());
}

void TelegramApi::onMessagesSaveGifError(Query *q, qint32 errorCode, const QString &errorText) {
    bool accepted = false;
    onError(q, errorCode, errorText, q->extra(), accepted);
    if(!accepted)
        Q_EMIT messagesSaveGifError(q->mainMsgId(), errorCode, errorText, q->extra());
}

qint64 TelegramApi::messagesGetInlineBotResults(const InputUser &bot, const QString &query, const QString &offset, const QVariant &attachedData, Session *session) {
    if(!session) session = mMainSession;
    CHECK_SESSION(session)
    DEBUG_FUNCTION
    OutboundPkt p(mSettings);
    INIT_MAIN_CONNECTION(session)
    Functions::Messages::getInlineBotResults(&p, bot, query, offset);
    return session->sendQuery(p, &messagesGetInlineBotResultsMethods, attachedData, "Messages->getInlineBotResults" );
}

void TelegramApi::onMessagesGetInlineBotResultsAnswer(Query *q, InboundPkt &inboundPkt) {
    const MessagesBotResults &result = Functions::Messages::getInlineBotResultsResult(&inboundPkt);
    if(result.error())
        onMessagesGetInlineBotResultsError(q, -1, "LIBQTELEGRAM_INTERNAL_ERROR");
    else
        Q_EMIT messagesGetInlineBotResultsAnswer(q->mainMsgId(), result, q->extra());
}

void TelegramApi::onMessagesGetInlineBotResultsError(Query *q, qint32 errorCode, const QString &errorText) {
    bool accepted = false;
    onError(q, errorCode, errorText, q->extra(), accepted);
    if(!accepted)
        Q_EMIT messagesGetInlineBotResultsError(q->mainMsgId(), errorCode, errorText, q->extra());
}

qint64 TelegramApi::messagesSetInlineBotResults(bool gallery, bool privateValue, qint64 query_id, const QList<InputBotInlineResult> &results, qint32 cache_time, const QString &next_offset, const QVariant &attachedData, Session *session) {
    if(!session) session = mMainSession;
    CHECK_SESSION(session)
    DEBUG_FUNCTION
    OutboundPkt p(mSettings);
    INIT_MAIN_CONNECTION(session)
    Functions::Messages::setInlineBotResults(&p, gallery, privateValue, query_id, results, cache_time, next_offset);
    return session->sendQuery(p, &messagesSetInlineBotResultsMethods, attachedData, "Messages->setInlineBotResults" );
}

void TelegramApi::onMessagesSetInlineBotResultsAnswer(Query *q, InboundPkt &inboundPkt) {
    const bool result = Functions::Messages::setInlineBotResultsResult(&inboundPkt);
    Q_EMIT messagesSetInlineBotResultsAnswer(q->mainMsgId(), result, q->extra());
}

void TelegramApi::onMessagesSetInlineBotResultsError(Query *q, qint32 errorCode, const QString &errorText) {
    bool accepted = false;
    onError(q, errorCode, errorText, q->extra(), accepted);
    if(!accepted)
        Q_EMIT messagesSetInlineBotResultsError(q->mainMsgId(), errorCode, errorText, q->extra());
}

qint64 TelegramApi::messagesSendInlineBotResult(bool broadcast, bool silent, bool background, const InputPeer &peer, qint32 reply_to_msg_id, qint64 random_id, qint64 query_id, const QString &id, const QVariant &attachedData, Session *session) {
    if(!session) session = mMainSession;
    CHECK_SESSION(session)
    DEBUG_FUNCTION
    OutboundPkt p(mSettings);
    INIT_MAIN_CONNECTION(session)
    Functions::Messages::sendInlineBotResult(&p, broadcast, silent, background, peer, reply_to_msg_id, random_id, query_id, id);
    return session->sendQuery(p, &messagesSendInlineBotResultMethods, attachedData, "Messages->sendInlineBotResult" );
}

void TelegramApi::onMessagesSendInlineBotResultAnswer(Query *q, InboundPkt &inboundPkt) {
    const UpdatesType &result = Functions::Messages::sendInlineBotResultResult(&inboundPkt);
    if(result.error())
        onMessagesSendInlineBotResultError(q, -1, "LIBQTELEGRAM_INTERNAL_ERROR");
    else
        Q_EMIT messagesSendInlineBotResultAnswer(q->mainMsgId(), result, q->extra());
}

void TelegramApi::onMessagesSendInlineBotResultError(Query *q, qint32 errorCode, const QString &errorText) {
    bool accepted = false;
    onError(q, errorCode, errorText, q->extra(), accepted);
    if(!accepted)
        Q_EMIT messagesSendInlineBotResultError(q->mainMsgId(), errorCode, errorText, q->extra());
}


qint64 TelegramApi::photosUpdateProfilePhoto(const InputPhoto &id, const InputPhotoCrop &crop, const QVariant &attachedData, Session *session) {
    if(!session) session = mMainSession;
    CHECK_SESSION(session)
    DEBUG_FUNCTION
    OutboundPkt p(mSettings);
    INIT_MAIN_CONNECTION(session)
    Functions::Photos::updateProfilePhoto(&p, id, crop);
    return session->sendQuery(p, &photosUpdateProfilePhotoMethods, attachedData, "Photos->updateProfilePhoto" );
}

void TelegramApi::onPhotosUpdateProfilePhotoAnswer(Query *q, InboundPkt &inboundPkt) {
    const UserProfilePhoto &result = Functions::Photos::updateProfilePhotoResult(&inboundPkt);
    if(result.error())
        onPhotosUpdateProfilePhotoError(q, -1, "LIBQTELEGRAM_INTERNAL_ERROR");
    else
        Q_EMIT photosUpdateProfilePhotoAnswer(q->mainMsgId(), result, q->extra());
}

void TelegramApi::onPhotosUpdateProfilePhotoError(Query *q, qint32 errorCode, const QString &errorText) {
    bool accepted = false;
    onError(q, errorCode, errorText, q->extra(), accepted);
    if(!accepted)
        Q_EMIT photosUpdateProfilePhotoError(q->mainMsgId(), errorCode, errorText, q->extra());
}

qint64 TelegramApi::photosUploadProfilePhoto(const InputFile &file, const QString &caption, const InputGeoPoint &geo_point, const InputPhotoCrop &crop, const QVariant &attachedData, Session *session) {
    if(!session) session = mMainSession;
    CHECK_SESSION(session)
    DEBUG_FUNCTION
    OutboundPkt p(mSettings);
    INIT_MAIN_CONNECTION(session)
    Functions::Photos::uploadProfilePhoto(&p, file, caption, geo_point, crop);
    return session->sendQuery(p, &photosUploadProfilePhotoMethods, attachedData, "Photos->uploadProfilePhoto" );
}

void TelegramApi::onPhotosUploadProfilePhotoAnswer(Query *q, InboundPkt &inboundPkt) {
    const PhotosPhoto &result = Functions::Photos::uploadProfilePhotoResult(&inboundPkt);
    if(result.error())
        onPhotosUploadProfilePhotoError(q, -1, "LIBQTELEGRAM_INTERNAL_ERROR");
    else
        Q_EMIT photosUploadProfilePhotoAnswer(q->mainMsgId(), result, q->extra());
}

void TelegramApi::onPhotosUploadProfilePhotoError(Query *q, qint32 errorCode, const QString &errorText) {
    bool accepted = false;
    onError(q, errorCode, errorText, q->extra(), accepted);
    if(!accepted)
        Q_EMIT photosUploadProfilePhotoError(q->mainMsgId(), errorCode, errorText, q->extra());
}

qint64 TelegramApi::photosDeletePhotos(const QList<InputPhoto> &id, const QVariant &attachedData, Session *session) {
    if(!session) session = mMainSession;
    CHECK_SESSION(session)
    DEBUG_FUNCTION
    OutboundPkt p(mSettings);
    INIT_MAIN_CONNECTION(session)
    Functions::Photos::deletePhotos(&p, id);
    return session->sendQuery(p, &photosDeletePhotosMethods, attachedData, "Photos->deletePhotos" );
}

void TelegramApi::onPhotosDeletePhotosAnswer(Query *q, InboundPkt &inboundPkt) {
    const QList<qint64> &result = Functions::Photos::deletePhotosResult(&inboundPkt);
    Q_EMIT photosDeletePhotosAnswer(q->mainMsgId(), result, q->extra());
}

void TelegramApi::onPhotosDeletePhotosError(Query *q, qint32 errorCode, const QString &errorText) {
    bool accepted = false;
    onError(q, errorCode, errorText, q->extra(), accepted);
    if(!accepted)
        Q_EMIT photosDeletePhotosError(q->mainMsgId(), errorCode, errorText, q->extra());
}

qint64 TelegramApi::photosGetUserPhotos(const InputUser &user_id, qint32 offset, qint64 max_id, qint32 limit, const QVariant &attachedData, Session *session) {
    if(!session) session = mMainSession;
    CHECK_SESSION(session)
    DEBUG_FUNCTION
    OutboundPkt p(mSettings);
    INIT_MAIN_CONNECTION(session)
    Functions::Photos::getUserPhotos(&p, user_id, offset, max_id, limit);
    return session->sendQuery(p, &photosGetUserPhotosMethods, attachedData, "Photos->getUserPhotos" );
}

void TelegramApi::onPhotosGetUserPhotosAnswer(Query *q, InboundPkt &inboundPkt) {
    const PhotosPhotos &result = Functions::Photos::getUserPhotosResult(&inboundPkt);
    if(result.error())
        onPhotosGetUserPhotosError(q, -1, "LIBQTELEGRAM_INTERNAL_ERROR");
    else
        Q_EMIT photosGetUserPhotosAnswer(q->mainMsgId(), result, q->extra());
}

void TelegramApi::onPhotosGetUserPhotosError(Query *q, qint32 errorCode, const QString &errorText) {
    bool accepted = false;
    onError(q, errorCode, errorText, q->extra(), accepted);
    if(!accepted)
        Q_EMIT photosGetUserPhotosError(q->mainMsgId(), errorCode, errorText, q->extra());
}


qint64 TelegramApi::updatesGetState(const QVariant &attachedData, Session *session) {
    if(!session) session = mMainSession;
    CHECK_SESSION(session)
    DEBUG_FUNCTION
    OutboundPkt p(mSettings);
    INIT_MAIN_CONNECTION(session)
    Functions::Updates::getState(&p);
    return session->sendQuery(p, &updatesGetStateMethods, attachedData, "Updates->getState" );
}

void TelegramApi::onUpdatesGetStateAnswer(Query *q, InboundPkt &inboundPkt) {
    const UpdatesState &result = Functions::Updates::getStateResult(&inboundPkt);
    if(result.error())
        onUpdatesGetStateError(q, -1, "LIBQTELEGRAM_INTERNAL_ERROR");
    else
        Q_EMIT updatesGetStateAnswer(q->mainMsgId(), result, q->extra());
}

void TelegramApi::onUpdatesGetStateError(Query *q, qint32 errorCode, const QString &errorText) {
    bool accepted = false;
    onError(q, errorCode, errorText, q->extra(), accepted);
    if(!accepted)
        Q_EMIT updatesGetStateError(q->mainMsgId(), errorCode, errorText, q->extra());
}

qint64 TelegramApi::updatesGetDifference(qint32 pts, qint32 date, qint32 qts, const QVariant &attachedData, Session *session) {
    if(!session) session = mMainSession;
    CHECK_SESSION(session)
    DEBUG_FUNCTION
    OutboundPkt p(mSettings);
    INIT_MAIN_CONNECTION(session)
    Functions::Updates::getDifference(&p, pts, date, qts);
    return session->sendQuery(p, &updatesGetDifferenceMethods, attachedData, "Updates->getDifference" );
}

void TelegramApi::onUpdatesGetDifferenceAnswer(Query *q, InboundPkt &inboundPkt) {
    const UpdatesDifference &result = Functions::Updates::getDifferenceResult(&inboundPkt);
    if(result.error())
        onUpdatesGetDifferenceError(q, -1, "LIBQTELEGRAM_INTERNAL_ERROR");
    else
        Q_EMIT updatesGetDifferenceAnswer(q->mainMsgId(), result, q->extra());
}

void TelegramApi::onUpdatesGetDifferenceError(Query *q, qint32 errorCode, const QString &errorText) {
    bool accepted = false;
    onError(q, errorCode, errorText, q->extra(), accepted);
    if(!accepted)
        Q_EMIT updatesGetDifferenceError(q->mainMsgId(), errorCode, errorText, q->extra());
}

qint64 TelegramApi::updatesGetChannelDifference(const InputChannel &channel, const ChannelMessagesFilter &filter, qint32 pts, qint32 limit, const QVariant &attachedData, Session *session) {
    if(!session) session = mMainSession;
    CHECK_SESSION(session)
    DEBUG_FUNCTION
    OutboundPkt p(mSettings);
    INIT_MAIN_CONNECTION(session)
    Functions::Updates::getChannelDifference(&p, channel, filter, pts, limit);
    return session->sendQuery(p, &updatesGetChannelDifferenceMethods, attachedData, "Updates->getChannelDifference" );
}

void TelegramApi::onUpdatesGetChannelDifferenceAnswer(Query *q, InboundPkt &inboundPkt) {
    const UpdatesChannelDifference &result = Functions::Updates::getChannelDifferenceResult(&inboundPkt);
    if(result.error())
        onUpdatesGetChannelDifferenceError(q, -1, "LIBQTELEGRAM_INTERNAL_ERROR");
    else
        Q_EMIT updatesGetChannelDifferenceAnswer(q->mainMsgId(), result, q->extra());
}

void TelegramApi::onUpdatesGetChannelDifferenceError(Query *q, qint32 errorCode, const QString &errorText) {
    bool accepted = false;
    onError(q, errorCode, errorText, q->extra(), accepted);
    if(!accepted)
        Q_EMIT updatesGetChannelDifferenceError(q->mainMsgId(), errorCode, errorText, q->extra());
}


qint64 TelegramApi::uploadSaveFilePart(qint64 file_id, qint32 file_part, const QByteArray &bytes, const QVariant &attachedData, Session *session) {
    if(!session) session = mMainSession;
    CHECK_SESSION(session)
    DEBUG_FUNCTION
    OutboundPkt p(mSettings);
    INIT_MAIN_CONNECTION(session)
    Functions::Upload::saveFilePart(&p, file_id, file_part, bytes);
    return session->sendQuery(p, &uploadSaveFilePartMethods, attachedData, "Upload->saveFilePart" );
}

void TelegramApi::onUploadSaveFilePartAnswer(Query *q, InboundPkt &inboundPkt) {
    const bool result = Functions::Upload::saveFilePartResult(&inboundPkt);
    Q_EMIT uploadSaveFilePartAnswer(q->mainMsgId(), result, q->extra());
}

void TelegramApi::onUploadSaveFilePartError(Query *q, qint32 errorCode, const QString &errorText) {
    bool accepted = false;
    onError(q, errorCode, errorText, q->extra(), accepted);
    if(!accepted)
        Q_EMIT uploadSaveFilePartError(q->mainMsgId(), errorCode, errorText, q->extra());
}

qint64 TelegramApi::uploadGetFile(const InputFileLocation &location, qint32 offset, qint32 limit, const QVariant &attachedData, Session *session) {
    if(!session) session = mMainSession;
    CHECK_SESSION(session)
    DEBUG_FUNCTION
    OutboundPkt p(mSettings);
    INIT_MAIN_CONNECTION(session)
    Functions::Upload::getFile(&p, location, offset, limit);
    return session->sendQuery(p, &uploadGetFileMethods, attachedData, "Upload->getFile" );
}

void TelegramApi::onUploadGetFileAnswer(Query *q, InboundPkt &inboundPkt) {
    const UploadFile &result = Functions::Upload::getFileResult(&inboundPkt);
    if(result.error())
        onUploadGetFileError(q, -1, "LIBQTELEGRAM_INTERNAL_ERROR");
    else
        Q_EMIT uploadGetFileAnswer(q->mainMsgId(), result, q->extra());
}

void TelegramApi::onUploadGetFileError(Query *q, qint32 errorCode, const QString &errorText) {
    bool accepted = false;
    onError(q, errorCode, errorText, q->extra(), accepted);
    if(!accepted)
        Q_EMIT uploadGetFileError(q->mainMsgId(), errorCode, errorText, q->extra());
}

qint64 TelegramApi::uploadSaveBigFilePart(qint64 file_id, qint32 file_part, qint32 file_total_parts, const QByteArray &bytes, const QVariant &attachedData, Session *session) {
    if(!session) session = mMainSession;
    CHECK_SESSION(session)
    DEBUG_FUNCTION
    OutboundPkt p(mSettings);
    INIT_MAIN_CONNECTION(session)
    Functions::Upload::saveBigFilePart(&p, file_id, file_part, file_total_parts, bytes);
    return session->sendQuery(p, &uploadSaveBigFilePartMethods, attachedData, "Upload->saveBigFilePart" );
}

void TelegramApi::onUploadSaveBigFilePartAnswer(Query *q, InboundPkt &inboundPkt) {
    const bool result = Functions::Upload::saveBigFilePartResult(&inboundPkt);
    Q_EMIT uploadSaveBigFilePartAnswer(q->mainMsgId(), result, q->extra());
}

void TelegramApi::onUploadSaveBigFilePartError(Query *q, qint32 errorCode, const QString &errorText) {
    bool accepted = false;
    onError(q, errorCode, errorText, q->extra(), accepted);
    if(!accepted)
        Q_EMIT uploadSaveBigFilePartError(q->mainMsgId(), errorCode, errorText, q->extra());
}


qint64 TelegramApi::usersGetUsers(const QList<InputUser> &id, const QVariant &attachedData, Session *session) {
    if(!session) session = mMainSession;
    CHECK_SESSION(session)
    DEBUG_FUNCTION
    OutboundPkt p(mSettings);
    INIT_MAIN_CONNECTION(session)
    Functions::Users::getUsers(&p, id);
    return session->sendQuery(p, &usersGetUsersMethods, attachedData, "Users->getUsers" );
}

void TelegramApi::onUsersGetUsersAnswer(Query *q, InboundPkt &inboundPkt) {
    const QList<User> &result = Functions::Users::getUsersResult(&inboundPkt);
    Q_EMIT usersGetUsersAnswer(q->mainMsgId(), result, q->extra());
}

void TelegramApi::onUsersGetUsersError(Query *q, qint32 errorCode, const QString &errorText) {
    bool accepted = false;
    onError(q, errorCode, errorText, q->extra(), accepted);
    if(!accepted)
        Q_EMIT usersGetUsersError(q->mainMsgId(), errorCode, errorText, q->extra());
}

qint64 TelegramApi::usersGetFullUser(const InputUser &id, const QVariant &attachedData, Session *session) {
    if(!session) session = mMainSession;
    CHECK_SESSION(session)
    DEBUG_FUNCTION
    OutboundPkt p(mSettings);
    INIT_MAIN_CONNECTION(session)
    Functions::Users::getFullUser(&p, id);
    return session->sendQuery(p, &usersGetFullUserMethods, attachedData, "Users->getFullUser" );
}

void TelegramApi::onUsersGetFullUserAnswer(Query *q, InboundPkt &inboundPkt) {
    const UserFull &result = Functions::Users::getFullUserResult(&inboundPkt);
    if(result.error())
        onUsersGetFullUserError(q, -1, "LIBQTELEGRAM_INTERNAL_ERROR");
    else
        Q_EMIT usersGetFullUserAnswer(q->mainMsgId(), result, q->extra());
}

void TelegramApi::onUsersGetFullUserError(Query *q, qint32 errorCode, const QString &errorText) {
    bool accepted = false;
    onError(q, errorCode, errorText, q->extra(), accepted);
    if(!accepted)
        Q_EMIT usersGetFullUserError(q->mainMsgId(), errorCode, errorText, q->extra());
}

void TelegramApi::onError(Query *q, qint32 errorCode, const QString &errorText, const QVariant &attachedData, bool &accepted) {
    Q_EMIT error(q->msgId(), errorCode, errorText, q->name(), attachedData, accepted);
}
