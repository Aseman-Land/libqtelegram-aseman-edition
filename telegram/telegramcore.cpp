// This file generated by libqtelegram-code-generator.
// You can download it from: https://github.com/Aseman-Land/libqtelegram-code-generator
// DO NOT EDIT THIS FILE BY HAND -- YOUR CHANGES WILL BE OVERWRITTEN

#include "telegramcore.h"
#include <QDebug>

qint32 TelegramCore::mTimeOut = 30000;

TelegramCore::TelegramCore(QObject *parent) :
    QObject(parent)
{
}

void TelegramCore::setApi(TelegramApi *api)
{
    mApi = api;

    connect(api, &TelegramApi::accountRegisterDeviceAnswer, this, &TelegramCore::onAccountRegisterDeviceAnswer);
    connect(api, &TelegramApi::accountRegisterDeviceError, this, &TelegramCore::onAccountRegisterDeviceError);
    
    connect(api, &TelegramApi::accountUnregisterDeviceAnswer, this, &TelegramCore::onAccountUnregisterDeviceAnswer);
    connect(api, &TelegramApi::accountUnregisterDeviceError, this, &TelegramCore::onAccountUnregisterDeviceError);
    
    connect(api, &TelegramApi::accountUpdateNotifySettingsAnswer, this, &TelegramCore::onAccountUpdateNotifySettingsAnswer);
    connect(api, &TelegramApi::accountUpdateNotifySettingsError, this, &TelegramCore::onAccountUpdateNotifySettingsError);
    
    connect(api, &TelegramApi::accountGetNotifySettingsAnswer, this, &TelegramCore::onAccountGetNotifySettingsAnswer);
    connect(api, &TelegramApi::accountGetNotifySettingsError, this, &TelegramCore::onAccountGetNotifySettingsError);
    
    connect(api, &TelegramApi::accountResetNotifySettingsAnswer, this, &TelegramCore::onAccountResetNotifySettingsAnswer);
    connect(api, &TelegramApi::accountResetNotifySettingsError, this, &TelegramCore::onAccountResetNotifySettingsError);
    
    connect(api, &TelegramApi::accountUpdateProfileAnswer, this, &TelegramCore::onAccountUpdateProfileAnswer);
    connect(api, &TelegramApi::accountUpdateProfileError, this, &TelegramCore::onAccountUpdateProfileError);
    
    connect(api, &TelegramApi::accountUpdateStatusAnswer, this, &TelegramCore::onAccountUpdateStatusAnswer);
    connect(api, &TelegramApi::accountUpdateStatusError, this, &TelegramCore::onAccountUpdateStatusError);
    
    connect(api, &TelegramApi::accountGetWallPapersAnswer, this, &TelegramCore::onAccountGetWallPapersAnswer);
    connect(api, &TelegramApi::accountGetWallPapersError, this, &TelegramCore::onAccountGetWallPapersError);
    
    connect(api, &TelegramApi::accountReportPeerAnswer, this, &TelegramCore::onAccountReportPeerAnswer);
    connect(api, &TelegramApi::accountReportPeerError, this, &TelegramCore::onAccountReportPeerError);
    
    connect(api, &TelegramApi::accountCheckUsernameAnswer, this, &TelegramCore::onAccountCheckUsernameAnswer);
    connect(api, &TelegramApi::accountCheckUsernameError, this, &TelegramCore::onAccountCheckUsernameError);
    
    connect(api, &TelegramApi::accountUpdateUsernameAnswer, this, &TelegramCore::onAccountUpdateUsernameAnswer);
    connect(api, &TelegramApi::accountUpdateUsernameError, this, &TelegramCore::onAccountUpdateUsernameError);
    
    connect(api, &TelegramApi::accountGetPrivacyAnswer, this, &TelegramCore::onAccountGetPrivacyAnswer);
    connect(api, &TelegramApi::accountGetPrivacyError, this, &TelegramCore::onAccountGetPrivacyError);
    
    connect(api, &TelegramApi::accountSetPrivacyAnswer, this, &TelegramCore::onAccountSetPrivacyAnswer);
    connect(api, &TelegramApi::accountSetPrivacyError, this, &TelegramCore::onAccountSetPrivacyError);
    
    connect(api, &TelegramApi::accountDeleteAccountAnswer, this, &TelegramCore::onAccountDeleteAccountAnswer);
    connect(api, &TelegramApi::accountDeleteAccountError, this, &TelegramCore::onAccountDeleteAccountError);
    
    connect(api, &TelegramApi::accountGetAccountTTLAnswer, this, &TelegramCore::onAccountGetAccountTTLAnswer);
    connect(api, &TelegramApi::accountGetAccountTTLError, this, &TelegramCore::onAccountGetAccountTTLError);
    
    connect(api, &TelegramApi::accountSetAccountTTLAnswer, this, &TelegramCore::onAccountSetAccountTTLAnswer);
    connect(api, &TelegramApi::accountSetAccountTTLError, this, &TelegramCore::onAccountSetAccountTTLError);
    
    connect(api, &TelegramApi::accountSendChangePhoneCodeAnswer, this, &TelegramCore::onAccountSendChangePhoneCodeAnswer);
    connect(api, &TelegramApi::accountSendChangePhoneCodeError, this, &TelegramCore::onAccountSendChangePhoneCodeError);
    
    connect(api, &TelegramApi::accountChangePhoneAnswer, this, &TelegramCore::onAccountChangePhoneAnswer);
    connect(api, &TelegramApi::accountChangePhoneError, this, &TelegramCore::onAccountChangePhoneError);
    
    connect(api, &TelegramApi::accountUpdateDeviceLockedAnswer, this, &TelegramCore::onAccountUpdateDeviceLockedAnswer);
    connect(api, &TelegramApi::accountUpdateDeviceLockedError, this, &TelegramCore::onAccountUpdateDeviceLockedError);
    
    connect(api, &TelegramApi::accountGetAuthorizationsAnswer, this, &TelegramCore::onAccountGetAuthorizationsAnswer);
    connect(api, &TelegramApi::accountGetAuthorizationsError, this, &TelegramCore::onAccountGetAuthorizationsError);
    
    connect(api, &TelegramApi::accountResetAuthorizationAnswer, this, &TelegramCore::onAccountResetAuthorizationAnswer);
    connect(api, &TelegramApi::accountResetAuthorizationError, this, &TelegramCore::onAccountResetAuthorizationError);
    
    connect(api, &TelegramApi::accountGetPasswordAnswer, this, &TelegramCore::onAccountGetPasswordAnswer);
    connect(api, &TelegramApi::accountGetPasswordError, this, &TelegramCore::onAccountGetPasswordError);
    
    connect(api, &TelegramApi::accountGetPasswordSettingsAnswer, this, &TelegramCore::onAccountGetPasswordSettingsAnswer);
    connect(api, &TelegramApi::accountGetPasswordSettingsError, this, &TelegramCore::onAccountGetPasswordSettingsError);
    
    connect(api, &TelegramApi::accountUpdatePasswordSettingsAnswer, this, &TelegramCore::onAccountUpdatePasswordSettingsAnswer);
    connect(api, &TelegramApi::accountUpdatePasswordSettingsError, this, &TelegramCore::onAccountUpdatePasswordSettingsError);
    
    
    connect(api, &TelegramApi::authCheckPhoneAnswer, this, &TelegramCore::onAuthCheckPhoneAnswer);
    connect(api, &TelegramApi::authCheckPhoneError, this, &TelegramCore::onAuthCheckPhoneError);
    
    connect(api, &TelegramApi::authSendCodeAnswer, this, &TelegramCore::onAuthSendCodeAnswer);
    connect(api, &TelegramApi::authSendCodeError, this, &TelegramCore::onAuthSendCodeError);
    
    connect(api, &TelegramApi::authSendCallAnswer, this, &TelegramCore::onAuthSendCallAnswer);
    connect(api, &TelegramApi::authSendCallError, this, &TelegramCore::onAuthSendCallError);
    
    connect(api, &TelegramApi::authSignUpAnswer, this, &TelegramCore::onAuthSignUpAnswer);
    connect(api, &TelegramApi::authSignUpError, this, &TelegramCore::onAuthSignUpError);
    
    connect(api, &TelegramApi::authSignInAnswer, this, &TelegramCore::onAuthSignInAnswer);
    connect(api, &TelegramApi::authSignInError, this, &TelegramCore::onAuthSignInError);
    
    connect(api, &TelegramApi::authLogOutAnswer, this, &TelegramCore::onAuthLogOutAnswer);
    connect(api, &TelegramApi::authLogOutError, this, &TelegramCore::onAuthLogOutError);
    
    connect(api, &TelegramApi::authResetAuthorizationsAnswer, this, &TelegramCore::onAuthResetAuthorizationsAnswer);
    connect(api, &TelegramApi::authResetAuthorizationsError, this, &TelegramCore::onAuthResetAuthorizationsError);
    
    connect(api, &TelegramApi::authSendInvitesAnswer, this, &TelegramCore::onAuthSendInvitesAnswer);
    connect(api, &TelegramApi::authSendInvitesError, this, &TelegramCore::onAuthSendInvitesError);
    
    connect(api, &TelegramApi::authExportAuthorizationAnswer, this, &TelegramCore::onAuthExportAuthorizationAnswer);
    connect(api, &TelegramApi::authExportAuthorizationError, this, &TelegramCore::onAuthExportAuthorizationError);
    
    connect(api, &TelegramApi::authImportAuthorizationAnswer, this, &TelegramCore::onAuthImportAuthorizationAnswer);
    connect(api, &TelegramApi::authImportAuthorizationError, this, &TelegramCore::onAuthImportAuthorizationError);
    
    connect(api, &TelegramApi::authBindTempAuthKeyAnswer, this, &TelegramCore::onAuthBindTempAuthKeyAnswer);
    connect(api, &TelegramApi::authBindTempAuthKeyError, this, &TelegramCore::onAuthBindTempAuthKeyError);
    
    connect(api, &TelegramApi::authSendSmsAnswer, this, &TelegramCore::onAuthSendSmsAnswer);
    connect(api, &TelegramApi::authSendSmsError, this, &TelegramCore::onAuthSendSmsError);
    
    connect(api, &TelegramApi::authImportBotAuthorizationAnswer, this, &TelegramCore::onAuthImportBotAuthorizationAnswer);
    connect(api, &TelegramApi::authImportBotAuthorizationError, this, &TelegramCore::onAuthImportBotAuthorizationError);
    
    connect(api, &TelegramApi::authCheckPasswordAnswer, this, &TelegramCore::onAuthCheckPasswordAnswer);
    connect(api, &TelegramApi::authCheckPasswordError, this, &TelegramCore::onAuthCheckPasswordError);
    
    connect(api, &TelegramApi::authRequestPasswordRecoveryAnswer, this, &TelegramCore::onAuthRequestPasswordRecoveryAnswer);
    connect(api, &TelegramApi::authRequestPasswordRecoveryError, this, &TelegramCore::onAuthRequestPasswordRecoveryError);
    
    connect(api, &TelegramApi::authRecoverPasswordAnswer, this, &TelegramCore::onAuthRecoverPasswordAnswer);
    connect(api, &TelegramApi::authRecoverPasswordError, this, &TelegramCore::onAuthRecoverPasswordError);
    
    
    connect(api, &TelegramApi::channelsGetDialogsAnswer, this, &TelegramCore::onChannelsGetDialogsAnswer);
    connect(api, &TelegramApi::channelsGetDialogsError, this, &TelegramCore::onChannelsGetDialogsError);
    
    connect(api, &TelegramApi::channelsGetImportantHistoryAnswer, this, &TelegramCore::onChannelsGetImportantHistoryAnswer);
    connect(api, &TelegramApi::channelsGetImportantHistoryError, this, &TelegramCore::onChannelsGetImportantHistoryError);
    
    connect(api, &TelegramApi::channelsReadHistoryAnswer, this, &TelegramCore::onChannelsReadHistoryAnswer);
    connect(api, &TelegramApi::channelsReadHistoryError, this, &TelegramCore::onChannelsReadHistoryError);
    
    connect(api, &TelegramApi::channelsDeleteMessagesAnswer, this, &TelegramCore::onChannelsDeleteMessagesAnswer);
    connect(api, &TelegramApi::channelsDeleteMessagesError, this, &TelegramCore::onChannelsDeleteMessagesError);
    
    connect(api, &TelegramApi::channelsDeleteUserHistoryAnswer, this, &TelegramCore::onChannelsDeleteUserHistoryAnswer);
    connect(api, &TelegramApi::channelsDeleteUserHistoryError, this, &TelegramCore::onChannelsDeleteUserHistoryError);
    
    connect(api, &TelegramApi::channelsReportSpamAnswer, this, &TelegramCore::onChannelsReportSpamAnswer);
    connect(api, &TelegramApi::channelsReportSpamError, this, &TelegramCore::onChannelsReportSpamError);
    
    connect(api, &TelegramApi::channelsGetMessagesAnswer, this, &TelegramCore::onChannelsGetMessagesAnswer);
    connect(api, &TelegramApi::channelsGetMessagesError, this, &TelegramCore::onChannelsGetMessagesError);
    
    connect(api, &TelegramApi::channelsGetParticipantsAnswer, this, &TelegramCore::onChannelsGetParticipantsAnswer);
    connect(api, &TelegramApi::channelsGetParticipantsError, this, &TelegramCore::onChannelsGetParticipantsError);
    
    connect(api, &TelegramApi::channelsGetParticipantAnswer, this, &TelegramCore::onChannelsGetParticipantAnswer);
    connect(api, &TelegramApi::channelsGetParticipantError, this, &TelegramCore::onChannelsGetParticipantError);
    
    connect(api, &TelegramApi::channelsGetChannelsAnswer, this, &TelegramCore::onChannelsGetChannelsAnswer);
    connect(api, &TelegramApi::channelsGetChannelsError, this, &TelegramCore::onChannelsGetChannelsError);
    
    connect(api, &TelegramApi::channelsGetFullChannelAnswer, this, &TelegramCore::onChannelsGetFullChannelAnswer);
    connect(api, &TelegramApi::channelsGetFullChannelError, this, &TelegramCore::onChannelsGetFullChannelError);
    
    connect(api, &TelegramApi::channelsCreateChannelAnswer, this, &TelegramCore::onChannelsCreateChannelAnswer);
    connect(api, &TelegramApi::channelsCreateChannelError, this, &TelegramCore::onChannelsCreateChannelError);
    
    connect(api, &TelegramApi::channelsEditAboutAnswer, this, &TelegramCore::onChannelsEditAboutAnswer);
    connect(api, &TelegramApi::channelsEditAboutError, this, &TelegramCore::onChannelsEditAboutError);
    
    connect(api, &TelegramApi::channelsEditAdminAnswer, this, &TelegramCore::onChannelsEditAdminAnswer);
    connect(api, &TelegramApi::channelsEditAdminError, this, &TelegramCore::onChannelsEditAdminError);
    
    connect(api, &TelegramApi::channelsEditTitleAnswer, this, &TelegramCore::onChannelsEditTitleAnswer);
    connect(api, &TelegramApi::channelsEditTitleError, this, &TelegramCore::onChannelsEditTitleError);
    
    connect(api, &TelegramApi::channelsEditPhotoAnswer, this, &TelegramCore::onChannelsEditPhotoAnswer);
    connect(api, &TelegramApi::channelsEditPhotoError, this, &TelegramCore::onChannelsEditPhotoError);
    
    connect(api, &TelegramApi::channelsToggleCommentsAnswer, this, &TelegramCore::onChannelsToggleCommentsAnswer);
    connect(api, &TelegramApi::channelsToggleCommentsError, this, &TelegramCore::onChannelsToggleCommentsError);
    
    connect(api, &TelegramApi::channelsCheckUsernameAnswer, this, &TelegramCore::onChannelsCheckUsernameAnswer);
    connect(api, &TelegramApi::channelsCheckUsernameError, this, &TelegramCore::onChannelsCheckUsernameError);
    
    connect(api, &TelegramApi::channelsUpdateUsernameAnswer, this, &TelegramCore::onChannelsUpdateUsernameAnswer);
    connect(api, &TelegramApi::channelsUpdateUsernameError, this, &TelegramCore::onChannelsUpdateUsernameError);
    
    connect(api, &TelegramApi::channelsJoinChannelAnswer, this, &TelegramCore::onChannelsJoinChannelAnswer);
    connect(api, &TelegramApi::channelsJoinChannelError, this, &TelegramCore::onChannelsJoinChannelError);
    
    connect(api, &TelegramApi::channelsLeaveChannelAnswer, this, &TelegramCore::onChannelsLeaveChannelAnswer);
    connect(api, &TelegramApi::channelsLeaveChannelError, this, &TelegramCore::onChannelsLeaveChannelError);
    
    connect(api, &TelegramApi::channelsInviteToChannelAnswer, this, &TelegramCore::onChannelsInviteToChannelAnswer);
    connect(api, &TelegramApi::channelsInviteToChannelError, this, &TelegramCore::onChannelsInviteToChannelError);
    
    connect(api, &TelegramApi::channelsKickFromChannelAnswer, this, &TelegramCore::onChannelsKickFromChannelAnswer);
    connect(api, &TelegramApi::channelsKickFromChannelError, this, &TelegramCore::onChannelsKickFromChannelError);
    
    connect(api, &TelegramApi::channelsExportInviteAnswer, this, &TelegramCore::onChannelsExportInviteAnswer);
    connect(api, &TelegramApi::channelsExportInviteError, this, &TelegramCore::onChannelsExportInviteError);
    
    connect(api, &TelegramApi::channelsDeleteChannelAnswer, this, &TelegramCore::onChannelsDeleteChannelAnswer);
    connect(api, &TelegramApi::channelsDeleteChannelError, this, &TelegramCore::onChannelsDeleteChannelError);
    
    
    connect(api, &TelegramApi::contactsGetStatusesAnswer, this, &TelegramCore::onContactsGetStatusesAnswer);
    connect(api, &TelegramApi::contactsGetStatusesError, this, &TelegramCore::onContactsGetStatusesError);
    
    connect(api, &TelegramApi::contactsGetContactsAnswer, this, &TelegramCore::onContactsGetContactsAnswer);
    connect(api, &TelegramApi::contactsGetContactsError, this, &TelegramCore::onContactsGetContactsError);
    
    connect(api, &TelegramApi::contactsImportContactsAnswer, this, &TelegramCore::onContactsImportContactsAnswer);
    connect(api, &TelegramApi::contactsImportContactsError, this, &TelegramCore::onContactsImportContactsError);
    
    connect(api, &TelegramApi::contactsGetSuggestedAnswer, this, &TelegramCore::onContactsGetSuggestedAnswer);
    connect(api, &TelegramApi::contactsGetSuggestedError, this, &TelegramCore::onContactsGetSuggestedError);
    
    connect(api, &TelegramApi::contactsDeleteContactAnswer, this, &TelegramCore::onContactsDeleteContactAnswer);
    connect(api, &TelegramApi::contactsDeleteContactError, this, &TelegramCore::onContactsDeleteContactError);
    
    connect(api, &TelegramApi::contactsDeleteContactsAnswer, this, &TelegramCore::onContactsDeleteContactsAnswer);
    connect(api, &TelegramApi::contactsDeleteContactsError, this, &TelegramCore::onContactsDeleteContactsError);
    
    connect(api, &TelegramApi::contactsBlockAnswer, this, &TelegramCore::onContactsBlockAnswer);
    connect(api, &TelegramApi::contactsBlockError, this, &TelegramCore::onContactsBlockError);
    
    connect(api, &TelegramApi::contactsUnblockAnswer, this, &TelegramCore::onContactsUnblockAnswer);
    connect(api, &TelegramApi::contactsUnblockError, this, &TelegramCore::onContactsUnblockError);
    
    connect(api, &TelegramApi::contactsGetBlockedAnswer, this, &TelegramCore::onContactsGetBlockedAnswer);
    connect(api, &TelegramApi::contactsGetBlockedError, this, &TelegramCore::onContactsGetBlockedError);
    
    connect(api, &TelegramApi::contactsExportCardAnswer, this, &TelegramCore::onContactsExportCardAnswer);
    connect(api, &TelegramApi::contactsExportCardError, this, &TelegramCore::onContactsExportCardError);
    
    connect(api, &TelegramApi::contactsImportCardAnswer, this, &TelegramCore::onContactsImportCardAnswer);
    connect(api, &TelegramApi::contactsImportCardError, this, &TelegramCore::onContactsImportCardError);
    
    connect(api, &TelegramApi::contactsSearchAnswer, this, &TelegramCore::onContactsSearchAnswer);
    connect(api, &TelegramApi::contactsSearchError, this, &TelegramCore::onContactsSearchError);
    
    connect(api, &TelegramApi::contactsResolveUsernameAnswer, this, &TelegramCore::onContactsResolveUsernameAnswer);
    connect(api, &TelegramApi::contactsResolveUsernameError, this, &TelegramCore::onContactsResolveUsernameError);
    
    
    connect(api, &TelegramApi::helpGetConfigAnswer, this, &TelegramCore::onHelpGetConfigAnswer);
    connect(api, &TelegramApi::helpGetConfigError, this, &TelegramCore::onHelpGetConfigError);
    
    connect(api, &TelegramApi::helpGetNearestDcAnswer, this, &TelegramCore::onHelpGetNearestDcAnswer);
    connect(api, &TelegramApi::helpGetNearestDcError, this, &TelegramCore::onHelpGetNearestDcError);
    
    connect(api, &TelegramApi::helpGetAppUpdateAnswer, this, &TelegramCore::onHelpGetAppUpdateAnswer);
    connect(api, &TelegramApi::helpGetAppUpdateError, this, &TelegramCore::onHelpGetAppUpdateError);
    
    connect(api, &TelegramApi::helpSaveAppLogAnswer, this, &TelegramCore::onHelpSaveAppLogAnswer);
    connect(api, &TelegramApi::helpSaveAppLogError, this, &TelegramCore::onHelpSaveAppLogError);
    
    connect(api, &TelegramApi::helpGetInviteTextAnswer, this, &TelegramCore::onHelpGetInviteTextAnswer);
    connect(api, &TelegramApi::helpGetInviteTextError, this, &TelegramCore::onHelpGetInviteTextError);
    
    connect(api, &TelegramApi::helpGetSupportAnswer, this, &TelegramCore::onHelpGetSupportAnswer);
    connect(api, &TelegramApi::helpGetSupportError, this, &TelegramCore::onHelpGetSupportError);
    
    connect(api, &TelegramApi::helpGetAppChangelogAnswer, this, &TelegramCore::onHelpGetAppChangelogAnswer);
    connect(api, &TelegramApi::helpGetAppChangelogError, this, &TelegramCore::onHelpGetAppChangelogError);
    
    connect(api, &TelegramApi::helpGetTermsOfServiceAnswer, this, &TelegramCore::onHelpGetTermsOfServiceAnswer);
    connect(api, &TelegramApi::helpGetTermsOfServiceError, this, &TelegramCore::onHelpGetTermsOfServiceError);
    
    
    connect(api, &TelegramApi::messagesGetMessagesAnswer, this, &TelegramCore::onMessagesGetMessagesAnswer);
    connect(api, &TelegramApi::messagesGetMessagesError, this, &TelegramCore::onMessagesGetMessagesError);
    
    connect(api, &TelegramApi::messagesGetDialogsAnswer, this, &TelegramCore::onMessagesGetDialogsAnswer);
    connect(api, &TelegramApi::messagesGetDialogsError, this, &TelegramCore::onMessagesGetDialogsError);
    
    connect(api, &TelegramApi::messagesGetHistoryAnswer, this, &TelegramCore::onMessagesGetHistoryAnswer);
    connect(api, &TelegramApi::messagesGetHistoryError, this, &TelegramCore::onMessagesGetHistoryError);
    
    connect(api, &TelegramApi::messagesSearchAnswer, this, &TelegramCore::onMessagesSearchAnswer);
    connect(api, &TelegramApi::messagesSearchError, this, &TelegramCore::onMessagesSearchError);
    
    connect(api, &TelegramApi::messagesReadHistoryAnswer, this, &TelegramCore::onMessagesReadHistoryAnswer);
    connect(api, &TelegramApi::messagesReadHistoryError, this, &TelegramCore::onMessagesReadHistoryError);
    
    connect(api, &TelegramApi::messagesDeleteHistoryAnswer, this, &TelegramCore::onMessagesDeleteHistoryAnswer);
    connect(api, &TelegramApi::messagesDeleteHistoryError, this, &TelegramCore::onMessagesDeleteHistoryError);
    
    connect(api, &TelegramApi::messagesDeleteMessagesAnswer, this, &TelegramCore::onMessagesDeleteMessagesAnswer);
    connect(api, &TelegramApi::messagesDeleteMessagesError, this, &TelegramCore::onMessagesDeleteMessagesError);
    
    connect(api, &TelegramApi::messagesReceivedMessagesAnswer, this, &TelegramCore::onMessagesReceivedMessagesAnswer);
    connect(api, &TelegramApi::messagesReceivedMessagesError, this, &TelegramCore::onMessagesReceivedMessagesError);
    
    connect(api, &TelegramApi::messagesSetTypingAnswer, this, &TelegramCore::onMessagesSetTypingAnswer);
    connect(api, &TelegramApi::messagesSetTypingError, this, &TelegramCore::onMessagesSetTypingError);
    
    connect(api, &TelegramApi::messagesSendMessageAnswer, this, &TelegramCore::onMessagesSendMessageAnswer);
    connect(api, &TelegramApi::messagesSendMessageError, this, &TelegramCore::onMessagesSendMessageError);
    
    connect(api, &TelegramApi::messagesSendMediaAnswer, this, &TelegramCore::onMessagesSendMediaAnswer);
    connect(api, &TelegramApi::messagesSendMediaError, this, &TelegramCore::onMessagesSendMediaError);
    
    connect(api, &TelegramApi::messagesForwardMessagesAnswer, this, &TelegramCore::onMessagesForwardMessagesAnswer);
    connect(api, &TelegramApi::messagesForwardMessagesError, this, &TelegramCore::onMessagesForwardMessagesError);
    
    connect(api, &TelegramApi::messagesReportSpamAnswer, this, &TelegramCore::onMessagesReportSpamAnswer);
    connect(api, &TelegramApi::messagesReportSpamError, this, &TelegramCore::onMessagesReportSpamError);
    
    connect(api, &TelegramApi::messagesGetChatsAnswer, this, &TelegramCore::onMessagesGetChatsAnswer);
    connect(api, &TelegramApi::messagesGetChatsError, this, &TelegramCore::onMessagesGetChatsError);
    
    connect(api, &TelegramApi::messagesGetFullChatAnswer, this, &TelegramCore::onMessagesGetFullChatAnswer);
    connect(api, &TelegramApi::messagesGetFullChatError, this, &TelegramCore::onMessagesGetFullChatError);
    
    connect(api, &TelegramApi::messagesEditChatTitleAnswer, this, &TelegramCore::onMessagesEditChatTitleAnswer);
    connect(api, &TelegramApi::messagesEditChatTitleError, this, &TelegramCore::onMessagesEditChatTitleError);
    
    connect(api, &TelegramApi::messagesEditChatPhotoAnswer, this, &TelegramCore::onMessagesEditChatPhotoAnswer);
    connect(api, &TelegramApi::messagesEditChatPhotoError, this, &TelegramCore::onMessagesEditChatPhotoError);
    
    connect(api, &TelegramApi::messagesAddChatUserAnswer, this, &TelegramCore::onMessagesAddChatUserAnswer);
    connect(api, &TelegramApi::messagesAddChatUserError, this, &TelegramCore::onMessagesAddChatUserError);
    
    connect(api, &TelegramApi::messagesDeleteChatUserAnswer, this, &TelegramCore::onMessagesDeleteChatUserAnswer);
    connect(api, &TelegramApi::messagesDeleteChatUserError, this, &TelegramCore::onMessagesDeleteChatUserError);
    
    connect(api, &TelegramApi::messagesCreateChatAnswer, this, &TelegramCore::onMessagesCreateChatAnswer);
    connect(api, &TelegramApi::messagesCreateChatError, this, &TelegramCore::onMessagesCreateChatError);
    
    connect(api, &TelegramApi::messagesForwardMessageAnswer, this, &TelegramCore::onMessagesForwardMessageAnswer);
    connect(api, &TelegramApi::messagesForwardMessageError, this, &TelegramCore::onMessagesForwardMessageError);
    
    connect(api, &TelegramApi::messagesSendBroadcastAnswer, this, &TelegramCore::onMessagesSendBroadcastAnswer);
    connect(api, &TelegramApi::messagesSendBroadcastError, this, &TelegramCore::onMessagesSendBroadcastError);
    
    connect(api, &TelegramApi::messagesGetDhConfigAnswer, this, &TelegramCore::onMessagesGetDhConfigAnswer);
    connect(api, &TelegramApi::messagesGetDhConfigError, this, &TelegramCore::onMessagesGetDhConfigError);
    
    connect(api, &TelegramApi::messagesRequestEncryptionAnswer, this, &TelegramCore::onMessagesRequestEncryptionAnswer);
    connect(api, &TelegramApi::messagesRequestEncryptionError, this, &TelegramCore::onMessagesRequestEncryptionError);
    
    connect(api, &TelegramApi::messagesAcceptEncryptionAnswer, this, &TelegramCore::onMessagesAcceptEncryptionAnswer);
    connect(api, &TelegramApi::messagesAcceptEncryptionError, this, &TelegramCore::onMessagesAcceptEncryptionError);
    
    connect(api, &TelegramApi::messagesDiscardEncryptionAnswer, this, &TelegramCore::onMessagesDiscardEncryptionAnswer);
    connect(api, &TelegramApi::messagesDiscardEncryptionError, this, &TelegramCore::onMessagesDiscardEncryptionError);
    
    connect(api, &TelegramApi::messagesSetEncryptedTypingAnswer, this, &TelegramCore::onMessagesSetEncryptedTypingAnswer);
    connect(api, &TelegramApi::messagesSetEncryptedTypingError, this, &TelegramCore::onMessagesSetEncryptedTypingError);
    
    connect(api, &TelegramApi::messagesReadEncryptedHistoryAnswer, this, &TelegramCore::onMessagesReadEncryptedHistoryAnswer);
    connect(api, &TelegramApi::messagesReadEncryptedHistoryError, this, &TelegramCore::onMessagesReadEncryptedHistoryError);
    
    connect(api, &TelegramApi::messagesSendEncryptedAnswer, this, &TelegramCore::onMessagesSendEncryptedAnswer);
    connect(api, &TelegramApi::messagesSendEncryptedError, this, &TelegramCore::onMessagesSendEncryptedError);
    
    connect(api, &TelegramApi::messagesSendEncryptedFileAnswer, this, &TelegramCore::onMessagesSendEncryptedFileAnswer);
    connect(api, &TelegramApi::messagesSendEncryptedFileError, this, &TelegramCore::onMessagesSendEncryptedFileError);
    
    connect(api, &TelegramApi::messagesSendEncryptedServiceAnswer, this, &TelegramCore::onMessagesSendEncryptedServiceAnswer);
    connect(api, &TelegramApi::messagesSendEncryptedServiceError, this, &TelegramCore::onMessagesSendEncryptedServiceError);
    
    connect(api, &TelegramApi::messagesReceivedQueueAnswer, this, &TelegramCore::onMessagesReceivedQueueAnswer);
    connect(api, &TelegramApi::messagesReceivedQueueError, this, &TelegramCore::onMessagesReceivedQueueError);
    
    connect(api, &TelegramApi::messagesReadMessageContentsAnswer, this, &TelegramCore::onMessagesReadMessageContentsAnswer);
    connect(api, &TelegramApi::messagesReadMessageContentsError, this, &TelegramCore::onMessagesReadMessageContentsError);
    
    connect(api, &TelegramApi::messagesGetStickersAnswer, this, &TelegramCore::onMessagesGetStickersAnswer);
    connect(api, &TelegramApi::messagesGetStickersError, this, &TelegramCore::onMessagesGetStickersError);
    
    connect(api, &TelegramApi::messagesGetAllStickersAnswer, this, &TelegramCore::onMessagesGetAllStickersAnswer);
    connect(api, &TelegramApi::messagesGetAllStickersError, this, &TelegramCore::onMessagesGetAllStickersError);
    
    connect(api, &TelegramApi::messagesGetWebPagePreviewAnswer, this, &TelegramCore::onMessagesGetWebPagePreviewAnswer);
    connect(api, &TelegramApi::messagesGetWebPagePreviewError, this, &TelegramCore::onMessagesGetWebPagePreviewError);
    
    connect(api, &TelegramApi::messagesExportChatInviteAnswer, this, &TelegramCore::onMessagesExportChatInviteAnswer);
    connect(api, &TelegramApi::messagesExportChatInviteError, this, &TelegramCore::onMessagesExportChatInviteError);
    
    connect(api, &TelegramApi::messagesCheckChatInviteAnswer, this, &TelegramCore::onMessagesCheckChatInviteAnswer);
    connect(api, &TelegramApi::messagesCheckChatInviteError, this, &TelegramCore::onMessagesCheckChatInviteError);
    
    connect(api, &TelegramApi::messagesImportChatInviteAnswer, this, &TelegramCore::onMessagesImportChatInviteAnswer);
    connect(api, &TelegramApi::messagesImportChatInviteError, this, &TelegramCore::onMessagesImportChatInviteError);
    
    connect(api, &TelegramApi::messagesGetStickerSetAnswer, this, &TelegramCore::onMessagesGetStickerSetAnswer);
    connect(api, &TelegramApi::messagesGetStickerSetError, this, &TelegramCore::onMessagesGetStickerSetError);
    
    connect(api, &TelegramApi::messagesInstallStickerSetAnswer, this, &TelegramCore::onMessagesInstallStickerSetAnswer);
    connect(api, &TelegramApi::messagesInstallStickerSetError, this, &TelegramCore::onMessagesInstallStickerSetError);
    
    connect(api, &TelegramApi::messagesUninstallStickerSetAnswer, this, &TelegramCore::onMessagesUninstallStickerSetAnswer);
    connect(api, &TelegramApi::messagesUninstallStickerSetError, this, &TelegramCore::onMessagesUninstallStickerSetError);
    
    connect(api, &TelegramApi::messagesStartBotAnswer, this, &TelegramCore::onMessagesStartBotAnswer);
    connect(api, &TelegramApi::messagesStartBotError, this, &TelegramCore::onMessagesStartBotError);
    
    connect(api, &TelegramApi::messagesGetMessagesViewsAnswer, this, &TelegramCore::onMessagesGetMessagesViewsAnswer);
    connect(api, &TelegramApi::messagesGetMessagesViewsError, this, &TelegramCore::onMessagesGetMessagesViewsError);
    
    connect(api, &TelegramApi::messagesToggleChatAdminsAnswer, this, &TelegramCore::onMessagesToggleChatAdminsAnswer);
    connect(api, &TelegramApi::messagesToggleChatAdminsError, this, &TelegramCore::onMessagesToggleChatAdminsError);
    
    connect(api, &TelegramApi::messagesEditChatAdminAnswer, this, &TelegramCore::onMessagesEditChatAdminAnswer);
    connect(api, &TelegramApi::messagesEditChatAdminError, this, &TelegramCore::onMessagesEditChatAdminError);
    
    connect(api, &TelegramApi::messagesMigrateChatAnswer, this, &TelegramCore::onMessagesMigrateChatAnswer);
    connect(api, &TelegramApi::messagesMigrateChatError, this, &TelegramCore::onMessagesMigrateChatError);
    
    connect(api, &TelegramApi::messagesSearchGlobalAnswer, this, &TelegramCore::onMessagesSearchGlobalAnswer);
    connect(api, &TelegramApi::messagesSearchGlobalError, this, &TelegramCore::onMessagesSearchGlobalError);
    
    connect(api, &TelegramApi::messagesReorderStickerSetsAnswer, this, &TelegramCore::onMessagesReorderStickerSetsAnswer);
    connect(api, &TelegramApi::messagesReorderStickerSetsError, this, &TelegramCore::onMessagesReorderStickerSetsError);
    
    connect(api, &TelegramApi::messagesGetDocumentByHashAnswer, this, &TelegramCore::onMessagesGetDocumentByHashAnswer);
    connect(api, &TelegramApi::messagesGetDocumentByHashError, this, &TelegramCore::onMessagesGetDocumentByHashError);
    
    connect(api, &TelegramApi::messagesSearchGifsAnswer, this, &TelegramCore::onMessagesSearchGifsAnswer);
    connect(api, &TelegramApi::messagesSearchGifsError, this, &TelegramCore::onMessagesSearchGifsError);
    
    connect(api, &TelegramApi::messagesGetSavedGifsAnswer, this, &TelegramCore::onMessagesGetSavedGifsAnswer);
    connect(api, &TelegramApi::messagesGetSavedGifsError, this, &TelegramCore::onMessagesGetSavedGifsError);
    
    connect(api, &TelegramApi::messagesSaveGifAnswer, this, &TelegramCore::onMessagesSaveGifAnswer);
    connect(api, &TelegramApi::messagesSaveGifError, this, &TelegramCore::onMessagesSaveGifError);
    
    connect(api, &TelegramApi::messagesGetInlineBotResultsAnswer, this, &TelegramCore::onMessagesGetInlineBotResultsAnswer);
    connect(api, &TelegramApi::messagesGetInlineBotResultsError, this, &TelegramCore::onMessagesGetInlineBotResultsError);
    
    connect(api, &TelegramApi::messagesSetInlineBotResultsAnswer, this, &TelegramCore::onMessagesSetInlineBotResultsAnswer);
    connect(api, &TelegramApi::messagesSetInlineBotResultsError, this, &TelegramCore::onMessagesSetInlineBotResultsError);
    
    connect(api, &TelegramApi::messagesSendInlineBotResultAnswer, this, &TelegramCore::onMessagesSendInlineBotResultAnswer);
    connect(api, &TelegramApi::messagesSendInlineBotResultError, this, &TelegramCore::onMessagesSendInlineBotResultError);
    
    
    connect(api, &TelegramApi::photosUpdateProfilePhotoAnswer, this, &TelegramCore::onPhotosUpdateProfilePhotoAnswer);
    connect(api, &TelegramApi::photosUpdateProfilePhotoError, this, &TelegramCore::onPhotosUpdateProfilePhotoError);
    
    connect(api, &TelegramApi::photosUploadProfilePhotoAnswer, this, &TelegramCore::onPhotosUploadProfilePhotoAnswer);
    connect(api, &TelegramApi::photosUploadProfilePhotoError, this, &TelegramCore::onPhotosUploadProfilePhotoError);
    
    connect(api, &TelegramApi::photosDeletePhotosAnswer, this, &TelegramCore::onPhotosDeletePhotosAnswer);
    connect(api, &TelegramApi::photosDeletePhotosError, this, &TelegramCore::onPhotosDeletePhotosError);
    
    connect(api, &TelegramApi::photosGetUserPhotosAnswer, this, &TelegramCore::onPhotosGetUserPhotosAnswer);
    connect(api, &TelegramApi::photosGetUserPhotosError, this, &TelegramCore::onPhotosGetUserPhotosError);
    
    
    connect(api, &TelegramApi::updatesGetStateAnswer, this, &TelegramCore::onUpdatesGetStateAnswer);
    connect(api, &TelegramApi::updatesGetStateError, this, &TelegramCore::onUpdatesGetStateError);
    
    connect(api, &TelegramApi::updatesGetDifferenceAnswer, this, &TelegramCore::onUpdatesGetDifferenceAnswer);
    connect(api, &TelegramApi::updatesGetDifferenceError, this, &TelegramCore::onUpdatesGetDifferenceError);
    
    connect(api, &TelegramApi::updatesGetChannelDifferenceAnswer, this, &TelegramCore::onUpdatesGetChannelDifferenceAnswer);
    connect(api, &TelegramApi::updatesGetChannelDifferenceError, this, &TelegramCore::onUpdatesGetChannelDifferenceError);
    
    
    connect(api, &TelegramApi::uploadSaveFilePartAnswer, this, &TelegramCore::onUploadSaveFilePartAnswer);
    connect(api, &TelegramApi::uploadSaveFilePartError, this, &TelegramCore::onUploadSaveFilePartError);
    
    connect(api, &TelegramApi::uploadGetFileAnswer, this, &TelegramCore::onUploadGetFileAnswer);
    connect(api, &TelegramApi::uploadGetFileError, this, &TelegramCore::onUploadGetFileError);
    
    connect(api, &TelegramApi::uploadSaveBigFilePartAnswer, this, &TelegramCore::onUploadSaveBigFilePartAnswer);
    connect(api, &TelegramApi::uploadSaveBigFilePartError, this, &TelegramCore::onUploadSaveBigFilePartError);
    
    
    connect(api, &TelegramApi::usersGetUsersAnswer, this, &TelegramCore::onUsersGetUsersAnswer);
    connect(api, &TelegramApi::usersGetUsersError, this, &TelegramCore::onUsersGetUsersError);
    
    connect(api, &TelegramApi::usersGetFullUserAnswer, this, &TelegramCore::onUsersGetFullUserAnswer);
    connect(api, &TelegramApi::usersGetFullUserError, this, &TelegramCore::onUsersGetFullUserError);

    connect(api, &TelegramApi::error, this, &TelegramCore::onError);
}

qint64 TelegramCore::accountRegisterDevice(qint32 token_type, const QString &token, const QString &device_model, const QString &system_version, const QString &app_version, bool app_sandbox, const QString &lang_code, Callback<bool > callBack, qint32 timeout) {
    if(!mApi) {
        bool result = 0;
        if(callBack)
            callBack(0, result, apiError());
        return 0;
    }
    qint64 msgId = mApi->accountRegisterDevice(token_type, token, device_model, system_version, app_version, app_sandbox, lang_code);
    if(msgId) {
        callBackPush<bool >(msgId, callBack);
        startTimeOut(msgId, timeout);
        mRecallArgs[msgId][""] = "accountRegisterDevice";
        mRecallArgs[msgId]["token_type"] = QVariant::fromValue<qint32>(token_type);
        mRecallArgs[msgId]["token"] = QVariant::fromValue<QString>(token);
        mRecallArgs[msgId]["device_model"] = QVariant::fromValue<QString>(device_model);
        mRecallArgs[msgId]["system_version"] = QVariant::fromValue<QString>(system_version);
        mRecallArgs[msgId]["app_version"] = QVariant::fromValue<QString>(app_version);
        mRecallArgs[msgId]["app_sandbox"] = QVariant::fromValue<bool>(app_sandbox);
        mRecallArgs[msgId]["lang_code"] = QVariant::fromValue<QString>(lang_code);
    } else {
        bool result = 0;
        if(callBack)
            callBack(0, result, apiError());
    }
    return msgId;
}

void TelegramCore::onAccountRegisterDeviceAnswer(qint64 msgId, bool result, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mRecallArgs.remove(msgId);
    callBackCall<bool >(msgId, result);
    stopTimeOut(msgId);
    Q_EMIT accountRegisterDeviceAnswer(msgId, result);
}

void TelegramCore::onAccountRegisterDeviceError(qint64 msgId, qint32 errorCode, const QString &errorText, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mRecallArgs.remove(msgId);
    bool result = 0;
    CallbackError error;
    error.errorCode = errorCode;
    error.errorText = errorText;
    error.null = false;
    callBackCall<bool >(msgId, result, error);
    stopTimeOut(msgId);
    Q_EMIT accountRegisterDeviceError(msgId, errorCode, errorText);
}

qint64 TelegramCore::accountUnregisterDevice(qint32 token_type, const QString &token, Callback<bool > callBack, qint32 timeout) {
    if(!mApi) {
        bool result = 0;
        if(callBack)
            callBack(0, result, apiError());
        return 0;
    }
    qint64 msgId = mApi->accountUnregisterDevice(token_type, token);
    if(msgId) {
        callBackPush<bool >(msgId, callBack);
        startTimeOut(msgId, timeout);
        mRecallArgs[msgId][""] = "accountUnregisterDevice";
        mRecallArgs[msgId]["token_type"] = QVariant::fromValue<qint32>(token_type);
        mRecallArgs[msgId]["token"] = QVariant::fromValue<QString>(token);
    } else {
        bool result = 0;
        if(callBack)
            callBack(0, result, apiError());
    }
    return msgId;
}

void TelegramCore::onAccountUnregisterDeviceAnswer(qint64 msgId, bool result, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mRecallArgs.remove(msgId);
    callBackCall<bool >(msgId, result);
    stopTimeOut(msgId);
    Q_EMIT accountUnregisterDeviceAnswer(msgId, result);
}

void TelegramCore::onAccountUnregisterDeviceError(qint64 msgId, qint32 errorCode, const QString &errorText, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mRecallArgs.remove(msgId);
    bool result = 0;
    CallbackError error;
    error.errorCode = errorCode;
    error.errorText = errorText;
    error.null = false;
    callBackCall<bool >(msgId, result, error);
    stopTimeOut(msgId);
    Q_EMIT accountUnregisterDeviceError(msgId, errorCode, errorText);
}

qint64 TelegramCore::accountUpdateNotifySettings(const InputNotifyPeer &peer, const InputPeerNotifySettings &settings, Callback<bool > callBack, qint32 timeout) {
    if(!mApi) {
        bool result = 0;
        if(callBack)
            callBack(0, result, apiError());
        return 0;
    }
    qint64 msgId = mApi->accountUpdateNotifySettings(peer, settings);
    if(msgId) {
        callBackPush<bool >(msgId, callBack);
        startTimeOut(msgId, timeout);
        mRecallArgs[msgId][""] = "accountUpdateNotifySettings";
        mRecallArgs[msgId]["peer"] = QVariant::fromValue<InputNotifyPeer>(peer);
        mRecallArgs[msgId]["settings"] = QVariant::fromValue<InputPeerNotifySettings>(settings);
    } else {
        bool result = 0;
        if(callBack)
            callBack(0, result, apiError());
    }
    return msgId;
}

void TelegramCore::onAccountUpdateNotifySettingsAnswer(qint64 msgId, bool result, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mRecallArgs.remove(msgId);
    callBackCall<bool >(msgId, result);
    stopTimeOut(msgId);
    Q_EMIT accountUpdateNotifySettingsAnswer(msgId, result);
}

void TelegramCore::onAccountUpdateNotifySettingsError(qint64 msgId, qint32 errorCode, const QString &errorText, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mRecallArgs.remove(msgId);
    bool result = 0;
    CallbackError error;
    error.errorCode = errorCode;
    error.errorText = errorText;
    error.null = false;
    callBackCall<bool >(msgId, result, error);
    stopTimeOut(msgId);
    Q_EMIT accountUpdateNotifySettingsError(msgId, errorCode, errorText);
}

qint64 TelegramCore::accountGetNotifySettings(const InputNotifyPeer &peer, Callback<PeerNotifySettings > callBack, qint32 timeout) {
    if(!mApi) {
        const PeerNotifySettings &result = PeerNotifySettings();
        if(callBack)
            callBack(0, result, apiError());
        return 0;
    }
    qint64 msgId = mApi->accountGetNotifySettings(peer);
    if(msgId) {
        callBackPush<PeerNotifySettings >(msgId, callBack);
        startTimeOut(msgId, timeout);
        mRecallArgs[msgId][""] = "accountGetNotifySettings";
        mRecallArgs[msgId]["peer"] = QVariant::fromValue<InputNotifyPeer>(peer);
    } else {
        const PeerNotifySettings &result = PeerNotifySettings();
        if(callBack)
            callBack(0, result, apiError());
    }
    return msgId;
}

void TelegramCore::onAccountGetNotifySettingsAnswer(qint64 msgId, const PeerNotifySettings &result, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mRecallArgs.remove(msgId);
    callBackCall<PeerNotifySettings >(msgId, result);
    stopTimeOut(msgId);
    Q_EMIT accountGetNotifySettingsAnswer(msgId, result);
}

void TelegramCore::onAccountGetNotifySettingsError(qint64 msgId, qint32 errorCode, const QString &errorText, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mRecallArgs.remove(msgId);
    const PeerNotifySettings &result = PeerNotifySettings();
    CallbackError error;
    error.errorCode = errorCode;
    error.errorText = errorText;
    error.null = false;
    callBackCall<PeerNotifySettings >(msgId, result, error);
    stopTimeOut(msgId);
    Q_EMIT accountGetNotifySettingsError(msgId, errorCode, errorText);
}

qint64 TelegramCore::accountResetNotifySettings(Callback<bool > callBack, qint32 timeout) {
    if(!mApi) {
        bool result = 0;
        if(callBack)
            callBack(0, result, apiError());
        return 0;
    }
    qint64 msgId = mApi->accountResetNotifySettings();
    if(msgId) {
        callBackPush<bool >(msgId, callBack);
        startTimeOut(msgId, timeout);
        mRecallArgs[msgId][""] = "accountResetNotifySettings";
    } else {
        bool result = 0;
        if(callBack)
            callBack(0, result, apiError());
    }
    return msgId;
}

void TelegramCore::onAccountResetNotifySettingsAnswer(qint64 msgId, bool result, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mRecallArgs.remove(msgId);
    callBackCall<bool >(msgId, result);
    stopTimeOut(msgId);
    Q_EMIT accountResetNotifySettingsAnswer(msgId, result);
}

void TelegramCore::onAccountResetNotifySettingsError(qint64 msgId, qint32 errorCode, const QString &errorText, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mRecallArgs.remove(msgId);
    bool result = 0;
    CallbackError error;
    error.errorCode = errorCode;
    error.errorText = errorText;
    error.null = false;
    callBackCall<bool >(msgId, result, error);
    stopTimeOut(msgId);
    Q_EMIT accountResetNotifySettingsError(msgId, errorCode, errorText);
}

qint64 TelegramCore::accountUpdateProfile(const QString &first_name, const QString &last_name, Callback<User > callBack, qint32 timeout) {
    if(!mApi) {
        const User &result = User();
        if(callBack)
            callBack(0, result, apiError());
        return 0;
    }
    qint64 msgId = mApi->accountUpdateProfile(first_name, last_name);
    if(msgId) {
        callBackPush<User >(msgId, callBack);
        startTimeOut(msgId, timeout);
        mRecallArgs[msgId][""] = "accountUpdateProfile";
        mRecallArgs[msgId]["first_name"] = QVariant::fromValue<QString>(first_name);
        mRecallArgs[msgId]["last_name"] = QVariant::fromValue<QString>(last_name);
    } else {
        const User &result = User();
        if(callBack)
            callBack(0, result, apiError());
    }
    return msgId;
}

void TelegramCore::onAccountUpdateProfileAnswer(qint64 msgId, const User &result, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mRecallArgs.remove(msgId);
    callBackCall<User >(msgId, result);
    stopTimeOut(msgId);
    Q_EMIT accountUpdateProfileAnswer(msgId, result);
}

void TelegramCore::onAccountUpdateProfileError(qint64 msgId, qint32 errorCode, const QString &errorText, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mRecallArgs.remove(msgId);
    const User &result = User();
    CallbackError error;
    error.errorCode = errorCode;
    error.errorText = errorText;
    error.null = false;
    callBackCall<User >(msgId, result, error);
    stopTimeOut(msgId);
    Q_EMIT accountUpdateProfileError(msgId, errorCode, errorText);
}

qint64 TelegramCore::accountUpdateStatus(bool offline, Callback<bool > callBack, qint32 timeout) {
    if(!mApi) {
        bool result = 0;
        if(callBack)
            callBack(0, result, apiError());
        return 0;
    }
    qint64 msgId = mApi->accountUpdateStatus(offline);
    if(msgId) {
        callBackPush<bool >(msgId, callBack);
        startTimeOut(msgId, timeout);
        mRecallArgs[msgId][""] = "accountUpdateStatus";
        mRecallArgs[msgId]["offline"] = QVariant::fromValue<bool>(offline);
    } else {
        bool result = 0;
        if(callBack)
            callBack(0, result, apiError());
    }
    return msgId;
}

void TelegramCore::onAccountUpdateStatusAnswer(qint64 msgId, bool result, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mRecallArgs.remove(msgId);
    callBackCall<bool >(msgId, result);
    stopTimeOut(msgId);
    Q_EMIT accountUpdateStatusAnswer(msgId, result);
}

void TelegramCore::onAccountUpdateStatusError(qint64 msgId, qint32 errorCode, const QString &errorText, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mRecallArgs.remove(msgId);
    bool result = 0;
    CallbackError error;
    error.errorCode = errorCode;
    error.errorText = errorText;
    error.null = false;
    callBackCall<bool >(msgId, result, error);
    stopTimeOut(msgId);
    Q_EMIT accountUpdateStatusError(msgId, errorCode, errorText);
}

qint64 TelegramCore::accountGetWallPapers(Callback<QList<WallPaper> > callBack, qint32 timeout) {
    if(!mApi) {
        const QList<WallPaper> &result = QList<WallPaper>();
        if(callBack)
            callBack(0, result, apiError());
        return 0;
    }
    qint64 msgId = mApi->accountGetWallPapers();
    if(msgId) {
        callBackPush<QList<WallPaper> >(msgId, callBack);
        startTimeOut(msgId, timeout);
        mRecallArgs[msgId][""] = "accountGetWallPapers";
    } else {
        const QList<WallPaper> &result = QList<WallPaper>();
        if(callBack)
            callBack(0, result, apiError());
    }
    return msgId;
}

void TelegramCore::onAccountGetWallPapersAnswer(qint64 msgId, const QList<WallPaper> &result, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mRecallArgs.remove(msgId);
    callBackCall<QList<WallPaper> >(msgId, result);
    stopTimeOut(msgId);
    Q_EMIT accountGetWallPapersAnswer(msgId, result);
}

void TelegramCore::onAccountGetWallPapersError(qint64 msgId, qint32 errorCode, const QString &errorText, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mRecallArgs.remove(msgId);
    const QList<WallPaper> &result = QList<WallPaper>();
    CallbackError error;
    error.errorCode = errorCode;
    error.errorText = errorText;
    error.null = false;
    callBackCall<QList<WallPaper> >(msgId, result, error);
    stopTimeOut(msgId);
    Q_EMIT accountGetWallPapersError(msgId, errorCode, errorText);
}

qint64 TelegramCore::accountReportPeer(const InputPeer &peer, const ReportReason &reason, Callback<bool > callBack, qint32 timeout) {
    if(!mApi) {
        bool result = 0;
        if(callBack)
            callBack(0, result, apiError());
        return 0;
    }
    qint64 msgId = mApi->accountReportPeer(peer, reason);
    if(msgId) {
        callBackPush<bool >(msgId, callBack);
        startTimeOut(msgId, timeout);
        mRecallArgs[msgId][""] = "accountReportPeer";
        mRecallArgs[msgId]["peer"] = QVariant::fromValue<InputPeer>(peer);
        mRecallArgs[msgId]["reason"] = QVariant::fromValue<ReportReason>(reason);
    } else {
        bool result = 0;
        if(callBack)
            callBack(0, result, apiError());
    }
    return msgId;
}

void TelegramCore::onAccountReportPeerAnswer(qint64 msgId, bool result, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mRecallArgs.remove(msgId);
    callBackCall<bool >(msgId, result);
    stopTimeOut(msgId);
    Q_EMIT accountReportPeerAnswer(msgId, result);
}

void TelegramCore::onAccountReportPeerError(qint64 msgId, qint32 errorCode, const QString &errorText, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mRecallArgs.remove(msgId);
    bool result = 0;
    CallbackError error;
    error.errorCode = errorCode;
    error.errorText = errorText;
    error.null = false;
    callBackCall<bool >(msgId, result, error);
    stopTimeOut(msgId);
    Q_EMIT accountReportPeerError(msgId, errorCode, errorText);
}

qint64 TelegramCore::accountCheckUsername(const QString &username, Callback<bool > callBack, qint32 timeout) {
    if(!mApi) {
        bool result = 0;
        if(callBack)
            callBack(0, result, apiError());
        return 0;
    }
    qint64 msgId = mApi->accountCheckUsername(username);
    if(msgId) {
        callBackPush<bool >(msgId, callBack);
        startTimeOut(msgId, timeout);
        mRecallArgs[msgId][""] = "accountCheckUsername";
        mRecallArgs[msgId]["username"] = QVariant::fromValue<QString>(username);
    } else {
        bool result = 0;
        if(callBack)
            callBack(0, result, apiError());
    }
    return msgId;
}

void TelegramCore::onAccountCheckUsernameAnswer(qint64 msgId, bool result, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mRecallArgs.remove(msgId);
    callBackCall<bool >(msgId, result);
    stopTimeOut(msgId);
    Q_EMIT accountCheckUsernameAnswer(msgId, result);
}

void TelegramCore::onAccountCheckUsernameError(qint64 msgId, qint32 errorCode, const QString &errorText, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mRecallArgs.remove(msgId);
    bool result = 0;
    CallbackError error;
    error.errorCode = errorCode;
    error.errorText = errorText;
    error.null = false;
    callBackCall<bool >(msgId, result, error);
    stopTimeOut(msgId);
    Q_EMIT accountCheckUsernameError(msgId, errorCode, errorText);
}

qint64 TelegramCore::accountUpdateUsername(const QString &username, Callback<User > callBack, qint32 timeout) {
    if(!mApi) {
        const User &result = User();
        if(callBack)
            callBack(0, result, apiError());
        return 0;
    }
    qint64 msgId = mApi->accountUpdateUsername(username);
    if(msgId) {
        callBackPush<User >(msgId, callBack);
        startTimeOut(msgId, timeout);
        mRecallArgs[msgId][""] = "accountUpdateUsername";
        mRecallArgs[msgId]["username"] = QVariant::fromValue<QString>(username);
    } else {
        const User &result = User();
        if(callBack)
            callBack(0, result, apiError());
    }
    return msgId;
}

void TelegramCore::onAccountUpdateUsernameAnswer(qint64 msgId, const User &result, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mRecallArgs.remove(msgId);
    callBackCall<User >(msgId, result);
    stopTimeOut(msgId);
    Q_EMIT accountUpdateUsernameAnswer(msgId, result);
}

void TelegramCore::onAccountUpdateUsernameError(qint64 msgId, qint32 errorCode, const QString &errorText, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mRecallArgs.remove(msgId);
    const User &result = User();
    CallbackError error;
    error.errorCode = errorCode;
    error.errorText = errorText;
    error.null = false;
    callBackCall<User >(msgId, result, error);
    stopTimeOut(msgId);
    Q_EMIT accountUpdateUsernameError(msgId, errorCode, errorText);
}

qint64 TelegramCore::accountGetPrivacy(const InputPrivacyKey &key, Callback<AccountPrivacyRules > callBack, qint32 timeout) {
    if(!mApi) {
        const AccountPrivacyRules &result = AccountPrivacyRules();
        if(callBack)
            callBack(0, result, apiError());
        return 0;
    }
    qint64 msgId = mApi->accountGetPrivacy(key);
    if(msgId) {
        callBackPush<AccountPrivacyRules >(msgId, callBack);
        startTimeOut(msgId, timeout);
        mRecallArgs[msgId][""] = "accountGetPrivacy";
        mRecallArgs[msgId]["key"] = QVariant::fromValue<InputPrivacyKey>(key);
    } else {
        const AccountPrivacyRules &result = AccountPrivacyRules();
        if(callBack)
            callBack(0, result, apiError());
    }
    return msgId;
}

void TelegramCore::onAccountGetPrivacyAnswer(qint64 msgId, const AccountPrivacyRules &result, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mRecallArgs.remove(msgId);
    callBackCall<AccountPrivacyRules >(msgId, result);
    stopTimeOut(msgId);
    Q_EMIT accountGetPrivacyAnswer(msgId, result);
}

void TelegramCore::onAccountGetPrivacyError(qint64 msgId, qint32 errorCode, const QString &errorText, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mRecallArgs.remove(msgId);
    const AccountPrivacyRules &result = AccountPrivacyRules();
    CallbackError error;
    error.errorCode = errorCode;
    error.errorText = errorText;
    error.null = false;
    callBackCall<AccountPrivacyRules >(msgId, result, error);
    stopTimeOut(msgId);
    Q_EMIT accountGetPrivacyError(msgId, errorCode, errorText);
}

qint64 TelegramCore::accountSetPrivacy(const InputPrivacyKey &key, const QList<InputPrivacyRule> &rules, Callback<AccountPrivacyRules > callBack, qint32 timeout) {
    if(!mApi) {
        const AccountPrivacyRules &result = AccountPrivacyRules();
        if(callBack)
            callBack(0, result, apiError());
        return 0;
    }
    qint64 msgId = mApi->accountSetPrivacy(key, rules);
    if(msgId) {
        callBackPush<AccountPrivacyRules >(msgId, callBack);
        startTimeOut(msgId, timeout);
        mRecallArgs[msgId][""] = "accountSetPrivacy";
        mRecallArgs[msgId]["key"] = QVariant::fromValue<InputPrivacyKey>(key);
        mRecallArgs[msgId]["rules"] = QVariant::fromValue<QList<InputPrivacyRule>>(rules);
    } else {
        const AccountPrivacyRules &result = AccountPrivacyRules();
        if(callBack)
            callBack(0, result, apiError());
    }
    return msgId;
}

void TelegramCore::onAccountSetPrivacyAnswer(qint64 msgId, const AccountPrivacyRules &result, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mRecallArgs.remove(msgId);
    callBackCall<AccountPrivacyRules >(msgId, result);
    stopTimeOut(msgId);
    Q_EMIT accountSetPrivacyAnswer(msgId, result);
}

void TelegramCore::onAccountSetPrivacyError(qint64 msgId, qint32 errorCode, const QString &errorText, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mRecallArgs.remove(msgId);
    const AccountPrivacyRules &result = AccountPrivacyRules();
    CallbackError error;
    error.errorCode = errorCode;
    error.errorText = errorText;
    error.null = false;
    callBackCall<AccountPrivacyRules >(msgId, result, error);
    stopTimeOut(msgId);
    Q_EMIT accountSetPrivacyError(msgId, errorCode, errorText);
}

qint64 TelegramCore::accountDeleteAccount(const QString &reason, Callback<bool > callBack, qint32 timeout) {
    if(!mApi) {
        bool result = 0;
        if(callBack)
            callBack(0, result, apiError());
        return 0;
    }
    qint64 msgId = mApi->accountDeleteAccount(reason);
    if(msgId) {
        callBackPush<bool >(msgId, callBack);
        startTimeOut(msgId, timeout);
        mRecallArgs[msgId][""] = "accountDeleteAccount";
        mRecallArgs[msgId]["reason"] = QVariant::fromValue<QString>(reason);
    } else {
        bool result = 0;
        if(callBack)
            callBack(0, result, apiError());
    }
    return msgId;
}

void TelegramCore::onAccountDeleteAccountAnswer(qint64 msgId, bool result, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mRecallArgs.remove(msgId);
    callBackCall<bool >(msgId, result);
    stopTimeOut(msgId);
    Q_EMIT accountDeleteAccountAnswer(msgId, result);
}

void TelegramCore::onAccountDeleteAccountError(qint64 msgId, qint32 errorCode, const QString &errorText, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mRecallArgs.remove(msgId);
    bool result = 0;
    CallbackError error;
    error.errorCode = errorCode;
    error.errorText = errorText;
    error.null = false;
    callBackCall<bool >(msgId, result, error);
    stopTimeOut(msgId);
    Q_EMIT accountDeleteAccountError(msgId, errorCode, errorText);
}

qint64 TelegramCore::accountGetAccountTTL(Callback<AccountDaysTTL > callBack, qint32 timeout) {
    if(!mApi) {
        const AccountDaysTTL &result = AccountDaysTTL();
        if(callBack)
            callBack(0, result, apiError());
        return 0;
    }
    qint64 msgId = mApi->accountGetAccountTTL();
    if(msgId) {
        callBackPush<AccountDaysTTL >(msgId, callBack);
        startTimeOut(msgId, timeout);
        mRecallArgs[msgId][""] = "accountGetAccountTTL";
    } else {
        const AccountDaysTTL &result = AccountDaysTTL();
        if(callBack)
            callBack(0, result, apiError());
    }
    return msgId;
}

void TelegramCore::onAccountGetAccountTTLAnswer(qint64 msgId, const AccountDaysTTL &result, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mRecallArgs.remove(msgId);
    callBackCall<AccountDaysTTL >(msgId, result);
    stopTimeOut(msgId);
    Q_EMIT accountGetAccountTTLAnswer(msgId, result);
}

void TelegramCore::onAccountGetAccountTTLError(qint64 msgId, qint32 errorCode, const QString &errorText, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mRecallArgs.remove(msgId);
    const AccountDaysTTL &result = AccountDaysTTL();
    CallbackError error;
    error.errorCode = errorCode;
    error.errorText = errorText;
    error.null = false;
    callBackCall<AccountDaysTTL >(msgId, result, error);
    stopTimeOut(msgId);
    Q_EMIT accountGetAccountTTLError(msgId, errorCode, errorText);
}

qint64 TelegramCore::accountSetAccountTTL(const AccountDaysTTL &ttl, Callback<bool > callBack, qint32 timeout) {
    if(!mApi) {
        bool result = 0;
        if(callBack)
            callBack(0, result, apiError());
        return 0;
    }
    qint64 msgId = mApi->accountSetAccountTTL(ttl);
    if(msgId) {
        callBackPush<bool >(msgId, callBack);
        startTimeOut(msgId, timeout);
        mRecallArgs[msgId][""] = "accountSetAccountTTL";
        mRecallArgs[msgId]["ttl"] = QVariant::fromValue<AccountDaysTTL>(ttl);
    } else {
        bool result = 0;
        if(callBack)
            callBack(0, result, apiError());
    }
    return msgId;
}

void TelegramCore::onAccountSetAccountTTLAnswer(qint64 msgId, bool result, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mRecallArgs.remove(msgId);
    callBackCall<bool >(msgId, result);
    stopTimeOut(msgId);
    Q_EMIT accountSetAccountTTLAnswer(msgId, result);
}

void TelegramCore::onAccountSetAccountTTLError(qint64 msgId, qint32 errorCode, const QString &errorText, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mRecallArgs.remove(msgId);
    bool result = 0;
    CallbackError error;
    error.errorCode = errorCode;
    error.errorText = errorText;
    error.null = false;
    callBackCall<bool >(msgId, result, error);
    stopTimeOut(msgId);
    Q_EMIT accountSetAccountTTLError(msgId, errorCode, errorText);
}

qint64 TelegramCore::accountSendChangePhoneCode(const QString &phone_number, Callback<AccountSentChangePhoneCode > callBack, qint32 timeout) {
    if(!mApi) {
        const AccountSentChangePhoneCode &result = AccountSentChangePhoneCode();
        if(callBack)
            callBack(0, result, apiError());
        return 0;
    }
    qint64 msgId = mApi->accountSendChangePhoneCode(phone_number);
    if(msgId) {
        callBackPush<AccountSentChangePhoneCode >(msgId, callBack);
        startTimeOut(msgId, timeout);
        mRecallArgs[msgId][""] = "accountSendChangePhoneCode";
        mRecallArgs[msgId]["phone_number"] = QVariant::fromValue<QString>(phone_number);
    } else {
        const AccountSentChangePhoneCode &result = AccountSentChangePhoneCode();
        if(callBack)
            callBack(0, result, apiError());
    }
    return msgId;
}

void TelegramCore::onAccountSendChangePhoneCodeAnswer(qint64 msgId, const AccountSentChangePhoneCode &result, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mRecallArgs.remove(msgId);
    callBackCall<AccountSentChangePhoneCode >(msgId, result);
    stopTimeOut(msgId);
    Q_EMIT accountSendChangePhoneCodeAnswer(msgId, result);
}

void TelegramCore::onAccountSendChangePhoneCodeError(qint64 msgId, qint32 errorCode, const QString &errorText, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mRecallArgs.remove(msgId);
    const AccountSentChangePhoneCode &result = AccountSentChangePhoneCode();
    CallbackError error;
    error.errorCode = errorCode;
    error.errorText = errorText;
    error.null = false;
    callBackCall<AccountSentChangePhoneCode >(msgId, result, error);
    stopTimeOut(msgId);
    Q_EMIT accountSendChangePhoneCodeError(msgId, errorCode, errorText);
}

qint64 TelegramCore::accountChangePhone(const QString &phone_number, const QString &phone_code_hash, const QString &phone_code, Callback<User > callBack, qint32 timeout) {
    if(!mApi) {
        const User &result = User();
        if(callBack)
            callBack(0, result, apiError());
        return 0;
    }
    qint64 msgId = mApi->accountChangePhone(phone_number, phone_code_hash, phone_code);
    if(msgId) {
        callBackPush<User >(msgId, callBack);
        startTimeOut(msgId, timeout);
        mRecallArgs[msgId][""] = "accountChangePhone";
        mRecallArgs[msgId]["phone_number"] = QVariant::fromValue<QString>(phone_number);
        mRecallArgs[msgId]["phone_code_hash"] = QVariant::fromValue<QString>(phone_code_hash);
        mRecallArgs[msgId]["phone_code"] = QVariant::fromValue<QString>(phone_code);
    } else {
        const User &result = User();
        if(callBack)
            callBack(0, result, apiError());
    }
    return msgId;
}

void TelegramCore::onAccountChangePhoneAnswer(qint64 msgId, const User &result, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mRecallArgs.remove(msgId);
    callBackCall<User >(msgId, result);
    stopTimeOut(msgId);
    Q_EMIT accountChangePhoneAnswer(msgId, result);
}

void TelegramCore::onAccountChangePhoneError(qint64 msgId, qint32 errorCode, const QString &errorText, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mRecallArgs.remove(msgId);
    const User &result = User();
    CallbackError error;
    error.errorCode = errorCode;
    error.errorText = errorText;
    error.null = false;
    callBackCall<User >(msgId, result, error);
    stopTimeOut(msgId);
    Q_EMIT accountChangePhoneError(msgId, errorCode, errorText);
}

qint64 TelegramCore::accountUpdateDeviceLocked(qint32 period, Callback<bool > callBack, qint32 timeout) {
    if(!mApi) {
        bool result = 0;
        if(callBack)
            callBack(0, result, apiError());
        return 0;
    }
    qint64 msgId = mApi->accountUpdateDeviceLocked(period);
    if(msgId) {
        callBackPush<bool >(msgId, callBack);
        startTimeOut(msgId, timeout);
        mRecallArgs[msgId][""] = "accountUpdateDeviceLocked";
        mRecallArgs[msgId]["period"] = QVariant::fromValue<qint32>(period);
    } else {
        bool result = 0;
        if(callBack)
            callBack(0, result, apiError());
    }
    return msgId;
}

void TelegramCore::onAccountUpdateDeviceLockedAnswer(qint64 msgId, bool result, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mRecallArgs.remove(msgId);
    callBackCall<bool >(msgId, result);
    stopTimeOut(msgId);
    Q_EMIT accountUpdateDeviceLockedAnswer(msgId, result);
}

void TelegramCore::onAccountUpdateDeviceLockedError(qint64 msgId, qint32 errorCode, const QString &errorText, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mRecallArgs.remove(msgId);
    bool result = 0;
    CallbackError error;
    error.errorCode = errorCode;
    error.errorText = errorText;
    error.null = false;
    callBackCall<bool >(msgId, result, error);
    stopTimeOut(msgId);
    Q_EMIT accountUpdateDeviceLockedError(msgId, errorCode, errorText);
}

qint64 TelegramCore::accountGetAuthorizations(Callback<AccountAuthorizations > callBack, qint32 timeout) {
    if(!mApi) {
        const AccountAuthorizations &result = AccountAuthorizations();
        if(callBack)
            callBack(0, result, apiError());
        return 0;
    }
    qint64 msgId = mApi->accountGetAuthorizations();
    if(msgId) {
        callBackPush<AccountAuthorizations >(msgId, callBack);
        startTimeOut(msgId, timeout);
        mRecallArgs[msgId][""] = "accountGetAuthorizations";
    } else {
        const AccountAuthorizations &result = AccountAuthorizations();
        if(callBack)
            callBack(0, result, apiError());
    }
    return msgId;
}

void TelegramCore::onAccountGetAuthorizationsAnswer(qint64 msgId, const AccountAuthorizations &result, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mRecallArgs.remove(msgId);
    callBackCall<AccountAuthorizations >(msgId, result);
    stopTimeOut(msgId);
    Q_EMIT accountGetAuthorizationsAnswer(msgId, result);
}

void TelegramCore::onAccountGetAuthorizationsError(qint64 msgId, qint32 errorCode, const QString &errorText, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mRecallArgs.remove(msgId);
    const AccountAuthorizations &result = AccountAuthorizations();
    CallbackError error;
    error.errorCode = errorCode;
    error.errorText = errorText;
    error.null = false;
    callBackCall<AccountAuthorizations >(msgId, result, error);
    stopTimeOut(msgId);
    Q_EMIT accountGetAuthorizationsError(msgId, errorCode, errorText);
}

qint64 TelegramCore::accountResetAuthorization(qint64 hash, Callback<bool > callBack, qint32 timeout) {
    if(!mApi) {
        bool result = 0;
        if(callBack)
            callBack(0, result, apiError());
        return 0;
    }
    qint64 msgId = mApi->accountResetAuthorization(hash);
    if(msgId) {
        callBackPush<bool >(msgId, callBack);
        startTimeOut(msgId, timeout);
        mRecallArgs[msgId][""] = "accountResetAuthorization";
        mRecallArgs[msgId]["hash"] = QVariant::fromValue<qint64>(hash);
    } else {
        bool result = 0;
        if(callBack)
            callBack(0, result, apiError());
    }
    return msgId;
}

void TelegramCore::onAccountResetAuthorizationAnswer(qint64 msgId, bool result, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mRecallArgs.remove(msgId);
    callBackCall<bool >(msgId, result);
    stopTimeOut(msgId);
    Q_EMIT accountResetAuthorizationAnswer(msgId, result);
}

void TelegramCore::onAccountResetAuthorizationError(qint64 msgId, qint32 errorCode, const QString &errorText, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mRecallArgs.remove(msgId);
    bool result = 0;
    CallbackError error;
    error.errorCode = errorCode;
    error.errorText = errorText;
    error.null = false;
    callBackCall<bool >(msgId, result, error);
    stopTimeOut(msgId);
    Q_EMIT accountResetAuthorizationError(msgId, errorCode, errorText);
}

qint64 TelegramCore::accountGetPassword(Callback<AccountPassword > callBack, qint32 timeout) {
    if(!mApi) {
        const AccountPassword &result = AccountPassword();
        if(callBack)
            callBack(0, result, apiError());
        return 0;
    }
    qint64 msgId = mApi->accountGetPassword();
    if(msgId) {
        callBackPush<AccountPassword >(msgId, callBack);
        startTimeOut(msgId, timeout);
        mRecallArgs[msgId][""] = "accountGetPassword";
    } else {
        const AccountPassword &result = AccountPassword();
        if(callBack)
            callBack(0, result, apiError());
    }
    return msgId;
}

void TelegramCore::onAccountGetPasswordAnswer(qint64 msgId, const AccountPassword &result, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mRecallArgs.remove(msgId);
    callBackCall<AccountPassword >(msgId, result);
    stopTimeOut(msgId);
    Q_EMIT accountGetPasswordAnswer(msgId, result);
}

void TelegramCore::onAccountGetPasswordError(qint64 msgId, qint32 errorCode, const QString &errorText, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mRecallArgs.remove(msgId);
    const AccountPassword &result = AccountPassword();
    CallbackError error;
    error.errorCode = errorCode;
    error.errorText = errorText;
    error.null = false;
    callBackCall<AccountPassword >(msgId, result, error);
    stopTimeOut(msgId);
    Q_EMIT accountGetPasswordError(msgId, errorCode, errorText);
}

qint64 TelegramCore::accountGetPasswordSettings(const QByteArray &current_password_hash, Callback<AccountPasswordSettings > callBack, qint32 timeout) {
    if(!mApi) {
        const AccountPasswordSettings &result = AccountPasswordSettings();
        if(callBack)
            callBack(0, result, apiError());
        return 0;
    }
    qint64 msgId = mApi->accountGetPasswordSettings(current_password_hash);
    if(msgId) {
        callBackPush<AccountPasswordSettings >(msgId, callBack);
        startTimeOut(msgId, timeout);
        mRecallArgs[msgId][""] = "accountGetPasswordSettings";
        mRecallArgs[msgId]["current_password_hash"] = QVariant::fromValue<QByteArray>(current_password_hash);
    } else {
        const AccountPasswordSettings &result = AccountPasswordSettings();
        if(callBack)
            callBack(0, result, apiError());
    }
    return msgId;
}

void TelegramCore::onAccountGetPasswordSettingsAnswer(qint64 msgId, const AccountPasswordSettings &result, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mRecallArgs.remove(msgId);
    callBackCall<AccountPasswordSettings >(msgId, result);
    stopTimeOut(msgId);
    Q_EMIT accountGetPasswordSettingsAnswer(msgId, result);
}

void TelegramCore::onAccountGetPasswordSettingsError(qint64 msgId, qint32 errorCode, const QString &errorText, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mRecallArgs.remove(msgId);
    const AccountPasswordSettings &result = AccountPasswordSettings();
    CallbackError error;
    error.errorCode = errorCode;
    error.errorText = errorText;
    error.null = false;
    callBackCall<AccountPasswordSettings >(msgId, result, error);
    stopTimeOut(msgId);
    Q_EMIT accountGetPasswordSettingsError(msgId, errorCode, errorText);
}

qint64 TelegramCore::accountUpdatePasswordSettings(const QByteArray &current_password_hash, const AccountPasswordInputSettings &new_settings, Callback<bool > callBack, qint32 timeout) {
    if(!mApi) {
        bool result = 0;
        if(callBack)
            callBack(0, result, apiError());
        return 0;
    }
    qint64 msgId = mApi->accountUpdatePasswordSettings(current_password_hash, new_settings);
    if(msgId) {
        callBackPush<bool >(msgId, callBack);
        startTimeOut(msgId, timeout);
        mRecallArgs[msgId][""] = "accountUpdatePasswordSettings";
        mRecallArgs[msgId]["current_password_hash"] = QVariant::fromValue<QByteArray>(current_password_hash);
        mRecallArgs[msgId]["new_settings"] = QVariant::fromValue<AccountPasswordInputSettings>(new_settings);
    } else {
        bool result = 0;
        if(callBack)
            callBack(0, result, apiError());
    }
    return msgId;
}

void TelegramCore::onAccountUpdatePasswordSettingsAnswer(qint64 msgId, bool result, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mRecallArgs.remove(msgId);
    callBackCall<bool >(msgId, result);
    stopTimeOut(msgId);
    Q_EMIT accountUpdatePasswordSettingsAnswer(msgId, result);
}

void TelegramCore::onAccountUpdatePasswordSettingsError(qint64 msgId, qint32 errorCode, const QString &errorText, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mRecallArgs.remove(msgId);
    bool result = 0;
    CallbackError error;
    error.errorCode = errorCode;
    error.errorText = errorText;
    error.null = false;
    callBackCall<bool >(msgId, result, error);
    stopTimeOut(msgId);
    Q_EMIT accountUpdatePasswordSettingsError(msgId, errorCode, errorText);
}


qint64 TelegramCore::authCheckPhone(const QString &phone_number, Callback<AuthCheckedPhone > callBack, qint32 timeout) {
    if(!mApi) {
        const AuthCheckedPhone &result = AuthCheckedPhone();
        if(callBack)
            callBack(0, result, apiError());
        return 0;
    }
    qint64 msgId = mApi->authCheckPhone(phone_number);
    if(msgId) {
        callBackPush<AuthCheckedPhone >(msgId, callBack);
        startTimeOut(msgId, timeout);
        mRecallArgs[msgId][""] = "authCheckPhone";
        mRecallArgs[msgId]["phone_number"] = QVariant::fromValue<QString>(phone_number);
    } else {
        const AuthCheckedPhone &result = AuthCheckedPhone();
        if(callBack)
            callBack(0, result, apiError());
    }
    return msgId;
}

void TelegramCore::onAuthCheckPhoneAnswer(qint64 msgId, const AuthCheckedPhone &result, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mRecallArgs.remove(msgId);
    callBackCall<AuthCheckedPhone >(msgId, result);
    stopTimeOut(msgId);
    Q_EMIT authCheckPhoneAnswer(msgId, result);
}

void TelegramCore::onAuthCheckPhoneError(qint64 msgId, qint32 errorCode, const QString &errorText, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mRecallArgs.remove(msgId);
    const AuthCheckedPhone &result = AuthCheckedPhone();
    CallbackError error;
    error.errorCode = errorCode;
    error.errorText = errorText;
    error.null = false;
    callBackCall<AuthCheckedPhone >(msgId, result, error);
    stopTimeOut(msgId);
    Q_EMIT authCheckPhoneError(msgId, errorCode, errorText);
}

qint64 TelegramCore::authSendCode(const QString &phone_number, qint32 sms_type, qint32 api_id, const QString &api_hash, const QString &lang_code, Callback<AuthSentCode > callBack, qint32 timeout) {
    if(!mApi) {
        const AuthSentCode &result = AuthSentCode();
        if(callBack)
            callBack(0, result, apiError());
        return 0;
    }
    qint64 msgId = mApi->authSendCode(phone_number, sms_type, api_id, api_hash, lang_code);
    if(msgId) {
        callBackPush<AuthSentCode >(msgId, callBack);
        startTimeOut(msgId, timeout);
        mRecallArgs[msgId][""] = "authSendCode";
        mRecallArgs[msgId]["phone_number"] = QVariant::fromValue<QString>(phone_number);
        mRecallArgs[msgId]["sms_type"] = QVariant::fromValue<qint32>(sms_type);
        mRecallArgs[msgId]["api_id"] = QVariant::fromValue<qint32>(api_id);
        mRecallArgs[msgId]["api_hash"] = QVariant::fromValue<QString>(api_hash);
        mRecallArgs[msgId]["lang_code"] = QVariant::fromValue<QString>(lang_code);
    } else {
        const AuthSentCode &result = AuthSentCode();
        if(callBack)
            callBack(0, result, apiError());
    }
    return msgId;
}

void TelegramCore::onAuthSendCodeAnswer(qint64 msgId, const AuthSentCode &result, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mRecallArgs.remove(msgId);
    callBackCall<AuthSentCode >(msgId, result);
    stopTimeOut(msgId);
    Q_EMIT authSendCodeAnswer(msgId, result);
}

void TelegramCore::onAuthSendCodeError(qint64 msgId, qint32 errorCode, const QString &errorText, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mRecallArgs.remove(msgId);
    const AuthSentCode &result = AuthSentCode();
    CallbackError error;
    error.errorCode = errorCode;
    error.errorText = errorText;
    error.null = false;
    callBackCall<AuthSentCode >(msgId, result, error);
    stopTimeOut(msgId);
    Q_EMIT authSendCodeError(msgId, errorCode, errorText);
}

qint64 TelegramCore::authSendCall(const QString &phone_number, const QString &phone_code_hash, Callback<bool > callBack, qint32 timeout) {
    if(!mApi) {
        bool result = 0;
        if(callBack)
            callBack(0, result, apiError());
        return 0;
    }
    qint64 msgId = mApi->authSendCall(phone_number, phone_code_hash);
    if(msgId) {
        callBackPush<bool >(msgId, callBack);
        startTimeOut(msgId, timeout);
        mRecallArgs[msgId][""] = "authSendCall";
        mRecallArgs[msgId]["phone_number"] = QVariant::fromValue<QString>(phone_number);
        mRecallArgs[msgId]["phone_code_hash"] = QVariant::fromValue<QString>(phone_code_hash);
    } else {
        bool result = 0;
        if(callBack)
            callBack(0, result, apiError());
    }
    return msgId;
}

void TelegramCore::onAuthSendCallAnswer(qint64 msgId, bool result, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mRecallArgs.remove(msgId);
    callBackCall<bool >(msgId, result);
    stopTimeOut(msgId);
    Q_EMIT authSendCallAnswer(msgId, result);
}

void TelegramCore::onAuthSendCallError(qint64 msgId, qint32 errorCode, const QString &errorText, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mRecallArgs.remove(msgId);
    bool result = 0;
    CallbackError error;
    error.errorCode = errorCode;
    error.errorText = errorText;
    error.null = false;
    callBackCall<bool >(msgId, result, error);
    stopTimeOut(msgId);
    Q_EMIT authSendCallError(msgId, errorCode, errorText);
}

qint64 TelegramCore::authSignUp(const QString &phone_number, const QString &phone_code_hash, const QString &phone_code, const QString &first_name, const QString &last_name, Callback<AuthAuthorization > callBack, qint32 timeout) {
    if(!mApi) {
        const AuthAuthorization &result = AuthAuthorization();
        if(callBack)
            callBack(0, result, apiError());
        return 0;
    }
    qint64 msgId = mApi->authSignUp(phone_number, phone_code_hash, phone_code, first_name, last_name);
    if(msgId) {
        callBackPush<AuthAuthorization >(msgId, callBack);
        startTimeOut(msgId, timeout);
        mRecallArgs[msgId][""] = "authSignUp";
        mRecallArgs[msgId]["phone_number"] = QVariant::fromValue<QString>(phone_number);
        mRecallArgs[msgId]["phone_code_hash"] = QVariant::fromValue<QString>(phone_code_hash);
        mRecallArgs[msgId]["phone_code"] = QVariant::fromValue<QString>(phone_code);
        mRecallArgs[msgId]["first_name"] = QVariant::fromValue<QString>(first_name);
        mRecallArgs[msgId]["last_name"] = QVariant::fromValue<QString>(last_name);
    } else {
        const AuthAuthorization &result = AuthAuthorization();
        if(callBack)
            callBack(0, result, apiError());
    }
    return msgId;
}

void TelegramCore::onAuthSignUpAnswer(qint64 msgId, const AuthAuthorization &result, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mRecallArgs.remove(msgId);
    callBackCall<AuthAuthorization >(msgId, result);
    stopTimeOut(msgId);
    Q_EMIT authSignUpAnswer(msgId, result);
}

void TelegramCore::onAuthSignUpError(qint64 msgId, qint32 errorCode, const QString &errorText, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mRecallArgs.remove(msgId);
    const AuthAuthorization &result = AuthAuthorization();
    CallbackError error;
    error.errorCode = errorCode;
    error.errorText = errorText;
    error.null = false;
    callBackCall<AuthAuthorization >(msgId, result, error);
    stopTimeOut(msgId);
    Q_EMIT authSignUpError(msgId, errorCode, errorText);
}

qint64 TelegramCore::authSignIn(const QString &phone_number, const QString &phone_code_hash, const QString &phone_code, Callback<AuthAuthorization > callBack, qint32 timeout) {
    if(!mApi) {
        const AuthAuthorization &result = AuthAuthorization();
        if(callBack)
            callBack(0, result, apiError());
        return 0;
    }
    qint64 msgId = mApi->authSignIn(phone_number, phone_code_hash, phone_code);
    if(msgId) {
        callBackPush<AuthAuthorization >(msgId, callBack);
        startTimeOut(msgId, timeout);
        mRecallArgs[msgId][""] = "authSignIn";
        mRecallArgs[msgId]["phone_number"] = QVariant::fromValue<QString>(phone_number);
        mRecallArgs[msgId]["phone_code_hash"] = QVariant::fromValue<QString>(phone_code_hash);
        mRecallArgs[msgId]["phone_code"] = QVariant::fromValue<QString>(phone_code);
    } else {
        const AuthAuthorization &result = AuthAuthorization();
        if(callBack)
            callBack(0, result, apiError());
    }
    return msgId;
}

void TelegramCore::onAuthSignInAnswer(qint64 msgId, const AuthAuthorization &result, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mRecallArgs.remove(msgId);
    callBackCall<AuthAuthorization >(msgId, result);
    stopTimeOut(msgId);
    Q_EMIT authSignInAnswer(msgId, result);
}

void TelegramCore::onAuthSignInError(qint64 msgId, qint32 errorCode, const QString &errorText, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mRecallArgs.remove(msgId);
    const AuthAuthorization &result = AuthAuthorization();
    CallbackError error;
    error.errorCode = errorCode;
    error.errorText = errorText;
    error.null = false;
    callBackCall<AuthAuthorization >(msgId, result, error);
    stopTimeOut(msgId);
    Q_EMIT authSignInError(msgId, errorCode, errorText);
}

qint64 TelegramCore::authLogOut(Callback<bool > callBack, qint32 timeout) {
    if(!mApi) {
        bool result = 0;
        if(callBack)
            callBack(0, result, apiError());
        return 0;
    }
    qint64 msgId = mApi->authLogOut();
    if(msgId) {
        callBackPush<bool >(msgId, callBack);
        startTimeOut(msgId, timeout);
        mRecallArgs[msgId][""] = "authLogOut";
    } else {
        bool result = 0;
        if(callBack)
            callBack(0, result, apiError());
    }
    return msgId;
}

void TelegramCore::onAuthLogOutAnswer(qint64 msgId, bool result, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mRecallArgs.remove(msgId);
    callBackCall<bool >(msgId, result);
    stopTimeOut(msgId);
    Q_EMIT authLogOutAnswer(msgId, result);
}

void TelegramCore::onAuthLogOutError(qint64 msgId, qint32 errorCode, const QString &errorText, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mRecallArgs.remove(msgId);
    bool result = 0;
    CallbackError error;
    error.errorCode = errorCode;
    error.errorText = errorText;
    error.null = false;
    callBackCall<bool >(msgId, result, error);
    stopTimeOut(msgId);
    Q_EMIT authLogOutError(msgId, errorCode, errorText);
}

qint64 TelegramCore::authResetAuthorizations(Callback<bool > callBack, qint32 timeout) {
    if(!mApi) {
        bool result = 0;
        if(callBack)
            callBack(0, result, apiError());
        return 0;
    }
    qint64 msgId = mApi->authResetAuthorizations();
    if(msgId) {
        callBackPush<bool >(msgId, callBack);
        startTimeOut(msgId, timeout);
        mRecallArgs[msgId][""] = "authResetAuthorizations";
    } else {
        bool result = 0;
        if(callBack)
            callBack(0, result, apiError());
    }
    return msgId;
}

void TelegramCore::onAuthResetAuthorizationsAnswer(qint64 msgId, bool result, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mRecallArgs.remove(msgId);
    callBackCall<bool >(msgId, result);
    stopTimeOut(msgId);
    Q_EMIT authResetAuthorizationsAnswer(msgId, result);
}

void TelegramCore::onAuthResetAuthorizationsError(qint64 msgId, qint32 errorCode, const QString &errorText, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mRecallArgs.remove(msgId);
    bool result = 0;
    CallbackError error;
    error.errorCode = errorCode;
    error.errorText = errorText;
    error.null = false;
    callBackCall<bool >(msgId, result, error);
    stopTimeOut(msgId);
    Q_EMIT authResetAuthorizationsError(msgId, errorCode, errorText);
}

qint64 TelegramCore::authSendInvites(const QList<QString> &phone_numbers, const QString &message, Callback<bool > callBack, qint32 timeout) {
    if(!mApi) {
        bool result = 0;
        if(callBack)
            callBack(0, result, apiError());
        return 0;
    }
    qint64 msgId = mApi->authSendInvites(phone_numbers, message);
    if(msgId) {
        callBackPush<bool >(msgId, callBack);
        startTimeOut(msgId, timeout);
        mRecallArgs[msgId][""] = "authSendInvites";
        mRecallArgs[msgId]["phone_numbers"] = QVariant::fromValue<QList<QString>>(phone_numbers);
        mRecallArgs[msgId]["message"] = QVariant::fromValue<QString>(message);
    } else {
        bool result = 0;
        if(callBack)
            callBack(0, result, apiError());
    }
    return msgId;
}

void TelegramCore::onAuthSendInvitesAnswer(qint64 msgId, bool result, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mRecallArgs.remove(msgId);
    callBackCall<bool >(msgId, result);
    stopTimeOut(msgId);
    Q_EMIT authSendInvitesAnswer(msgId, result);
}

void TelegramCore::onAuthSendInvitesError(qint64 msgId, qint32 errorCode, const QString &errorText, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mRecallArgs.remove(msgId);
    bool result = 0;
    CallbackError error;
    error.errorCode = errorCode;
    error.errorText = errorText;
    error.null = false;
    callBackCall<bool >(msgId, result, error);
    stopTimeOut(msgId);
    Q_EMIT authSendInvitesError(msgId, errorCode, errorText);
}

qint64 TelegramCore::authExportAuthorization(qint32 dc_id, Callback<AuthExportedAuthorization > callBack, qint32 timeout) {
    if(!mApi) {
        const AuthExportedAuthorization &result = AuthExportedAuthorization();
        if(callBack)
            callBack(0, result, apiError());
        return 0;
    }
    qint64 msgId = mApi->authExportAuthorization(dc_id);
    if(msgId) {
        callBackPush<AuthExportedAuthorization >(msgId, callBack);
        startTimeOut(msgId, timeout);
        mRecallArgs[msgId][""] = "authExportAuthorization";
        mRecallArgs[msgId]["dc_id"] = QVariant::fromValue<qint32>(dc_id);
    } else {
        const AuthExportedAuthorization &result = AuthExportedAuthorization();
        if(callBack)
            callBack(0, result, apiError());
    }
    return msgId;
}

void TelegramCore::onAuthExportAuthorizationAnswer(qint64 msgId, const AuthExportedAuthorization &result, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mRecallArgs.remove(msgId);
    callBackCall<AuthExportedAuthorization >(msgId, result);
    stopTimeOut(msgId);
    Q_EMIT authExportAuthorizationAnswer(msgId, result);
}

void TelegramCore::onAuthExportAuthorizationError(qint64 msgId, qint32 errorCode, const QString &errorText, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mRecallArgs.remove(msgId);
    const AuthExportedAuthorization &result = AuthExportedAuthorization();
    CallbackError error;
    error.errorCode = errorCode;
    error.errorText = errorText;
    error.null = false;
    callBackCall<AuthExportedAuthorization >(msgId, result, error);
    stopTimeOut(msgId);
    Q_EMIT authExportAuthorizationError(msgId, errorCode, errorText);
}

qint64 TelegramCore::authImportAuthorization(qint32 id, const QByteArray &bytes, Callback<AuthAuthorization > callBack, qint32 timeout) {
    if(!mApi) {
        const AuthAuthorization &result = AuthAuthorization();
        if(callBack)
            callBack(0, result, apiError());
        return 0;
    }
    qint64 msgId = mApi->authImportAuthorization(id, bytes);
    if(msgId) {
        callBackPush<AuthAuthorization >(msgId, callBack);
        startTimeOut(msgId, timeout);
        mRecallArgs[msgId][""] = "authImportAuthorization";
        mRecallArgs[msgId]["id"] = QVariant::fromValue<qint32>(id);
        mRecallArgs[msgId]["bytes"] = QVariant::fromValue<QByteArray>(bytes);
    } else {
        const AuthAuthorization &result = AuthAuthorization();
        if(callBack)
            callBack(0, result, apiError());
    }
    return msgId;
}

void TelegramCore::onAuthImportAuthorizationAnswer(qint64 msgId, const AuthAuthorization &result, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mRecallArgs.remove(msgId);
    callBackCall<AuthAuthorization >(msgId, result);
    stopTimeOut(msgId);
    Q_EMIT authImportAuthorizationAnswer(msgId, result);
}

void TelegramCore::onAuthImportAuthorizationError(qint64 msgId, qint32 errorCode, const QString &errorText, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mRecallArgs.remove(msgId);
    const AuthAuthorization &result = AuthAuthorization();
    CallbackError error;
    error.errorCode = errorCode;
    error.errorText = errorText;
    error.null = false;
    callBackCall<AuthAuthorization >(msgId, result, error);
    stopTimeOut(msgId);
    Q_EMIT authImportAuthorizationError(msgId, errorCode, errorText);
}

qint64 TelegramCore::authBindTempAuthKey(qint64 perm_auth_key_id, qint64 nonce, qint32 expires_at, const QByteArray &encrypted_message, Callback<bool > callBack, qint32 timeout) {
    if(!mApi) {
        bool result = 0;
        if(callBack)
            callBack(0, result, apiError());
        return 0;
    }
    qint64 msgId = mApi->authBindTempAuthKey(perm_auth_key_id, nonce, expires_at, encrypted_message);
    if(msgId) {
        callBackPush<bool >(msgId, callBack);
        startTimeOut(msgId, timeout);
        mRecallArgs[msgId][""] = "authBindTempAuthKey";
        mRecallArgs[msgId]["perm_auth_key_id"] = QVariant::fromValue<qint64>(perm_auth_key_id);
        mRecallArgs[msgId]["nonce"] = QVariant::fromValue<qint64>(nonce);
        mRecallArgs[msgId]["expires_at"] = QVariant::fromValue<qint32>(expires_at);
        mRecallArgs[msgId]["encrypted_message"] = QVariant::fromValue<QByteArray>(encrypted_message);
    } else {
        bool result = 0;
        if(callBack)
            callBack(0, result, apiError());
    }
    return msgId;
}

void TelegramCore::onAuthBindTempAuthKeyAnswer(qint64 msgId, bool result, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mRecallArgs.remove(msgId);
    callBackCall<bool >(msgId, result);
    stopTimeOut(msgId);
    Q_EMIT authBindTempAuthKeyAnswer(msgId, result);
}

void TelegramCore::onAuthBindTempAuthKeyError(qint64 msgId, qint32 errorCode, const QString &errorText, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mRecallArgs.remove(msgId);
    bool result = 0;
    CallbackError error;
    error.errorCode = errorCode;
    error.errorText = errorText;
    error.null = false;
    callBackCall<bool >(msgId, result, error);
    stopTimeOut(msgId);
    Q_EMIT authBindTempAuthKeyError(msgId, errorCode, errorText);
}

qint64 TelegramCore::authSendSms(const QString &phone_number, const QString &phone_code_hash, Callback<bool > callBack, qint32 timeout) {
    if(!mApi) {
        bool result = 0;
        if(callBack)
            callBack(0, result, apiError());
        return 0;
    }
    qint64 msgId = mApi->authSendSms(phone_number, phone_code_hash);
    if(msgId) {
        callBackPush<bool >(msgId, callBack);
        startTimeOut(msgId, timeout);
        mRecallArgs[msgId][""] = "authSendSms";
        mRecallArgs[msgId]["phone_number"] = QVariant::fromValue<QString>(phone_number);
        mRecallArgs[msgId]["phone_code_hash"] = QVariant::fromValue<QString>(phone_code_hash);
    } else {
        bool result = 0;
        if(callBack)
            callBack(0, result, apiError());
    }
    return msgId;
}

void TelegramCore::onAuthSendSmsAnswer(qint64 msgId, bool result, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mRecallArgs.remove(msgId);
    callBackCall<bool >(msgId, result);
    stopTimeOut(msgId);
    Q_EMIT authSendSmsAnswer(msgId, result);
}

void TelegramCore::onAuthSendSmsError(qint64 msgId, qint32 errorCode, const QString &errorText, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mRecallArgs.remove(msgId);
    bool result = 0;
    CallbackError error;
    error.errorCode = errorCode;
    error.errorText = errorText;
    error.null = false;
    callBackCall<bool >(msgId, result, error);
    stopTimeOut(msgId);
    Q_EMIT authSendSmsError(msgId, errorCode, errorText);
}

qint64 TelegramCore::authImportBotAuthorization(qint32 flags, qint32 api_id, const QString &api_hash, const QString &bot_auth_token, Callback<AuthAuthorization > callBack, qint32 timeout) {
    if(!mApi) {
        const AuthAuthorization &result = AuthAuthorization();
        if(callBack)
            callBack(0, result, apiError());
        return 0;
    }
    qint64 msgId = mApi->authImportBotAuthorization(flags, api_id, api_hash, bot_auth_token);
    if(msgId) {
        callBackPush<AuthAuthorization >(msgId, callBack);
        startTimeOut(msgId, timeout);
        mRecallArgs[msgId][""] = "authImportBotAuthorization";
        mRecallArgs[msgId]["flags"] = QVariant::fromValue<qint32>(flags);
        mRecallArgs[msgId]["api_id"] = QVariant::fromValue<qint32>(api_id);
        mRecallArgs[msgId]["api_hash"] = QVariant::fromValue<QString>(api_hash);
        mRecallArgs[msgId]["bot_auth_token"] = QVariant::fromValue<QString>(bot_auth_token);
    } else {
        const AuthAuthorization &result = AuthAuthorization();
        if(callBack)
            callBack(0, result, apiError());
    }
    return msgId;
}

void TelegramCore::onAuthImportBotAuthorizationAnswer(qint64 msgId, const AuthAuthorization &result, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mRecallArgs.remove(msgId);
    callBackCall<AuthAuthorization >(msgId, result);
    stopTimeOut(msgId);
    Q_EMIT authImportBotAuthorizationAnswer(msgId, result);
}

void TelegramCore::onAuthImportBotAuthorizationError(qint64 msgId, qint32 errorCode, const QString &errorText, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mRecallArgs.remove(msgId);
    const AuthAuthorization &result = AuthAuthorization();
    CallbackError error;
    error.errorCode = errorCode;
    error.errorText = errorText;
    error.null = false;
    callBackCall<AuthAuthorization >(msgId, result, error);
    stopTimeOut(msgId);
    Q_EMIT authImportBotAuthorizationError(msgId, errorCode, errorText);
}

qint64 TelegramCore::authCheckPassword(const QByteArray &password_hash, Callback<AuthAuthorization > callBack, qint32 timeout) {
    if(!mApi) {
        const AuthAuthorization &result = AuthAuthorization();
        if(callBack)
            callBack(0, result, apiError());
        return 0;
    }
    qint64 msgId = mApi->authCheckPassword(password_hash);
    if(msgId) {
        callBackPush<AuthAuthorization >(msgId, callBack);
        startTimeOut(msgId, timeout);
        mRecallArgs[msgId][""] = "authCheckPassword";
        mRecallArgs[msgId]["password_hash"] = QVariant::fromValue<QByteArray>(password_hash);
    } else {
        const AuthAuthorization &result = AuthAuthorization();
        if(callBack)
            callBack(0, result, apiError());
    }
    return msgId;
}

void TelegramCore::onAuthCheckPasswordAnswer(qint64 msgId, const AuthAuthorization &result, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mRecallArgs.remove(msgId);
    callBackCall<AuthAuthorization >(msgId, result);
    stopTimeOut(msgId);
    Q_EMIT authCheckPasswordAnswer(msgId, result);
}

void TelegramCore::onAuthCheckPasswordError(qint64 msgId, qint32 errorCode, const QString &errorText, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mRecallArgs.remove(msgId);
    const AuthAuthorization &result = AuthAuthorization();
    CallbackError error;
    error.errorCode = errorCode;
    error.errorText = errorText;
    error.null = false;
    callBackCall<AuthAuthorization >(msgId, result, error);
    stopTimeOut(msgId);
    Q_EMIT authCheckPasswordError(msgId, errorCode, errorText);
}

qint64 TelegramCore::authRequestPasswordRecovery(Callback<AuthPasswordRecovery > callBack, qint32 timeout) {
    if(!mApi) {
        const AuthPasswordRecovery &result = AuthPasswordRecovery();
        if(callBack)
            callBack(0, result, apiError());
        return 0;
    }
    qint64 msgId = mApi->authRequestPasswordRecovery();
    if(msgId) {
        callBackPush<AuthPasswordRecovery >(msgId, callBack);
        startTimeOut(msgId, timeout);
        mRecallArgs[msgId][""] = "authRequestPasswordRecovery";
    } else {
        const AuthPasswordRecovery &result = AuthPasswordRecovery();
        if(callBack)
            callBack(0, result, apiError());
    }
    return msgId;
}

void TelegramCore::onAuthRequestPasswordRecoveryAnswer(qint64 msgId, const AuthPasswordRecovery &result, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mRecallArgs.remove(msgId);
    callBackCall<AuthPasswordRecovery >(msgId, result);
    stopTimeOut(msgId);
    Q_EMIT authRequestPasswordRecoveryAnswer(msgId, result);
}

void TelegramCore::onAuthRequestPasswordRecoveryError(qint64 msgId, qint32 errorCode, const QString &errorText, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mRecallArgs.remove(msgId);
    const AuthPasswordRecovery &result = AuthPasswordRecovery();
    CallbackError error;
    error.errorCode = errorCode;
    error.errorText = errorText;
    error.null = false;
    callBackCall<AuthPasswordRecovery >(msgId, result, error);
    stopTimeOut(msgId);
    Q_EMIT authRequestPasswordRecoveryError(msgId, errorCode, errorText);
}

qint64 TelegramCore::authRecoverPassword(const QString &code, Callback<AuthAuthorization > callBack, qint32 timeout) {
    if(!mApi) {
        const AuthAuthorization &result = AuthAuthorization();
        if(callBack)
            callBack(0, result, apiError());
        return 0;
    }
    qint64 msgId = mApi->authRecoverPassword(code);
    if(msgId) {
        callBackPush<AuthAuthorization >(msgId, callBack);
        startTimeOut(msgId, timeout);
        mRecallArgs[msgId][""] = "authRecoverPassword";
        mRecallArgs[msgId]["code"] = QVariant::fromValue<QString>(code);
    } else {
        const AuthAuthorization &result = AuthAuthorization();
        if(callBack)
            callBack(0, result, apiError());
    }
    return msgId;
}

void TelegramCore::onAuthRecoverPasswordAnswer(qint64 msgId, const AuthAuthorization &result, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mRecallArgs.remove(msgId);
    callBackCall<AuthAuthorization >(msgId, result);
    stopTimeOut(msgId);
    Q_EMIT authRecoverPasswordAnswer(msgId, result);
}

void TelegramCore::onAuthRecoverPasswordError(qint64 msgId, qint32 errorCode, const QString &errorText, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mRecallArgs.remove(msgId);
    const AuthAuthorization &result = AuthAuthorization();
    CallbackError error;
    error.errorCode = errorCode;
    error.errorText = errorText;
    error.null = false;
    callBackCall<AuthAuthorization >(msgId, result, error);
    stopTimeOut(msgId);
    Q_EMIT authRecoverPasswordError(msgId, errorCode, errorText);
}


qint64 TelegramCore::channelsGetDialogs(qint32 offset, qint32 limit, Callback<MessagesDialogs > callBack, qint32 timeout) {
    if(!mApi) {
        const MessagesDialogs &result = MessagesDialogs();
        if(callBack)
            callBack(0, result, apiError());
        return 0;
    }
    qint64 msgId = mApi->channelsGetDialogs(offset, limit);
    if(msgId) {
        callBackPush<MessagesDialogs >(msgId, callBack);
        startTimeOut(msgId, timeout);
        mRecallArgs[msgId][""] = "channelsGetDialogs";
        mRecallArgs[msgId]["offset"] = QVariant::fromValue<qint32>(offset);
        mRecallArgs[msgId]["limit"] = QVariant::fromValue<qint32>(limit);
    } else {
        const MessagesDialogs &result = MessagesDialogs();
        if(callBack)
            callBack(0, result, apiError());
    }
    return msgId;
}

void TelegramCore::onChannelsGetDialogsAnswer(qint64 msgId, const MessagesDialogs &result, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mRecallArgs.remove(msgId);
    callBackCall<MessagesDialogs >(msgId, result);
    stopTimeOut(msgId);
    Q_EMIT channelsGetDialogsAnswer(msgId, result);
}

void TelegramCore::onChannelsGetDialogsError(qint64 msgId, qint32 errorCode, const QString &errorText, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mRecallArgs.remove(msgId);
    const MessagesDialogs &result = MessagesDialogs();
    CallbackError error;
    error.errorCode = errorCode;
    error.errorText = errorText;
    error.null = false;
    callBackCall<MessagesDialogs >(msgId, result, error);
    stopTimeOut(msgId);
    Q_EMIT channelsGetDialogsError(msgId, errorCode, errorText);
}

qint64 TelegramCore::channelsGetImportantHistory(const InputChannel &channel, qint32 offset_id, qint32 add_offset, qint32 limit, qint32 max_id, qint32 min_id, Callback<MessagesMessages > callBack, qint32 timeout) {
    if(!mApi) {
        const MessagesMessages &result = MessagesMessages();
        if(callBack)
            callBack(0, result, apiError());
        return 0;
    }
    qint64 msgId = mApi->channelsGetImportantHistory(channel, offset_id, add_offset, limit, max_id, min_id);
    if(msgId) {
        callBackPush<MessagesMessages >(msgId, callBack);
        startTimeOut(msgId, timeout);
        mRecallArgs[msgId][""] = "channelsGetImportantHistory";
        mRecallArgs[msgId]["channel"] = QVariant::fromValue<InputChannel>(channel);
        mRecallArgs[msgId]["offset_id"] = QVariant::fromValue<qint32>(offset_id);
        mRecallArgs[msgId]["add_offset"] = QVariant::fromValue<qint32>(add_offset);
        mRecallArgs[msgId]["limit"] = QVariant::fromValue<qint32>(limit);
        mRecallArgs[msgId]["max_id"] = QVariant::fromValue<qint32>(max_id);
        mRecallArgs[msgId]["min_id"] = QVariant::fromValue<qint32>(min_id);
    } else {
        const MessagesMessages &result = MessagesMessages();
        if(callBack)
            callBack(0, result, apiError());
    }
    return msgId;
}

void TelegramCore::onChannelsGetImportantHistoryAnswer(qint64 msgId, const MessagesMessages &result, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mRecallArgs.remove(msgId);
    callBackCall<MessagesMessages >(msgId, result);
    stopTimeOut(msgId);
    Q_EMIT channelsGetImportantHistoryAnswer(msgId, result);
}

void TelegramCore::onChannelsGetImportantHistoryError(qint64 msgId, qint32 errorCode, const QString &errorText, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mRecallArgs.remove(msgId);
    const MessagesMessages &result = MessagesMessages();
    CallbackError error;
    error.errorCode = errorCode;
    error.errorText = errorText;
    error.null = false;
    callBackCall<MessagesMessages >(msgId, result, error);
    stopTimeOut(msgId);
    Q_EMIT channelsGetImportantHistoryError(msgId, errorCode, errorText);
}

qint64 TelegramCore::channelsReadHistory(const InputChannel &channel, qint32 max_id, Callback<bool > callBack, qint32 timeout) {
    if(!mApi) {
        bool result = 0;
        if(callBack)
            callBack(0, result, apiError());
        return 0;
    }
    qint64 msgId = mApi->channelsReadHistory(channel, max_id);
    if(msgId) {
        callBackPush<bool >(msgId, callBack);
        startTimeOut(msgId, timeout);
        mRecallArgs[msgId][""] = "channelsReadHistory";
        mRecallArgs[msgId]["channel"] = QVariant::fromValue<InputChannel>(channel);
        mRecallArgs[msgId]["max_id"] = QVariant::fromValue<qint32>(max_id);
    } else {
        bool result = 0;
        if(callBack)
            callBack(0, result, apiError());
    }
    return msgId;
}

void TelegramCore::onChannelsReadHistoryAnswer(qint64 msgId, bool result, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mRecallArgs.remove(msgId);
    callBackCall<bool >(msgId, result);
    stopTimeOut(msgId);
    Q_EMIT channelsReadHistoryAnswer(msgId, result);
}

void TelegramCore::onChannelsReadHistoryError(qint64 msgId, qint32 errorCode, const QString &errorText, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mRecallArgs.remove(msgId);
    bool result = 0;
    CallbackError error;
    error.errorCode = errorCode;
    error.errorText = errorText;
    error.null = false;
    callBackCall<bool >(msgId, result, error);
    stopTimeOut(msgId);
    Q_EMIT channelsReadHistoryError(msgId, errorCode, errorText);
}

qint64 TelegramCore::channelsDeleteMessages(const InputChannel &channel, const QList<qint32> &id, Callback<MessagesAffectedMessages > callBack, qint32 timeout) {
    if(!mApi) {
        const MessagesAffectedMessages &result = MessagesAffectedMessages();
        if(callBack)
            callBack(0, result, apiError());
        return 0;
    }
    qint64 msgId = mApi->channelsDeleteMessages(channel, id);
    if(msgId) {
        callBackPush<MessagesAffectedMessages >(msgId, callBack);
        startTimeOut(msgId, timeout);
        mRecallArgs[msgId][""] = "channelsDeleteMessages";
        mRecallArgs[msgId]["channel"] = QVariant::fromValue<InputChannel>(channel);
        mRecallArgs[msgId]["id"] = QVariant::fromValue<QList<qint32>>(id);
    } else {
        const MessagesAffectedMessages &result = MessagesAffectedMessages();
        if(callBack)
            callBack(0, result, apiError());
    }
    return msgId;
}

void TelegramCore::onChannelsDeleteMessagesAnswer(qint64 msgId, const MessagesAffectedMessages &result, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mRecallArgs.remove(msgId);
    callBackCall<MessagesAffectedMessages >(msgId, result);
    stopTimeOut(msgId);
    Q_EMIT channelsDeleteMessagesAnswer(msgId, result);
}

void TelegramCore::onChannelsDeleteMessagesError(qint64 msgId, qint32 errorCode, const QString &errorText, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mRecallArgs.remove(msgId);
    const MessagesAffectedMessages &result = MessagesAffectedMessages();
    CallbackError error;
    error.errorCode = errorCode;
    error.errorText = errorText;
    error.null = false;
    callBackCall<MessagesAffectedMessages >(msgId, result, error);
    stopTimeOut(msgId);
    Q_EMIT channelsDeleteMessagesError(msgId, errorCode, errorText);
}

qint64 TelegramCore::channelsDeleteUserHistory(const InputChannel &channel, const InputUser &user_id, Callback<MessagesAffectedHistory > callBack, qint32 timeout) {
    if(!mApi) {
        const MessagesAffectedHistory &result = MessagesAffectedHistory();
        if(callBack)
            callBack(0, result, apiError());
        return 0;
    }
    qint64 msgId = mApi->channelsDeleteUserHistory(channel, user_id);
    if(msgId) {
        callBackPush<MessagesAffectedHistory >(msgId, callBack);
        startTimeOut(msgId, timeout);
        mRecallArgs[msgId][""] = "channelsDeleteUserHistory";
        mRecallArgs[msgId]["channel"] = QVariant::fromValue<InputChannel>(channel);
        mRecallArgs[msgId]["user_id"] = QVariant::fromValue<InputUser>(user_id);
    } else {
        const MessagesAffectedHistory &result = MessagesAffectedHistory();
        if(callBack)
            callBack(0, result, apiError());
    }
    return msgId;
}

void TelegramCore::onChannelsDeleteUserHistoryAnswer(qint64 msgId, const MessagesAffectedHistory &result, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mRecallArgs.remove(msgId);
    callBackCall<MessagesAffectedHistory >(msgId, result);
    stopTimeOut(msgId);
    Q_EMIT channelsDeleteUserHistoryAnswer(msgId, result);
}

void TelegramCore::onChannelsDeleteUserHistoryError(qint64 msgId, qint32 errorCode, const QString &errorText, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mRecallArgs.remove(msgId);
    const MessagesAffectedHistory &result = MessagesAffectedHistory();
    CallbackError error;
    error.errorCode = errorCode;
    error.errorText = errorText;
    error.null = false;
    callBackCall<MessagesAffectedHistory >(msgId, result, error);
    stopTimeOut(msgId);
    Q_EMIT channelsDeleteUserHistoryError(msgId, errorCode, errorText);
}

qint64 TelegramCore::channelsReportSpam(const InputChannel &channel, const InputUser &user_id, const QList<qint32> &id, Callback<bool > callBack, qint32 timeout) {
    if(!mApi) {
        bool result = 0;
        if(callBack)
            callBack(0, result, apiError());
        return 0;
    }
    qint64 msgId = mApi->channelsReportSpam(channel, user_id, id);
    if(msgId) {
        callBackPush<bool >(msgId, callBack);
        startTimeOut(msgId, timeout);
        mRecallArgs[msgId][""] = "channelsReportSpam";
        mRecallArgs[msgId]["channel"] = QVariant::fromValue<InputChannel>(channel);
        mRecallArgs[msgId]["user_id"] = QVariant::fromValue<InputUser>(user_id);
        mRecallArgs[msgId]["id"] = QVariant::fromValue<QList<qint32>>(id);
    } else {
        bool result = 0;
        if(callBack)
            callBack(0, result, apiError());
    }
    return msgId;
}

void TelegramCore::onChannelsReportSpamAnswer(qint64 msgId, bool result, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mRecallArgs.remove(msgId);
    callBackCall<bool >(msgId, result);
    stopTimeOut(msgId);
    Q_EMIT channelsReportSpamAnswer(msgId, result);
}

void TelegramCore::onChannelsReportSpamError(qint64 msgId, qint32 errorCode, const QString &errorText, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mRecallArgs.remove(msgId);
    bool result = 0;
    CallbackError error;
    error.errorCode = errorCode;
    error.errorText = errorText;
    error.null = false;
    callBackCall<bool >(msgId, result, error);
    stopTimeOut(msgId);
    Q_EMIT channelsReportSpamError(msgId, errorCode, errorText);
}

qint64 TelegramCore::channelsGetMessages(const InputChannel &channel, const QList<qint32> &id, Callback<MessagesMessages > callBack, qint32 timeout) {
    if(!mApi) {
        const MessagesMessages &result = MessagesMessages();
        if(callBack)
            callBack(0, result, apiError());
        return 0;
    }
    qint64 msgId = mApi->channelsGetMessages(channel, id);
    if(msgId) {
        callBackPush<MessagesMessages >(msgId, callBack);
        startTimeOut(msgId, timeout);
        mRecallArgs[msgId][""] = "channelsGetMessages";
        mRecallArgs[msgId]["channel"] = QVariant::fromValue<InputChannel>(channel);
        mRecallArgs[msgId]["id"] = QVariant::fromValue<QList<qint32>>(id);
    } else {
        const MessagesMessages &result = MessagesMessages();
        if(callBack)
            callBack(0, result, apiError());
    }
    return msgId;
}

void TelegramCore::onChannelsGetMessagesAnswer(qint64 msgId, const MessagesMessages &result, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mRecallArgs.remove(msgId);
    callBackCall<MessagesMessages >(msgId, result);
    stopTimeOut(msgId);
    Q_EMIT channelsGetMessagesAnswer(msgId, result);
}

void TelegramCore::onChannelsGetMessagesError(qint64 msgId, qint32 errorCode, const QString &errorText, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mRecallArgs.remove(msgId);
    const MessagesMessages &result = MessagesMessages();
    CallbackError error;
    error.errorCode = errorCode;
    error.errorText = errorText;
    error.null = false;
    callBackCall<MessagesMessages >(msgId, result, error);
    stopTimeOut(msgId);
    Q_EMIT channelsGetMessagesError(msgId, errorCode, errorText);
}

qint64 TelegramCore::channelsGetParticipants(const InputChannel &channel, const ChannelParticipantsFilter &filter, qint32 offset, qint32 limit, Callback<ChannelsChannelParticipants > callBack, qint32 timeout) {
    if(!mApi) {
        const ChannelsChannelParticipants &result = ChannelsChannelParticipants();
        if(callBack)
            callBack(0, result, apiError());
        return 0;
    }
    qint64 msgId = mApi->channelsGetParticipants(channel, filter, offset, limit);
    if(msgId) {
        callBackPush<ChannelsChannelParticipants >(msgId, callBack);
        startTimeOut(msgId, timeout);
        mRecallArgs[msgId][""] = "channelsGetParticipants";
        mRecallArgs[msgId]["channel"] = QVariant::fromValue<InputChannel>(channel);
        mRecallArgs[msgId]["filter"] = QVariant::fromValue<ChannelParticipantsFilter>(filter);
        mRecallArgs[msgId]["offset"] = QVariant::fromValue<qint32>(offset);
        mRecallArgs[msgId]["limit"] = QVariant::fromValue<qint32>(limit);
    } else {
        const ChannelsChannelParticipants &result = ChannelsChannelParticipants();
        if(callBack)
            callBack(0, result, apiError());
    }
    return msgId;
}

void TelegramCore::onChannelsGetParticipantsAnswer(qint64 msgId, const ChannelsChannelParticipants &result, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mRecallArgs.remove(msgId);
    callBackCall<ChannelsChannelParticipants >(msgId, result);
    stopTimeOut(msgId);
    Q_EMIT channelsGetParticipantsAnswer(msgId, result);
}

void TelegramCore::onChannelsGetParticipantsError(qint64 msgId, qint32 errorCode, const QString &errorText, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mRecallArgs.remove(msgId);
    const ChannelsChannelParticipants &result = ChannelsChannelParticipants();
    CallbackError error;
    error.errorCode = errorCode;
    error.errorText = errorText;
    error.null = false;
    callBackCall<ChannelsChannelParticipants >(msgId, result, error);
    stopTimeOut(msgId);
    Q_EMIT channelsGetParticipantsError(msgId, errorCode, errorText);
}

qint64 TelegramCore::channelsGetParticipant(const InputChannel &channel, const InputUser &user_id, Callback<ChannelsChannelParticipant > callBack, qint32 timeout) {
    if(!mApi) {
        const ChannelsChannelParticipant &result = ChannelsChannelParticipant();
        if(callBack)
            callBack(0, result, apiError());
        return 0;
    }
    qint64 msgId = mApi->channelsGetParticipant(channel, user_id);
    if(msgId) {
        callBackPush<ChannelsChannelParticipant >(msgId, callBack);
        startTimeOut(msgId, timeout);
        mRecallArgs[msgId][""] = "channelsGetParticipant";
        mRecallArgs[msgId]["channel"] = QVariant::fromValue<InputChannel>(channel);
        mRecallArgs[msgId]["user_id"] = QVariant::fromValue<InputUser>(user_id);
    } else {
        const ChannelsChannelParticipant &result = ChannelsChannelParticipant();
        if(callBack)
            callBack(0, result, apiError());
    }
    return msgId;
}

void TelegramCore::onChannelsGetParticipantAnswer(qint64 msgId, const ChannelsChannelParticipant &result, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mRecallArgs.remove(msgId);
    callBackCall<ChannelsChannelParticipant >(msgId, result);
    stopTimeOut(msgId);
    Q_EMIT channelsGetParticipantAnswer(msgId, result);
}

void TelegramCore::onChannelsGetParticipantError(qint64 msgId, qint32 errorCode, const QString &errorText, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mRecallArgs.remove(msgId);
    const ChannelsChannelParticipant &result = ChannelsChannelParticipant();
    CallbackError error;
    error.errorCode = errorCode;
    error.errorText = errorText;
    error.null = false;
    callBackCall<ChannelsChannelParticipant >(msgId, result, error);
    stopTimeOut(msgId);
    Q_EMIT channelsGetParticipantError(msgId, errorCode, errorText);
}

qint64 TelegramCore::channelsGetChannels(const QList<InputChannel> &id, Callback<MessagesChats > callBack, qint32 timeout) {
    if(!mApi) {
        const MessagesChats &result = MessagesChats();
        if(callBack)
            callBack(0, result, apiError());
        return 0;
    }
    qint64 msgId = mApi->channelsGetChannels(id);
    if(msgId) {
        callBackPush<MessagesChats >(msgId, callBack);
        startTimeOut(msgId, timeout);
        mRecallArgs[msgId][""] = "channelsGetChannels";
        mRecallArgs[msgId]["id"] = QVariant::fromValue<QList<InputChannel>>(id);
    } else {
        const MessagesChats &result = MessagesChats();
        if(callBack)
            callBack(0, result, apiError());
    }
    return msgId;
}

void TelegramCore::onChannelsGetChannelsAnswer(qint64 msgId, const MessagesChats &result, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mRecallArgs.remove(msgId);
    callBackCall<MessagesChats >(msgId, result);
    stopTimeOut(msgId);
    Q_EMIT channelsGetChannelsAnswer(msgId, result);
}

void TelegramCore::onChannelsGetChannelsError(qint64 msgId, qint32 errorCode, const QString &errorText, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mRecallArgs.remove(msgId);
    const MessagesChats &result = MessagesChats();
    CallbackError error;
    error.errorCode = errorCode;
    error.errorText = errorText;
    error.null = false;
    callBackCall<MessagesChats >(msgId, result, error);
    stopTimeOut(msgId);
    Q_EMIT channelsGetChannelsError(msgId, errorCode, errorText);
}

qint64 TelegramCore::channelsGetFullChannel(const InputChannel &channel, Callback<MessagesChatFull > callBack, qint32 timeout) {
    if(!mApi) {
        const MessagesChatFull &result = MessagesChatFull();
        if(callBack)
            callBack(0, result, apiError());
        return 0;
    }
    qint64 msgId = mApi->channelsGetFullChannel(channel);
    if(msgId) {
        callBackPush<MessagesChatFull >(msgId, callBack);
        startTimeOut(msgId, timeout);
        mRecallArgs[msgId][""] = "channelsGetFullChannel";
        mRecallArgs[msgId]["channel"] = QVariant::fromValue<InputChannel>(channel);
    } else {
        const MessagesChatFull &result = MessagesChatFull();
        if(callBack)
            callBack(0, result, apiError());
    }
    return msgId;
}

void TelegramCore::onChannelsGetFullChannelAnswer(qint64 msgId, const MessagesChatFull &result, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mRecallArgs.remove(msgId);
    callBackCall<MessagesChatFull >(msgId, result);
    stopTimeOut(msgId);
    Q_EMIT channelsGetFullChannelAnswer(msgId, result);
}

void TelegramCore::onChannelsGetFullChannelError(qint64 msgId, qint32 errorCode, const QString &errorText, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mRecallArgs.remove(msgId);
    const MessagesChatFull &result = MessagesChatFull();
    CallbackError error;
    error.errorCode = errorCode;
    error.errorText = errorText;
    error.null = false;
    callBackCall<MessagesChatFull >(msgId, result, error);
    stopTimeOut(msgId);
    Q_EMIT channelsGetFullChannelError(msgId, errorCode, errorText);
}

qint64 TelegramCore::channelsCreateChannel(bool broadcast, bool megagroup, const QString &title, const QString &about, Callback<UpdatesType > callBack, qint32 timeout) {
    if(!mApi) {
        const UpdatesType &result = UpdatesType();
        if(callBack)
            callBack(0, result, apiError());
        return 0;
    }
    qint64 msgId = mApi->channelsCreateChannel(broadcast, megagroup, title, about);
    if(msgId) {
        callBackPush<UpdatesType >(msgId, callBack);
        startTimeOut(msgId, timeout);
        mRecallArgs[msgId][""] = "channelsCreateChannel";
        mRecallArgs[msgId]["broadcast"] = QVariant::fromValue<bool>(broadcast);
        mRecallArgs[msgId]["megagroup"] = QVariant::fromValue<bool>(megagroup);
        mRecallArgs[msgId]["title"] = QVariant::fromValue<QString>(title);
        mRecallArgs[msgId]["about"] = QVariant::fromValue<QString>(about);
    } else {
        const UpdatesType &result = UpdatesType();
        if(callBack)
            callBack(0, result, apiError());
    }
    return msgId;
}

void TelegramCore::onChannelsCreateChannelAnswer(qint64 msgId, const UpdatesType &result, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mRecallArgs.remove(msgId);
    callBackCall<UpdatesType >(msgId, result);
    stopTimeOut(msgId);
    Q_EMIT channelsCreateChannelAnswer(msgId, result);
}

void TelegramCore::onChannelsCreateChannelError(qint64 msgId, qint32 errorCode, const QString &errorText, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mRecallArgs.remove(msgId);
    const UpdatesType &result = UpdatesType();
    CallbackError error;
    error.errorCode = errorCode;
    error.errorText = errorText;
    error.null = false;
    callBackCall<UpdatesType >(msgId, result, error);
    stopTimeOut(msgId);
    Q_EMIT channelsCreateChannelError(msgId, errorCode, errorText);
}

qint64 TelegramCore::channelsEditAbout(const InputChannel &channel, const QString &about, Callback<bool > callBack, qint32 timeout) {
    if(!mApi) {
        bool result = 0;
        if(callBack)
            callBack(0, result, apiError());
        return 0;
    }
    qint64 msgId = mApi->channelsEditAbout(channel, about);
    if(msgId) {
        callBackPush<bool >(msgId, callBack);
        startTimeOut(msgId, timeout);
        mRecallArgs[msgId][""] = "channelsEditAbout";
        mRecallArgs[msgId]["channel"] = QVariant::fromValue<InputChannel>(channel);
        mRecallArgs[msgId]["about"] = QVariant::fromValue<QString>(about);
    } else {
        bool result = 0;
        if(callBack)
            callBack(0, result, apiError());
    }
    return msgId;
}

void TelegramCore::onChannelsEditAboutAnswer(qint64 msgId, bool result, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mRecallArgs.remove(msgId);
    callBackCall<bool >(msgId, result);
    stopTimeOut(msgId);
    Q_EMIT channelsEditAboutAnswer(msgId, result);
}

void TelegramCore::onChannelsEditAboutError(qint64 msgId, qint32 errorCode, const QString &errorText, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mRecallArgs.remove(msgId);
    bool result = 0;
    CallbackError error;
    error.errorCode = errorCode;
    error.errorText = errorText;
    error.null = false;
    callBackCall<bool >(msgId, result, error);
    stopTimeOut(msgId);
    Q_EMIT channelsEditAboutError(msgId, errorCode, errorText);
}

qint64 TelegramCore::channelsEditAdmin(const InputChannel &channel, const InputUser &user_id, const ChannelParticipantRole &role, Callback<UpdatesType > callBack, qint32 timeout) {
    if(!mApi) {
        const UpdatesType &result = UpdatesType();
        if(callBack)
            callBack(0, result, apiError());
        return 0;
    }
    qint64 msgId = mApi->channelsEditAdmin(channel, user_id, role);
    if(msgId) {
        callBackPush<UpdatesType >(msgId, callBack);
        startTimeOut(msgId, timeout);
        mRecallArgs[msgId][""] = "channelsEditAdmin";
        mRecallArgs[msgId]["channel"] = QVariant::fromValue<InputChannel>(channel);
        mRecallArgs[msgId]["user_id"] = QVariant::fromValue<InputUser>(user_id);
        mRecallArgs[msgId]["role"] = QVariant::fromValue<ChannelParticipantRole>(role);
    } else {
        const UpdatesType &result = UpdatesType();
        if(callBack)
            callBack(0, result, apiError());
    }
    return msgId;
}

void TelegramCore::onChannelsEditAdminAnswer(qint64 msgId, const UpdatesType &result, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mRecallArgs.remove(msgId);
    callBackCall<UpdatesType >(msgId, result);
    stopTimeOut(msgId);
    Q_EMIT channelsEditAdminAnswer(msgId, result);
}

void TelegramCore::onChannelsEditAdminError(qint64 msgId, qint32 errorCode, const QString &errorText, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mRecallArgs.remove(msgId);
    const UpdatesType &result = UpdatesType();
    CallbackError error;
    error.errorCode = errorCode;
    error.errorText = errorText;
    error.null = false;
    callBackCall<UpdatesType >(msgId, result, error);
    stopTimeOut(msgId);
    Q_EMIT channelsEditAdminError(msgId, errorCode, errorText);
}

qint64 TelegramCore::channelsEditTitle(const InputChannel &channel, const QString &title, Callback<UpdatesType > callBack, qint32 timeout) {
    if(!mApi) {
        const UpdatesType &result = UpdatesType();
        if(callBack)
            callBack(0, result, apiError());
        return 0;
    }
    qint64 msgId = mApi->channelsEditTitle(channel, title);
    if(msgId) {
        callBackPush<UpdatesType >(msgId, callBack);
        startTimeOut(msgId, timeout);
        mRecallArgs[msgId][""] = "channelsEditTitle";
        mRecallArgs[msgId]["channel"] = QVariant::fromValue<InputChannel>(channel);
        mRecallArgs[msgId]["title"] = QVariant::fromValue<QString>(title);
    } else {
        const UpdatesType &result = UpdatesType();
        if(callBack)
            callBack(0, result, apiError());
    }
    return msgId;
}

void TelegramCore::onChannelsEditTitleAnswer(qint64 msgId, const UpdatesType &result, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mRecallArgs.remove(msgId);
    callBackCall<UpdatesType >(msgId, result);
    stopTimeOut(msgId);
    Q_EMIT channelsEditTitleAnswer(msgId, result);
}

void TelegramCore::onChannelsEditTitleError(qint64 msgId, qint32 errorCode, const QString &errorText, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mRecallArgs.remove(msgId);
    const UpdatesType &result = UpdatesType();
    CallbackError error;
    error.errorCode = errorCode;
    error.errorText = errorText;
    error.null = false;
    callBackCall<UpdatesType >(msgId, result, error);
    stopTimeOut(msgId);
    Q_EMIT channelsEditTitleError(msgId, errorCode, errorText);
}

qint64 TelegramCore::channelsEditPhoto(const InputChannel &channel, const InputChatPhoto &photo, Callback<UpdatesType > callBack, qint32 timeout) {
    if(!mApi) {
        const UpdatesType &result = UpdatesType();
        if(callBack)
            callBack(0, result, apiError());
        return 0;
    }
    qint64 msgId = mApi->channelsEditPhoto(channel, photo);
    if(msgId) {
        callBackPush<UpdatesType >(msgId, callBack);
        startTimeOut(msgId, timeout);
        mRecallArgs[msgId][""] = "channelsEditPhoto";
        mRecallArgs[msgId]["channel"] = QVariant::fromValue<InputChannel>(channel);
        mRecallArgs[msgId]["photo"] = QVariant::fromValue<InputChatPhoto>(photo);
    } else {
        const UpdatesType &result = UpdatesType();
        if(callBack)
            callBack(0, result, apiError());
    }
    return msgId;
}

void TelegramCore::onChannelsEditPhotoAnswer(qint64 msgId, const UpdatesType &result, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mRecallArgs.remove(msgId);
    callBackCall<UpdatesType >(msgId, result);
    stopTimeOut(msgId);
    Q_EMIT channelsEditPhotoAnswer(msgId, result);
}

void TelegramCore::onChannelsEditPhotoError(qint64 msgId, qint32 errorCode, const QString &errorText, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mRecallArgs.remove(msgId);
    const UpdatesType &result = UpdatesType();
    CallbackError error;
    error.errorCode = errorCode;
    error.errorText = errorText;
    error.null = false;
    callBackCall<UpdatesType >(msgId, result, error);
    stopTimeOut(msgId);
    Q_EMIT channelsEditPhotoError(msgId, errorCode, errorText);
}

qint64 TelegramCore::channelsToggleComments(const InputChannel &channel, bool enabled, Callback<UpdatesType > callBack, qint32 timeout) {
    if(!mApi) {
        const UpdatesType &result = UpdatesType();
        if(callBack)
            callBack(0, result, apiError());
        return 0;
    }
    qint64 msgId = mApi->channelsToggleComments(channel, enabled);
    if(msgId) {
        callBackPush<UpdatesType >(msgId, callBack);
        startTimeOut(msgId, timeout);
        mRecallArgs[msgId][""] = "channelsToggleComments";
        mRecallArgs[msgId]["channel"] = QVariant::fromValue<InputChannel>(channel);
        mRecallArgs[msgId]["enabled"] = QVariant::fromValue<bool>(enabled);
    } else {
        const UpdatesType &result = UpdatesType();
        if(callBack)
            callBack(0, result, apiError());
    }
    return msgId;
}

void TelegramCore::onChannelsToggleCommentsAnswer(qint64 msgId, const UpdatesType &result, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mRecallArgs.remove(msgId);
    callBackCall<UpdatesType >(msgId, result);
    stopTimeOut(msgId);
    Q_EMIT channelsToggleCommentsAnswer(msgId, result);
}

void TelegramCore::onChannelsToggleCommentsError(qint64 msgId, qint32 errorCode, const QString &errorText, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mRecallArgs.remove(msgId);
    const UpdatesType &result = UpdatesType();
    CallbackError error;
    error.errorCode = errorCode;
    error.errorText = errorText;
    error.null = false;
    callBackCall<UpdatesType >(msgId, result, error);
    stopTimeOut(msgId);
    Q_EMIT channelsToggleCommentsError(msgId, errorCode, errorText);
}

qint64 TelegramCore::channelsCheckUsername(const InputChannel &channel, const QString &username, Callback<bool > callBack, qint32 timeout) {
    if(!mApi) {
        bool result = 0;
        if(callBack)
            callBack(0, result, apiError());
        return 0;
    }
    qint64 msgId = mApi->channelsCheckUsername(channel, username);
    if(msgId) {
        callBackPush<bool >(msgId, callBack);
        startTimeOut(msgId, timeout);
        mRecallArgs[msgId][""] = "channelsCheckUsername";
        mRecallArgs[msgId]["channel"] = QVariant::fromValue<InputChannel>(channel);
        mRecallArgs[msgId]["username"] = QVariant::fromValue<QString>(username);
    } else {
        bool result = 0;
        if(callBack)
            callBack(0, result, apiError());
    }
    return msgId;
}

void TelegramCore::onChannelsCheckUsernameAnswer(qint64 msgId, bool result, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mRecallArgs.remove(msgId);
    callBackCall<bool >(msgId, result);
    stopTimeOut(msgId);
    Q_EMIT channelsCheckUsernameAnswer(msgId, result);
}

void TelegramCore::onChannelsCheckUsernameError(qint64 msgId, qint32 errorCode, const QString &errorText, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mRecallArgs.remove(msgId);
    bool result = 0;
    CallbackError error;
    error.errorCode = errorCode;
    error.errorText = errorText;
    error.null = false;
    callBackCall<bool >(msgId, result, error);
    stopTimeOut(msgId);
    Q_EMIT channelsCheckUsernameError(msgId, errorCode, errorText);
}

qint64 TelegramCore::channelsUpdateUsername(const InputChannel &channel, const QString &username, Callback<bool > callBack, qint32 timeout) {
    if(!mApi) {
        bool result = 0;
        if(callBack)
            callBack(0, result, apiError());
        return 0;
    }
    qint64 msgId = mApi->channelsUpdateUsername(channel, username);
    if(msgId) {
        callBackPush<bool >(msgId, callBack);
        startTimeOut(msgId, timeout);
        mRecallArgs[msgId][""] = "channelsUpdateUsername";
        mRecallArgs[msgId]["channel"] = QVariant::fromValue<InputChannel>(channel);
        mRecallArgs[msgId]["username"] = QVariant::fromValue<QString>(username);
    } else {
        bool result = 0;
        if(callBack)
            callBack(0, result, apiError());
    }
    return msgId;
}

void TelegramCore::onChannelsUpdateUsernameAnswer(qint64 msgId, bool result, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mRecallArgs.remove(msgId);
    callBackCall<bool >(msgId, result);
    stopTimeOut(msgId);
    Q_EMIT channelsUpdateUsernameAnswer(msgId, result);
}

void TelegramCore::onChannelsUpdateUsernameError(qint64 msgId, qint32 errorCode, const QString &errorText, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mRecallArgs.remove(msgId);
    bool result = 0;
    CallbackError error;
    error.errorCode = errorCode;
    error.errorText = errorText;
    error.null = false;
    callBackCall<bool >(msgId, result, error);
    stopTimeOut(msgId);
    Q_EMIT channelsUpdateUsernameError(msgId, errorCode, errorText);
}

qint64 TelegramCore::channelsJoinChannel(const InputChannel &channel, Callback<UpdatesType > callBack, qint32 timeout) {
    if(!mApi) {
        const UpdatesType &result = UpdatesType();
        if(callBack)
            callBack(0, result, apiError());
        return 0;
    }
    qint64 msgId = mApi->channelsJoinChannel(channel);
    if(msgId) {
        callBackPush<UpdatesType >(msgId, callBack);
        startTimeOut(msgId, timeout);
        mRecallArgs[msgId][""] = "channelsJoinChannel";
        mRecallArgs[msgId]["channel"] = QVariant::fromValue<InputChannel>(channel);
    } else {
        const UpdatesType &result = UpdatesType();
        if(callBack)
            callBack(0, result, apiError());
    }
    return msgId;
}

void TelegramCore::onChannelsJoinChannelAnswer(qint64 msgId, const UpdatesType &result, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mRecallArgs.remove(msgId);
    callBackCall<UpdatesType >(msgId, result);
    stopTimeOut(msgId);
    Q_EMIT channelsJoinChannelAnswer(msgId, result);
}

void TelegramCore::onChannelsJoinChannelError(qint64 msgId, qint32 errorCode, const QString &errorText, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mRecallArgs.remove(msgId);
    const UpdatesType &result = UpdatesType();
    CallbackError error;
    error.errorCode = errorCode;
    error.errorText = errorText;
    error.null = false;
    callBackCall<UpdatesType >(msgId, result, error);
    stopTimeOut(msgId);
    Q_EMIT channelsJoinChannelError(msgId, errorCode, errorText);
}

qint64 TelegramCore::channelsLeaveChannel(const InputChannel &channel, Callback<UpdatesType > callBack, qint32 timeout) {
    if(!mApi) {
        const UpdatesType &result = UpdatesType();
        if(callBack)
            callBack(0, result, apiError());
        return 0;
    }
    qint64 msgId = mApi->channelsLeaveChannel(channel);
    if(msgId) {
        callBackPush<UpdatesType >(msgId, callBack);
        startTimeOut(msgId, timeout);
        mRecallArgs[msgId][""] = "channelsLeaveChannel";
        mRecallArgs[msgId]["channel"] = QVariant::fromValue<InputChannel>(channel);
    } else {
        const UpdatesType &result = UpdatesType();
        if(callBack)
            callBack(0, result, apiError());
    }
    return msgId;
}

void TelegramCore::onChannelsLeaveChannelAnswer(qint64 msgId, const UpdatesType &result, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mRecallArgs.remove(msgId);
    callBackCall<UpdatesType >(msgId, result);
    stopTimeOut(msgId);
    Q_EMIT channelsLeaveChannelAnswer(msgId, result);
}

void TelegramCore::onChannelsLeaveChannelError(qint64 msgId, qint32 errorCode, const QString &errorText, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mRecallArgs.remove(msgId);
    const UpdatesType &result = UpdatesType();
    CallbackError error;
    error.errorCode = errorCode;
    error.errorText = errorText;
    error.null = false;
    callBackCall<UpdatesType >(msgId, result, error);
    stopTimeOut(msgId);
    Q_EMIT channelsLeaveChannelError(msgId, errorCode, errorText);
}

qint64 TelegramCore::channelsInviteToChannel(const InputChannel &channel, const QList<InputUser> &users, Callback<UpdatesType > callBack, qint32 timeout) {
    if(!mApi) {
        const UpdatesType &result = UpdatesType();
        if(callBack)
            callBack(0, result, apiError());
        return 0;
    }
    qint64 msgId = mApi->channelsInviteToChannel(channel, users);
    if(msgId) {
        callBackPush<UpdatesType >(msgId, callBack);
        startTimeOut(msgId, timeout);
        mRecallArgs[msgId][""] = "channelsInviteToChannel";
        mRecallArgs[msgId]["channel"] = QVariant::fromValue<InputChannel>(channel);
        mRecallArgs[msgId]["users"] = QVariant::fromValue<QList<InputUser>>(users);
    } else {
        const UpdatesType &result = UpdatesType();
        if(callBack)
            callBack(0, result, apiError());
    }
    return msgId;
}

void TelegramCore::onChannelsInviteToChannelAnswer(qint64 msgId, const UpdatesType &result, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mRecallArgs.remove(msgId);
    callBackCall<UpdatesType >(msgId, result);
    stopTimeOut(msgId);
    Q_EMIT channelsInviteToChannelAnswer(msgId, result);
}

void TelegramCore::onChannelsInviteToChannelError(qint64 msgId, qint32 errorCode, const QString &errorText, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mRecallArgs.remove(msgId);
    const UpdatesType &result = UpdatesType();
    CallbackError error;
    error.errorCode = errorCode;
    error.errorText = errorText;
    error.null = false;
    callBackCall<UpdatesType >(msgId, result, error);
    stopTimeOut(msgId);
    Q_EMIT channelsInviteToChannelError(msgId, errorCode, errorText);
}

qint64 TelegramCore::channelsKickFromChannel(const InputChannel &channel, const InputUser &user_id, bool kicked, Callback<UpdatesType > callBack, qint32 timeout) {
    if(!mApi) {
        const UpdatesType &result = UpdatesType();
        if(callBack)
            callBack(0, result, apiError());
        return 0;
    }
    qint64 msgId = mApi->channelsKickFromChannel(channel, user_id, kicked);
    if(msgId) {
        callBackPush<UpdatesType >(msgId, callBack);
        startTimeOut(msgId, timeout);
        mRecallArgs[msgId][""] = "channelsKickFromChannel";
        mRecallArgs[msgId]["channel"] = QVariant::fromValue<InputChannel>(channel);
        mRecallArgs[msgId]["user_id"] = QVariant::fromValue<InputUser>(user_id);
        mRecallArgs[msgId]["kicked"] = QVariant::fromValue<bool>(kicked);
    } else {
        const UpdatesType &result = UpdatesType();
        if(callBack)
            callBack(0, result, apiError());
    }
    return msgId;
}

void TelegramCore::onChannelsKickFromChannelAnswer(qint64 msgId, const UpdatesType &result, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mRecallArgs.remove(msgId);
    callBackCall<UpdatesType >(msgId, result);
    stopTimeOut(msgId);
    Q_EMIT channelsKickFromChannelAnswer(msgId, result);
}

void TelegramCore::onChannelsKickFromChannelError(qint64 msgId, qint32 errorCode, const QString &errorText, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mRecallArgs.remove(msgId);
    const UpdatesType &result = UpdatesType();
    CallbackError error;
    error.errorCode = errorCode;
    error.errorText = errorText;
    error.null = false;
    callBackCall<UpdatesType >(msgId, result, error);
    stopTimeOut(msgId);
    Q_EMIT channelsKickFromChannelError(msgId, errorCode, errorText);
}

qint64 TelegramCore::channelsExportInvite(const InputChannel &channel, Callback<ExportedChatInvite > callBack, qint32 timeout) {
    if(!mApi) {
        const ExportedChatInvite &result = ExportedChatInvite();
        if(callBack)
            callBack(0, result, apiError());
        return 0;
    }
    qint64 msgId = mApi->channelsExportInvite(channel);
    if(msgId) {
        callBackPush<ExportedChatInvite >(msgId, callBack);
        startTimeOut(msgId, timeout);
        mRecallArgs[msgId][""] = "channelsExportInvite";
        mRecallArgs[msgId]["channel"] = QVariant::fromValue<InputChannel>(channel);
    } else {
        const ExportedChatInvite &result = ExportedChatInvite();
        if(callBack)
            callBack(0, result, apiError());
    }
    return msgId;
}

void TelegramCore::onChannelsExportInviteAnswer(qint64 msgId, const ExportedChatInvite &result, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mRecallArgs.remove(msgId);
    callBackCall<ExportedChatInvite >(msgId, result);
    stopTimeOut(msgId);
    Q_EMIT channelsExportInviteAnswer(msgId, result);
}

void TelegramCore::onChannelsExportInviteError(qint64 msgId, qint32 errorCode, const QString &errorText, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mRecallArgs.remove(msgId);
    const ExportedChatInvite &result = ExportedChatInvite();
    CallbackError error;
    error.errorCode = errorCode;
    error.errorText = errorText;
    error.null = false;
    callBackCall<ExportedChatInvite >(msgId, result, error);
    stopTimeOut(msgId);
    Q_EMIT channelsExportInviteError(msgId, errorCode, errorText);
}

qint64 TelegramCore::channelsDeleteChannel(const InputChannel &channel, Callback<UpdatesType > callBack, qint32 timeout) {
    if(!mApi) {
        const UpdatesType &result = UpdatesType();
        if(callBack)
            callBack(0, result, apiError());
        return 0;
    }
    qint64 msgId = mApi->channelsDeleteChannel(channel);
    if(msgId) {
        callBackPush<UpdatesType >(msgId, callBack);
        startTimeOut(msgId, timeout);
        mRecallArgs[msgId][""] = "channelsDeleteChannel";
        mRecallArgs[msgId]["channel"] = QVariant::fromValue<InputChannel>(channel);
    } else {
        const UpdatesType &result = UpdatesType();
        if(callBack)
            callBack(0, result, apiError());
    }
    return msgId;
}

void TelegramCore::onChannelsDeleteChannelAnswer(qint64 msgId, const UpdatesType &result, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mRecallArgs.remove(msgId);
    callBackCall<UpdatesType >(msgId, result);
    stopTimeOut(msgId);
    Q_EMIT channelsDeleteChannelAnswer(msgId, result);
}

void TelegramCore::onChannelsDeleteChannelError(qint64 msgId, qint32 errorCode, const QString &errorText, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mRecallArgs.remove(msgId);
    const UpdatesType &result = UpdatesType();
    CallbackError error;
    error.errorCode = errorCode;
    error.errorText = errorText;
    error.null = false;
    callBackCall<UpdatesType >(msgId, result, error);
    stopTimeOut(msgId);
    Q_EMIT channelsDeleteChannelError(msgId, errorCode, errorText);
}


qint64 TelegramCore::contactsGetStatuses(Callback<QList<ContactStatus> > callBack, qint32 timeout) {
    if(!mApi) {
        const QList<ContactStatus> &result = QList<ContactStatus>();
        if(callBack)
            callBack(0, result, apiError());
        return 0;
    }
    qint64 msgId = mApi->contactsGetStatuses();
    if(msgId) {
        callBackPush<QList<ContactStatus> >(msgId, callBack);
        startTimeOut(msgId, timeout);
        mRecallArgs[msgId][""] = "contactsGetStatuses";
    } else {
        const QList<ContactStatus> &result = QList<ContactStatus>();
        if(callBack)
            callBack(0, result, apiError());
    }
    return msgId;
}

void TelegramCore::onContactsGetStatusesAnswer(qint64 msgId, const QList<ContactStatus> &result, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mRecallArgs.remove(msgId);
    callBackCall<QList<ContactStatus> >(msgId, result);
    stopTimeOut(msgId);
    Q_EMIT contactsGetStatusesAnswer(msgId, result);
}

void TelegramCore::onContactsGetStatusesError(qint64 msgId, qint32 errorCode, const QString &errorText, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mRecallArgs.remove(msgId);
    const QList<ContactStatus> &result = QList<ContactStatus>();
    CallbackError error;
    error.errorCode = errorCode;
    error.errorText = errorText;
    error.null = false;
    callBackCall<QList<ContactStatus> >(msgId, result, error);
    stopTimeOut(msgId);
    Q_EMIT contactsGetStatusesError(msgId, errorCode, errorText);
}

qint64 TelegramCore::contactsGetContacts(const QString &hash, Callback<ContactsContacts > callBack, qint32 timeout) {
    if(!mApi) {
        const ContactsContacts &result = ContactsContacts();
        if(callBack)
            callBack(0, result, apiError());
        return 0;
    }
    qint64 msgId = mApi->contactsGetContacts(hash);
    if(msgId) {
        callBackPush<ContactsContacts >(msgId, callBack);
        startTimeOut(msgId, timeout);
        mRecallArgs[msgId][""] = "contactsGetContacts";
        mRecallArgs[msgId]["hash"] = QVariant::fromValue<QString>(hash);
    } else {
        const ContactsContacts &result = ContactsContacts();
        if(callBack)
            callBack(0, result, apiError());
    }
    return msgId;
}

void TelegramCore::onContactsGetContactsAnswer(qint64 msgId, const ContactsContacts &result, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mRecallArgs.remove(msgId);
    callBackCall<ContactsContacts >(msgId, result);
    stopTimeOut(msgId);
    Q_EMIT contactsGetContactsAnswer(msgId, result);
}

void TelegramCore::onContactsGetContactsError(qint64 msgId, qint32 errorCode, const QString &errorText, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mRecallArgs.remove(msgId);
    const ContactsContacts &result = ContactsContacts();
    CallbackError error;
    error.errorCode = errorCode;
    error.errorText = errorText;
    error.null = false;
    callBackCall<ContactsContacts >(msgId, result, error);
    stopTimeOut(msgId);
    Q_EMIT contactsGetContactsError(msgId, errorCode, errorText);
}

qint64 TelegramCore::contactsImportContacts(const QList<InputContact> &contacts, bool replace, Callback<ContactsImportedContacts > callBack, qint32 timeout) {
    if(!mApi) {
        const ContactsImportedContacts &result = ContactsImportedContacts();
        if(callBack)
            callBack(0, result, apiError());
        return 0;
    }
    qint64 msgId = mApi->contactsImportContacts(contacts, replace);
    if(msgId) {
        callBackPush<ContactsImportedContacts >(msgId, callBack);
        startTimeOut(msgId, timeout);
        mRecallArgs[msgId][""] = "contactsImportContacts";
        mRecallArgs[msgId]["contacts"] = QVariant::fromValue<QList<InputContact>>(contacts);
        mRecallArgs[msgId]["replace"] = QVariant::fromValue<bool>(replace);
    } else {
        const ContactsImportedContacts &result = ContactsImportedContacts();
        if(callBack)
            callBack(0, result, apiError());
    }
    return msgId;
}

void TelegramCore::onContactsImportContactsAnswer(qint64 msgId, const ContactsImportedContacts &result, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mRecallArgs.remove(msgId);
    callBackCall<ContactsImportedContacts >(msgId, result);
    stopTimeOut(msgId);
    Q_EMIT contactsImportContactsAnswer(msgId, result);
}

void TelegramCore::onContactsImportContactsError(qint64 msgId, qint32 errorCode, const QString &errorText, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mRecallArgs.remove(msgId);
    const ContactsImportedContacts &result = ContactsImportedContacts();
    CallbackError error;
    error.errorCode = errorCode;
    error.errorText = errorText;
    error.null = false;
    callBackCall<ContactsImportedContacts >(msgId, result, error);
    stopTimeOut(msgId);
    Q_EMIT contactsImportContactsError(msgId, errorCode, errorText);
}

qint64 TelegramCore::contactsGetSuggested(qint32 limit, Callback<ContactsSuggested > callBack, qint32 timeout) {
    if(!mApi) {
        const ContactsSuggested &result = ContactsSuggested();
        if(callBack)
            callBack(0, result, apiError());
        return 0;
    }
    qint64 msgId = mApi->contactsGetSuggested(limit);
    if(msgId) {
        callBackPush<ContactsSuggested >(msgId, callBack);
        startTimeOut(msgId, timeout);
        mRecallArgs[msgId][""] = "contactsGetSuggested";
        mRecallArgs[msgId]["limit"] = QVariant::fromValue<qint32>(limit);
    } else {
        const ContactsSuggested &result = ContactsSuggested();
        if(callBack)
            callBack(0, result, apiError());
    }
    return msgId;
}

void TelegramCore::onContactsGetSuggestedAnswer(qint64 msgId, const ContactsSuggested &result, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mRecallArgs.remove(msgId);
    callBackCall<ContactsSuggested >(msgId, result);
    stopTimeOut(msgId);
    Q_EMIT contactsGetSuggestedAnswer(msgId, result);
}

void TelegramCore::onContactsGetSuggestedError(qint64 msgId, qint32 errorCode, const QString &errorText, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mRecallArgs.remove(msgId);
    const ContactsSuggested &result = ContactsSuggested();
    CallbackError error;
    error.errorCode = errorCode;
    error.errorText = errorText;
    error.null = false;
    callBackCall<ContactsSuggested >(msgId, result, error);
    stopTimeOut(msgId);
    Q_EMIT contactsGetSuggestedError(msgId, errorCode, errorText);
}

qint64 TelegramCore::contactsDeleteContact(const InputUser &id, Callback<ContactsLink > callBack, qint32 timeout) {
    if(!mApi) {
        const ContactsLink &result = ContactsLink();
        if(callBack)
            callBack(0, result, apiError());
        return 0;
    }
    qint64 msgId = mApi->contactsDeleteContact(id);
    if(msgId) {
        callBackPush<ContactsLink >(msgId, callBack);
        startTimeOut(msgId, timeout);
        mRecallArgs[msgId][""] = "contactsDeleteContact";
        mRecallArgs[msgId]["id"] = QVariant::fromValue<InputUser>(id);
    } else {
        const ContactsLink &result = ContactsLink();
        if(callBack)
            callBack(0, result, apiError());
    }
    return msgId;
}

void TelegramCore::onContactsDeleteContactAnswer(qint64 msgId, const ContactsLink &result, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mRecallArgs.remove(msgId);
    callBackCall<ContactsLink >(msgId, result);
    stopTimeOut(msgId);
    Q_EMIT contactsDeleteContactAnswer(msgId, result);
}

void TelegramCore::onContactsDeleteContactError(qint64 msgId, qint32 errorCode, const QString &errorText, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mRecallArgs.remove(msgId);
    const ContactsLink &result = ContactsLink();
    CallbackError error;
    error.errorCode = errorCode;
    error.errorText = errorText;
    error.null = false;
    callBackCall<ContactsLink >(msgId, result, error);
    stopTimeOut(msgId);
    Q_EMIT contactsDeleteContactError(msgId, errorCode, errorText);
}

qint64 TelegramCore::contactsDeleteContacts(const QList<InputUser> &id, Callback<bool > callBack, qint32 timeout) {
    if(!mApi) {
        bool result = 0;
        if(callBack)
            callBack(0, result, apiError());
        return 0;
    }
    qint64 msgId = mApi->contactsDeleteContacts(id);
    if(msgId) {
        callBackPush<bool >(msgId, callBack);
        startTimeOut(msgId, timeout);
        mRecallArgs[msgId][""] = "contactsDeleteContacts";
        mRecallArgs[msgId]["id"] = QVariant::fromValue<QList<InputUser>>(id);
    } else {
        bool result = 0;
        if(callBack)
            callBack(0, result, apiError());
    }
    return msgId;
}

void TelegramCore::onContactsDeleteContactsAnswer(qint64 msgId, bool result, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mRecallArgs.remove(msgId);
    callBackCall<bool >(msgId, result);
    stopTimeOut(msgId);
    Q_EMIT contactsDeleteContactsAnswer(msgId, result);
}

void TelegramCore::onContactsDeleteContactsError(qint64 msgId, qint32 errorCode, const QString &errorText, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mRecallArgs.remove(msgId);
    bool result = 0;
    CallbackError error;
    error.errorCode = errorCode;
    error.errorText = errorText;
    error.null = false;
    callBackCall<bool >(msgId, result, error);
    stopTimeOut(msgId);
    Q_EMIT contactsDeleteContactsError(msgId, errorCode, errorText);
}

qint64 TelegramCore::contactsBlock(const InputUser &id, Callback<bool > callBack, qint32 timeout) {
    if(!mApi) {
        bool result = 0;
        if(callBack)
            callBack(0, result, apiError());
        return 0;
    }
    qint64 msgId = mApi->contactsBlock(id);
    if(msgId) {
        callBackPush<bool >(msgId, callBack);
        startTimeOut(msgId, timeout);
        mRecallArgs[msgId][""] = "contactsBlock";
        mRecallArgs[msgId]["id"] = QVariant::fromValue<InputUser>(id);
    } else {
        bool result = 0;
        if(callBack)
            callBack(0, result, apiError());
    }
    return msgId;
}

void TelegramCore::onContactsBlockAnswer(qint64 msgId, bool result, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mRecallArgs.remove(msgId);
    callBackCall<bool >(msgId, result);
    stopTimeOut(msgId);
    Q_EMIT contactsBlockAnswer(msgId, result);
}

void TelegramCore::onContactsBlockError(qint64 msgId, qint32 errorCode, const QString &errorText, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mRecallArgs.remove(msgId);
    bool result = 0;
    CallbackError error;
    error.errorCode = errorCode;
    error.errorText = errorText;
    error.null = false;
    callBackCall<bool >(msgId, result, error);
    stopTimeOut(msgId);
    Q_EMIT contactsBlockError(msgId, errorCode, errorText);
}

qint64 TelegramCore::contactsUnblock(const InputUser &id, Callback<bool > callBack, qint32 timeout) {
    if(!mApi) {
        bool result = 0;
        if(callBack)
            callBack(0, result, apiError());
        return 0;
    }
    qint64 msgId = mApi->contactsUnblock(id);
    if(msgId) {
        callBackPush<bool >(msgId, callBack);
        startTimeOut(msgId, timeout);
        mRecallArgs[msgId][""] = "contactsUnblock";
        mRecallArgs[msgId]["id"] = QVariant::fromValue<InputUser>(id);
    } else {
        bool result = 0;
        if(callBack)
            callBack(0, result, apiError());
    }
    return msgId;
}

void TelegramCore::onContactsUnblockAnswer(qint64 msgId, bool result, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mRecallArgs.remove(msgId);
    callBackCall<bool >(msgId, result);
    stopTimeOut(msgId);
    Q_EMIT contactsUnblockAnswer(msgId, result);
}

void TelegramCore::onContactsUnblockError(qint64 msgId, qint32 errorCode, const QString &errorText, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mRecallArgs.remove(msgId);
    bool result = 0;
    CallbackError error;
    error.errorCode = errorCode;
    error.errorText = errorText;
    error.null = false;
    callBackCall<bool >(msgId, result, error);
    stopTimeOut(msgId);
    Q_EMIT contactsUnblockError(msgId, errorCode, errorText);
}

qint64 TelegramCore::contactsGetBlocked(qint32 offset, qint32 limit, Callback<ContactsBlocked > callBack, qint32 timeout) {
    if(!mApi) {
        const ContactsBlocked &result = ContactsBlocked();
        if(callBack)
            callBack(0, result, apiError());
        return 0;
    }
    qint64 msgId = mApi->contactsGetBlocked(offset, limit);
    if(msgId) {
        callBackPush<ContactsBlocked >(msgId, callBack);
        startTimeOut(msgId, timeout);
        mRecallArgs[msgId][""] = "contactsGetBlocked";
        mRecallArgs[msgId]["offset"] = QVariant::fromValue<qint32>(offset);
        mRecallArgs[msgId]["limit"] = QVariant::fromValue<qint32>(limit);
    } else {
        const ContactsBlocked &result = ContactsBlocked();
        if(callBack)
            callBack(0, result, apiError());
    }
    return msgId;
}

void TelegramCore::onContactsGetBlockedAnswer(qint64 msgId, const ContactsBlocked &result, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mRecallArgs.remove(msgId);
    callBackCall<ContactsBlocked >(msgId, result);
    stopTimeOut(msgId);
    Q_EMIT contactsGetBlockedAnswer(msgId, result);
}

void TelegramCore::onContactsGetBlockedError(qint64 msgId, qint32 errorCode, const QString &errorText, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mRecallArgs.remove(msgId);
    const ContactsBlocked &result = ContactsBlocked();
    CallbackError error;
    error.errorCode = errorCode;
    error.errorText = errorText;
    error.null = false;
    callBackCall<ContactsBlocked >(msgId, result, error);
    stopTimeOut(msgId);
    Q_EMIT contactsGetBlockedError(msgId, errorCode, errorText);
}

qint64 TelegramCore::contactsExportCard(Callback<QList<qint32> > callBack, qint32 timeout) {
    if(!mApi) {
        const QList<qint32> &result = QList<qint32>();
        if(callBack)
            callBack(0, result, apiError());
        return 0;
    }
    qint64 msgId = mApi->contactsExportCard();
    if(msgId) {
        callBackPush<QList<qint32> >(msgId, callBack);
        startTimeOut(msgId, timeout);
        mRecallArgs[msgId][""] = "contactsExportCard";
    } else {
        const QList<qint32> &result = QList<qint32>();
        if(callBack)
            callBack(0, result, apiError());
    }
    return msgId;
}

void TelegramCore::onContactsExportCardAnswer(qint64 msgId, const QList<qint32> &result, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mRecallArgs.remove(msgId);
    callBackCall<QList<qint32> >(msgId, result);
    stopTimeOut(msgId);
    Q_EMIT contactsExportCardAnswer(msgId, result);
}

void TelegramCore::onContactsExportCardError(qint64 msgId, qint32 errorCode, const QString &errorText, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mRecallArgs.remove(msgId);
    const QList<qint32> &result = QList<qint32>();
    CallbackError error;
    error.errorCode = errorCode;
    error.errorText = errorText;
    error.null = false;
    callBackCall<QList<qint32> >(msgId, result, error);
    stopTimeOut(msgId);
    Q_EMIT contactsExportCardError(msgId, errorCode, errorText);
}

qint64 TelegramCore::contactsImportCard(const QList<qint32> &export_card, Callback<User > callBack, qint32 timeout) {
    if(!mApi) {
        const User &result = User();
        if(callBack)
            callBack(0, result, apiError());
        return 0;
    }
    qint64 msgId = mApi->contactsImportCard(export_card);
    if(msgId) {
        callBackPush<User >(msgId, callBack);
        startTimeOut(msgId, timeout);
        mRecallArgs[msgId][""] = "contactsImportCard";
        mRecallArgs[msgId]["export_card"] = QVariant::fromValue<QList<qint32>>(export_card);
    } else {
        const User &result = User();
        if(callBack)
            callBack(0, result, apiError());
    }
    return msgId;
}

void TelegramCore::onContactsImportCardAnswer(qint64 msgId, const User &result, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mRecallArgs.remove(msgId);
    callBackCall<User >(msgId, result);
    stopTimeOut(msgId);
    Q_EMIT contactsImportCardAnswer(msgId, result);
}

void TelegramCore::onContactsImportCardError(qint64 msgId, qint32 errorCode, const QString &errorText, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mRecallArgs.remove(msgId);
    const User &result = User();
    CallbackError error;
    error.errorCode = errorCode;
    error.errorText = errorText;
    error.null = false;
    callBackCall<User >(msgId, result, error);
    stopTimeOut(msgId);
    Q_EMIT contactsImportCardError(msgId, errorCode, errorText);
}

qint64 TelegramCore::contactsSearch(const QString &q, qint32 limit, Callback<ContactsFound > callBack, qint32 timeout) {
    if(!mApi) {
        const ContactsFound &result = ContactsFound();
        if(callBack)
            callBack(0, result, apiError());
        return 0;
    }
    qint64 msgId = mApi->contactsSearch(q, limit);
    if(msgId) {
        callBackPush<ContactsFound >(msgId, callBack);
        startTimeOut(msgId, timeout);
        mRecallArgs[msgId][""] = "contactsSearch";
        mRecallArgs[msgId]["q"] = QVariant::fromValue<QString>(q);
        mRecallArgs[msgId]["limit"] = QVariant::fromValue<qint32>(limit);
    } else {
        const ContactsFound &result = ContactsFound();
        if(callBack)
            callBack(0, result, apiError());
    }
    return msgId;
}

void TelegramCore::onContactsSearchAnswer(qint64 msgId, const ContactsFound &result, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mRecallArgs.remove(msgId);
    callBackCall<ContactsFound >(msgId, result);
    stopTimeOut(msgId);
    Q_EMIT contactsSearchAnswer(msgId, result);
}

void TelegramCore::onContactsSearchError(qint64 msgId, qint32 errorCode, const QString &errorText, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mRecallArgs.remove(msgId);
    const ContactsFound &result = ContactsFound();
    CallbackError error;
    error.errorCode = errorCode;
    error.errorText = errorText;
    error.null = false;
    callBackCall<ContactsFound >(msgId, result, error);
    stopTimeOut(msgId);
    Q_EMIT contactsSearchError(msgId, errorCode, errorText);
}

qint64 TelegramCore::contactsResolveUsername(const QString &username, Callback<ContactsResolvedPeer > callBack, qint32 timeout) {
    if(!mApi) {
        const ContactsResolvedPeer &result = ContactsResolvedPeer();
        if(callBack)
            callBack(0, result, apiError());
        return 0;
    }
    qint64 msgId = mApi->contactsResolveUsername(username);
    if(msgId) {
        callBackPush<ContactsResolvedPeer >(msgId, callBack);
        startTimeOut(msgId, timeout);
        mRecallArgs[msgId][""] = "contactsResolveUsername";
        mRecallArgs[msgId]["username"] = QVariant::fromValue<QString>(username);
    } else {
        const ContactsResolvedPeer &result = ContactsResolvedPeer();
        if(callBack)
            callBack(0, result, apiError());
    }
    return msgId;
}

void TelegramCore::onContactsResolveUsernameAnswer(qint64 msgId, const ContactsResolvedPeer &result, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mRecallArgs.remove(msgId);
    callBackCall<ContactsResolvedPeer >(msgId, result);
    stopTimeOut(msgId);
    Q_EMIT contactsResolveUsernameAnswer(msgId, result);
}

void TelegramCore::onContactsResolveUsernameError(qint64 msgId, qint32 errorCode, const QString &errorText, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mRecallArgs.remove(msgId);
    const ContactsResolvedPeer &result = ContactsResolvedPeer();
    CallbackError error;
    error.errorCode = errorCode;
    error.errorText = errorText;
    error.null = false;
    callBackCall<ContactsResolvedPeer >(msgId, result, error);
    stopTimeOut(msgId);
    Q_EMIT contactsResolveUsernameError(msgId, errorCode, errorText);
}


qint64 TelegramCore::helpGetConfig(Callback<Config > callBack, qint32 timeout) {
    if(!mApi) {
        const Config &result = Config();
        if(callBack)
            callBack(0, result, apiError());
        return 0;
    }
    qint64 msgId = mApi->helpGetConfig();
    if(msgId) {
        callBackPush<Config >(msgId, callBack);
        startTimeOut(msgId, timeout);
        mRecallArgs[msgId][""] = "helpGetConfig";
    } else {
        const Config &result = Config();
        if(callBack)
            callBack(0, result, apiError());
    }
    return msgId;
}

void TelegramCore::onHelpGetConfigAnswer(qint64 msgId, const Config &result, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mRecallArgs.remove(msgId);
    callBackCall<Config >(msgId, result);
    stopTimeOut(msgId);
    Q_EMIT helpGetConfigAnswer(msgId, result);
}

void TelegramCore::onHelpGetConfigError(qint64 msgId, qint32 errorCode, const QString &errorText, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mRecallArgs.remove(msgId);
    const Config &result = Config();
    CallbackError error;
    error.errorCode = errorCode;
    error.errorText = errorText;
    error.null = false;
    callBackCall<Config >(msgId, result, error);
    stopTimeOut(msgId);
    Q_EMIT helpGetConfigError(msgId, errorCode, errorText);
}

qint64 TelegramCore::helpGetNearestDc(Callback<NearestDc > callBack, qint32 timeout) {
    if(!mApi) {
        const NearestDc &result = NearestDc();
        if(callBack)
            callBack(0, result, apiError());
        return 0;
    }
    qint64 msgId = mApi->helpGetNearestDc();
    if(msgId) {
        callBackPush<NearestDc >(msgId, callBack);
        startTimeOut(msgId, timeout);
        mRecallArgs[msgId][""] = "helpGetNearestDc";
    } else {
        const NearestDc &result = NearestDc();
        if(callBack)
            callBack(0, result, apiError());
    }
    return msgId;
}

void TelegramCore::onHelpGetNearestDcAnswer(qint64 msgId, const NearestDc &result, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mRecallArgs.remove(msgId);
    callBackCall<NearestDc >(msgId, result);
    stopTimeOut(msgId);
    Q_EMIT helpGetNearestDcAnswer(msgId, result);
}

void TelegramCore::onHelpGetNearestDcError(qint64 msgId, qint32 errorCode, const QString &errorText, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mRecallArgs.remove(msgId);
    const NearestDc &result = NearestDc();
    CallbackError error;
    error.errorCode = errorCode;
    error.errorText = errorText;
    error.null = false;
    callBackCall<NearestDc >(msgId, result, error);
    stopTimeOut(msgId);
    Q_EMIT helpGetNearestDcError(msgId, errorCode, errorText);
}

qint64 TelegramCore::helpGetAppUpdate(const QString &device_model, const QString &system_version, const QString &app_version, const QString &lang_code, Callback<HelpAppUpdate > callBack, qint32 timeout) {
    if(!mApi) {
        const HelpAppUpdate &result = HelpAppUpdate();
        if(callBack)
            callBack(0, result, apiError());
        return 0;
    }
    qint64 msgId = mApi->helpGetAppUpdate(device_model, system_version, app_version, lang_code);
    if(msgId) {
        callBackPush<HelpAppUpdate >(msgId, callBack);
        startTimeOut(msgId, timeout);
        mRecallArgs[msgId][""] = "helpGetAppUpdate";
        mRecallArgs[msgId]["device_model"] = QVariant::fromValue<QString>(device_model);
        mRecallArgs[msgId]["system_version"] = QVariant::fromValue<QString>(system_version);
        mRecallArgs[msgId]["app_version"] = QVariant::fromValue<QString>(app_version);
        mRecallArgs[msgId]["lang_code"] = QVariant::fromValue<QString>(lang_code);
    } else {
        const HelpAppUpdate &result = HelpAppUpdate();
        if(callBack)
            callBack(0, result, apiError());
    }
    return msgId;
}

void TelegramCore::onHelpGetAppUpdateAnswer(qint64 msgId, const HelpAppUpdate &result, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mRecallArgs.remove(msgId);
    callBackCall<HelpAppUpdate >(msgId, result);
    stopTimeOut(msgId);
    Q_EMIT helpGetAppUpdateAnswer(msgId, result);
}

void TelegramCore::onHelpGetAppUpdateError(qint64 msgId, qint32 errorCode, const QString &errorText, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mRecallArgs.remove(msgId);
    const HelpAppUpdate &result = HelpAppUpdate();
    CallbackError error;
    error.errorCode = errorCode;
    error.errorText = errorText;
    error.null = false;
    callBackCall<HelpAppUpdate >(msgId, result, error);
    stopTimeOut(msgId);
    Q_EMIT helpGetAppUpdateError(msgId, errorCode, errorText);
}

qint64 TelegramCore::helpSaveAppLog(const QList<InputAppEvent> &events, Callback<bool > callBack, qint32 timeout) {
    if(!mApi) {
        bool result = 0;
        if(callBack)
            callBack(0, result, apiError());
        return 0;
    }
    qint64 msgId = mApi->helpSaveAppLog(events);
    if(msgId) {
        callBackPush<bool >(msgId, callBack);
        startTimeOut(msgId, timeout);
        mRecallArgs[msgId][""] = "helpSaveAppLog";
        mRecallArgs[msgId]["events"] = QVariant::fromValue<QList<InputAppEvent>>(events);
    } else {
        bool result = 0;
        if(callBack)
            callBack(0, result, apiError());
    }
    return msgId;
}

void TelegramCore::onHelpSaveAppLogAnswer(qint64 msgId, bool result, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mRecallArgs.remove(msgId);
    callBackCall<bool >(msgId, result);
    stopTimeOut(msgId);
    Q_EMIT helpSaveAppLogAnswer(msgId, result);
}

void TelegramCore::onHelpSaveAppLogError(qint64 msgId, qint32 errorCode, const QString &errorText, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mRecallArgs.remove(msgId);
    bool result = 0;
    CallbackError error;
    error.errorCode = errorCode;
    error.errorText = errorText;
    error.null = false;
    callBackCall<bool >(msgId, result, error);
    stopTimeOut(msgId);
    Q_EMIT helpSaveAppLogError(msgId, errorCode, errorText);
}

qint64 TelegramCore::helpGetInviteText(const QString &lang_code, Callback<HelpInviteText > callBack, qint32 timeout) {
    if(!mApi) {
        const HelpInviteText &result = HelpInviteText();
        if(callBack)
            callBack(0, result, apiError());
        return 0;
    }
    qint64 msgId = mApi->helpGetInviteText(lang_code);
    if(msgId) {
        callBackPush<HelpInviteText >(msgId, callBack);
        startTimeOut(msgId, timeout);
        mRecallArgs[msgId][""] = "helpGetInviteText";
        mRecallArgs[msgId]["lang_code"] = QVariant::fromValue<QString>(lang_code);
    } else {
        const HelpInviteText &result = HelpInviteText();
        if(callBack)
            callBack(0, result, apiError());
    }
    return msgId;
}

void TelegramCore::onHelpGetInviteTextAnswer(qint64 msgId, const HelpInviteText &result, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mRecallArgs.remove(msgId);
    callBackCall<HelpInviteText >(msgId, result);
    stopTimeOut(msgId);
    Q_EMIT helpGetInviteTextAnswer(msgId, result);
}

void TelegramCore::onHelpGetInviteTextError(qint64 msgId, qint32 errorCode, const QString &errorText, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mRecallArgs.remove(msgId);
    const HelpInviteText &result = HelpInviteText();
    CallbackError error;
    error.errorCode = errorCode;
    error.errorText = errorText;
    error.null = false;
    callBackCall<HelpInviteText >(msgId, result, error);
    stopTimeOut(msgId);
    Q_EMIT helpGetInviteTextError(msgId, errorCode, errorText);
}

qint64 TelegramCore::helpGetSupport(Callback<HelpSupport > callBack, qint32 timeout) {
    if(!mApi) {
        const HelpSupport &result = HelpSupport();
        if(callBack)
            callBack(0, result, apiError());
        return 0;
    }
    qint64 msgId = mApi->helpGetSupport();
    if(msgId) {
        callBackPush<HelpSupport >(msgId, callBack);
        startTimeOut(msgId, timeout);
        mRecallArgs[msgId][""] = "helpGetSupport";
    } else {
        const HelpSupport &result = HelpSupport();
        if(callBack)
            callBack(0, result, apiError());
    }
    return msgId;
}

void TelegramCore::onHelpGetSupportAnswer(qint64 msgId, const HelpSupport &result, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mRecallArgs.remove(msgId);
    callBackCall<HelpSupport >(msgId, result);
    stopTimeOut(msgId);
    Q_EMIT helpGetSupportAnswer(msgId, result);
}

void TelegramCore::onHelpGetSupportError(qint64 msgId, qint32 errorCode, const QString &errorText, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mRecallArgs.remove(msgId);
    const HelpSupport &result = HelpSupport();
    CallbackError error;
    error.errorCode = errorCode;
    error.errorText = errorText;
    error.null = false;
    callBackCall<HelpSupport >(msgId, result, error);
    stopTimeOut(msgId);
    Q_EMIT helpGetSupportError(msgId, errorCode, errorText);
}

qint64 TelegramCore::helpGetAppChangelog(const QString &device_model, const QString &system_version, const QString &app_version, const QString &lang_code, Callback<HelpAppChangelog > callBack, qint32 timeout) {
    if(!mApi) {
        const HelpAppChangelog &result = HelpAppChangelog();
        if(callBack)
            callBack(0, result, apiError());
        return 0;
    }
    qint64 msgId = mApi->helpGetAppChangelog(device_model, system_version, app_version, lang_code);
    if(msgId) {
        callBackPush<HelpAppChangelog >(msgId, callBack);
        startTimeOut(msgId, timeout);
        mRecallArgs[msgId][""] = "helpGetAppChangelog";
        mRecallArgs[msgId]["device_model"] = QVariant::fromValue<QString>(device_model);
        mRecallArgs[msgId]["system_version"] = QVariant::fromValue<QString>(system_version);
        mRecallArgs[msgId]["app_version"] = QVariant::fromValue<QString>(app_version);
        mRecallArgs[msgId]["lang_code"] = QVariant::fromValue<QString>(lang_code);
    } else {
        const HelpAppChangelog &result = HelpAppChangelog();
        if(callBack)
            callBack(0, result, apiError());
    }
    return msgId;
}

void TelegramCore::onHelpGetAppChangelogAnswer(qint64 msgId, const HelpAppChangelog &result, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mRecallArgs.remove(msgId);
    callBackCall<HelpAppChangelog >(msgId, result);
    stopTimeOut(msgId);
    Q_EMIT helpGetAppChangelogAnswer(msgId, result);
}

void TelegramCore::onHelpGetAppChangelogError(qint64 msgId, qint32 errorCode, const QString &errorText, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mRecallArgs.remove(msgId);
    const HelpAppChangelog &result = HelpAppChangelog();
    CallbackError error;
    error.errorCode = errorCode;
    error.errorText = errorText;
    error.null = false;
    callBackCall<HelpAppChangelog >(msgId, result, error);
    stopTimeOut(msgId);
    Q_EMIT helpGetAppChangelogError(msgId, errorCode, errorText);
}

qint64 TelegramCore::helpGetTermsOfService(const QString &lang_code, Callback<HelpTermsOfService > callBack, qint32 timeout) {
    if(!mApi) {
        const HelpTermsOfService &result = HelpTermsOfService();
        if(callBack)
            callBack(0, result, apiError());
        return 0;
    }
    qint64 msgId = mApi->helpGetTermsOfService(lang_code);
    if(msgId) {
        callBackPush<HelpTermsOfService >(msgId, callBack);
        startTimeOut(msgId, timeout);
        mRecallArgs[msgId][""] = "helpGetTermsOfService";
        mRecallArgs[msgId]["lang_code"] = QVariant::fromValue<QString>(lang_code);
    } else {
        const HelpTermsOfService &result = HelpTermsOfService();
        if(callBack)
            callBack(0, result, apiError());
    }
    return msgId;
}

void TelegramCore::onHelpGetTermsOfServiceAnswer(qint64 msgId, const HelpTermsOfService &result, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mRecallArgs.remove(msgId);
    callBackCall<HelpTermsOfService >(msgId, result);
    stopTimeOut(msgId);
    Q_EMIT helpGetTermsOfServiceAnswer(msgId, result);
}

void TelegramCore::onHelpGetTermsOfServiceError(qint64 msgId, qint32 errorCode, const QString &errorText, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mRecallArgs.remove(msgId);
    const HelpTermsOfService &result = HelpTermsOfService();
    CallbackError error;
    error.errorCode = errorCode;
    error.errorText = errorText;
    error.null = false;
    callBackCall<HelpTermsOfService >(msgId, result, error);
    stopTimeOut(msgId);
    Q_EMIT helpGetTermsOfServiceError(msgId, errorCode, errorText);
}


qint64 TelegramCore::messagesGetMessages(const QList<qint32> &id, Callback<MessagesMessages > callBack, qint32 timeout) {
    if(!mApi) {
        const MessagesMessages &result = MessagesMessages();
        if(callBack)
            callBack(0, result, apiError());
        return 0;
    }
    qint64 msgId = mApi->messagesGetMessages(id);
    if(msgId) {
        callBackPush<MessagesMessages >(msgId, callBack);
        startTimeOut(msgId, timeout);
        mRecallArgs[msgId][""] = "messagesGetMessages";
        mRecallArgs[msgId]["id"] = QVariant::fromValue<QList<qint32>>(id);
    } else {
        const MessagesMessages &result = MessagesMessages();
        if(callBack)
            callBack(0, result, apiError());
    }
    return msgId;
}

void TelegramCore::onMessagesGetMessagesAnswer(qint64 msgId, const MessagesMessages &result, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mRecallArgs.remove(msgId);
    callBackCall<MessagesMessages >(msgId, result);
    stopTimeOut(msgId);
    Q_EMIT messagesGetMessagesAnswer(msgId, result);
}

void TelegramCore::onMessagesGetMessagesError(qint64 msgId, qint32 errorCode, const QString &errorText, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mRecallArgs.remove(msgId);
    const MessagesMessages &result = MessagesMessages();
    CallbackError error;
    error.errorCode = errorCode;
    error.errorText = errorText;
    error.null = false;
    callBackCall<MessagesMessages >(msgId, result, error);
    stopTimeOut(msgId);
    Q_EMIT messagesGetMessagesError(msgId, errorCode, errorText);
}

qint64 TelegramCore::messagesGetDialogs(qint32 offset_date, qint32 offset_id, const InputPeer &offset_peer, qint32 limit, Callback<MessagesDialogs > callBack, qint32 timeout) {
    if(!mApi) {
        const MessagesDialogs &result = MessagesDialogs();
        if(callBack)
            callBack(0, result, apiError());
        return 0;
    }
    qint64 msgId = mApi->messagesGetDialogs(offset_date, offset_id, offset_peer, limit);
    if(msgId) {
        callBackPush<MessagesDialogs >(msgId, callBack);
        startTimeOut(msgId, timeout);
        mRecallArgs[msgId][""] = "messagesGetDialogs";
        mRecallArgs[msgId]["offset_date"] = QVariant::fromValue<qint32>(offset_date);
        mRecallArgs[msgId]["offset_id"] = QVariant::fromValue<qint32>(offset_id);
        mRecallArgs[msgId]["offset_peer"] = QVariant::fromValue<InputPeer>(offset_peer);
        mRecallArgs[msgId]["limit"] = QVariant::fromValue<qint32>(limit);
    } else {
        const MessagesDialogs &result = MessagesDialogs();
        if(callBack)
            callBack(0, result, apiError());
    }
    return msgId;
}

void TelegramCore::onMessagesGetDialogsAnswer(qint64 msgId, const MessagesDialogs &result, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mRecallArgs.remove(msgId);
    callBackCall<MessagesDialogs >(msgId, result);
    stopTimeOut(msgId);
    Q_EMIT messagesGetDialogsAnswer(msgId, result);
}

void TelegramCore::onMessagesGetDialogsError(qint64 msgId, qint32 errorCode, const QString &errorText, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mRecallArgs.remove(msgId);
    const MessagesDialogs &result = MessagesDialogs();
    CallbackError error;
    error.errorCode = errorCode;
    error.errorText = errorText;
    error.null = false;
    callBackCall<MessagesDialogs >(msgId, result, error);
    stopTimeOut(msgId);
    Q_EMIT messagesGetDialogsError(msgId, errorCode, errorText);
}

qint64 TelegramCore::messagesGetHistory(const InputPeer &peer, qint32 offset_id, qint32 add_offset, qint32 limit, qint32 max_id, qint32 min_id, Callback<MessagesMessages > callBack, qint32 timeout) {
    if(!mApi) {
        const MessagesMessages &result = MessagesMessages();
        if(callBack)
            callBack(0, result, apiError());
        return 0;
    }
    qint64 msgId = mApi->messagesGetHistory(peer, offset_id, add_offset, limit, max_id, min_id);
    if(msgId) {
        callBackPush<MessagesMessages >(msgId, callBack);
        startTimeOut(msgId, timeout);
        mRecallArgs[msgId][""] = "messagesGetHistory";
        mRecallArgs[msgId]["peer"] = QVariant::fromValue<InputPeer>(peer);
        mRecallArgs[msgId]["offset_id"] = QVariant::fromValue<qint32>(offset_id);
        mRecallArgs[msgId]["add_offset"] = QVariant::fromValue<qint32>(add_offset);
        mRecallArgs[msgId]["limit"] = QVariant::fromValue<qint32>(limit);
        mRecallArgs[msgId]["max_id"] = QVariant::fromValue<qint32>(max_id);
        mRecallArgs[msgId]["min_id"] = QVariant::fromValue<qint32>(min_id);
    } else {
        const MessagesMessages &result = MessagesMessages();
        if(callBack)
            callBack(0, result, apiError());
    }
    return msgId;
}

void TelegramCore::onMessagesGetHistoryAnswer(qint64 msgId, const MessagesMessages &result, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mRecallArgs.remove(msgId);
    callBackCall<MessagesMessages >(msgId, result);
    stopTimeOut(msgId);
    Q_EMIT messagesGetHistoryAnswer(msgId, result);
}

void TelegramCore::onMessagesGetHistoryError(qint64 msgId, qint32 errorCode, const QString &errorText, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mRecallArgs.remove(msgId);
    const MessagesMessages &result = MessagesMessages();
    CallbackError error;
    error.errorCode = errorCode;
    error.errorText = errorText;
    error.null = false;
    callBackCall<MessagesMessages >(msgId, result, error);
    stopTimeOut(msgId);
    Q_EMIT messagesGetHistoryError(msgId, errorCode, errorText);
}

qint64 TelegramCore::messagesSearch(bool important_only, const InputPeer &peer, const QString &q, const MessagesFilter &filter, qint32 min_date, qint32 max_date, qint32 offset, qint32 max_id, qint32 limit, Callback<MessagesMessages > callBack, qint32 timeout) {
    if(!mApi) {
        const MessagesMessages &result = MessagesMessages();
        if(callBack)
            callBack(0, result, apiError());
        return 0;
    }
    qint64 msgId = mApi->messagesSearch(important_only, peer, q, filter, min_date, max_date, offset, max_id, limit);
    if(msgId) {
        callBackPush<MessagesMessages >(msgId, callBack);
        startTimeOut(msgId, timeout);
        mRecallArgs[msgId][""] = "messagesSearch";
        mRecallArgs[msgId]["important_only"] = QVariant::fromValue<bool>(important_only);
        mRecallArgs[msgId]["peer"] = QVariant::fromValue<InputPeer>(peer);
        mRecallArgs[msgId]["q"] = QVariant::fromValue<QString>(q);
        mRecallArgs[msgId]["filter"] = QVariant::fromValue<MessagesFilter>(filter);
        mRecallArgs[msgId]["min_date"] = QVariant::fromValue<qint32>(min_date);
        mRecallArgs[msgId]["max_date"] = QVariant::fromValue<qint32>(max_date);
        mRecallArgs[msgId]["offset"] = QVariant::fromValue<qint32>(offset);
        mRecallArgs[msgId]["max_id"] = QVariant::fromValue<qint32>(max_id);
        mRecallArgs[msgId]["limit"] = QVariant::fromValue<qint32>(limit);
    } else {
        const MessagesMessages &result = MessagesMessages();
        if(callBack)
            callBack(0, result, apiError());
    }
    return msgId;
}

void TelegramCore::onMessagesSearchAnswer(qint64 msgId, const MessagesMessages &result, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mRecallArgs.remove(msgId);
    callBackCall<MessagesMessages >(msgId, result);
    stopTimeOut(msgId);
    Q_EMIT messagesSearchAnswer(msgId, result);
}

void TelegramCore::onMessagesSearchError(qint64 msgId, qint32 errorCode, const QString &errorText, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mRecallArgs.remove(msgId);
    const MessagesMessages &result = MessagesMessages();
    CallbackError error;
    error.errorCode = errorCode;
    error.errorText = errorText;
    error.null = false;
    callBackCall<MessagesMessages >(msgId, result, error);
    stopTimeOut(msgId);
    Q_EMIT messagesSearchError(msgId, errorCode, errorText);
}

qint64 TelegramCore::messagesReadHistory(const InputPeer &peer, qint32 max_id, Callback<MessagesAffectedMessages > callBack, qint32 timeout) {
    if(!mApi) {
        const MessagesAffectedMessages &result = MessagesAffectedMessages();
        if(callBack)
            callBack(0, result, apiError());
        return 0;
    }
    qint64 msgId = mApi->messagesReadHistory(peer, max_id);
    if(msgId) {
        callBackPush<MessagesAffectedMessages >(msgId, callBack);
        startTimeOut(msgId, timeout);
        mRecallArgs[msgId][""] = "messagesReadHistory";
        mRecallArgs[msgId]["peer"] = QVariant::fromValue<InputPeer>(peer);
        mRecallArgs[msgId]["max_id"] = QVariant::fromValue<qint32>(max_id);
    } else {
        const MessagesAffectedMessages &result = MessagesAffectedMessages();
        if(callBack)
            callBack(0, result, apiError());
    }
    return msgId;
}

void TelegramCore::onMessagesReadHistoryAnswer(qint64 msgId, const MessagesAffectedMessages &result, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mRecallArgs.remove(msgId);
    callBackCall<MessagesAffectedMessages >(msgId, result);
    stopTimeOut(msgId);
    Q_EMIT messagesReadHistoryAnswer(msgId, result);
}

void TelegramCore::onMessagesReadHistoryError(qint64 msgId, qint32 errorCode, const QString &errorText, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mRecallArgs.remove(msgId);
    const MessagesAffectedMessages &result = MessagesAffectedMessages();
    CallbackError error;
    error.errorCode = errorCode;
    error.errorText = errorText;
    error.null = false;
    callBackCall<MessagesAffectedMessages >(msgId, result, error);
    stopTimeOut(msgId);
    Q_EMIT messagesReadHistoryError(msgId, errorCode, errorText);
}

qint64 TelegramCore::messagesDeleteHistory(const InputPeer &peer, qint32 max_id, Callback<MessagesAffectedHistory > callBack, qint32 timeout) {
    if(!mApi) {
        const MessagesAffectedHistory &result = MessagesAffectedHistory();
        if(callBack)
            callBack(0, result, apiError());
        return 0;
    }
    qint64 msgId = mApi->messagesDeleteHistory(peer, max_id);
    if(msgId) {
        callBackPush<MessagesAffectedHistory >(msgId, callBack);
        startTimeOut(msgId, timeout);
        mRecallArgs[msgId][""] = "messagesDeleteHistory";
        mRecallArgs[msgId]["peer"] = QVariant::fromValue<InputPeer>(peer);
        mRecallArgs[msgId]["max_id"] = QVariant::fromValue<qint32>(max_id);
    } else {
        const MessagesAffectedHistory &result = MessagesAffectedHistory();
        if(callBack)
            callBack(0, result, apiError());
    }
    return msgId;
}

void TelegramCore::onMessagesDeleteHistoryAnswer(qint64 msgId, const MessagesAffectedHistory &result, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mRecallArgs.remove(msgId);
    callBackCall<MessagesAffectedHistory >(msgId, result);
    stopTimeOut(msgId);
    Q_EMIT messagesDeleteHistoryAnswer(msgId, result);
}

void TelegramCore::onMessagesDeleteHistoryError(qint64 msgId, qint32 errorCode, const QString &errorText, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mRecallArgs.remove(msgId);
    const MessagesAffectedHistory &result = MessagesAffectedHistory();
    CallbackError error;
    error.errorCode = errorCode;
    error.errorText = errorText;
    error.null = false;
    callBackCall<MessagesAffectedHistory >(msgId, result, error);
    stopTimeOut(msgId);
    Q_EMIT messagesDeleteHistoryError(msgId, errorCode, errorText);
}

qint64 TelegramCore::messagesDeleteMessages(const QList<qint32> &id, Callback<MessagesAffectedMessages > callBack, qint32 timeout) {
    if(!mApi) {
        const MessagesAffectedMessages &result = MessagesAffectedMessages();
        if(callBack)
            callBack(0, result, apiError());
        return 0;
    }
    qint64 msgId = mApi->messagesDeleteMessages(id);
    if(msgId) {
        callBackPush<MessagesAffectedMessages >(msgId, callBack);
        startTimeOut(msgId, timeout);
        mRecallArgs[msgId][""] = "messagesDeleteMessages";
        mRecallArgs[msgId]["id"] = QVariant::fromValue<QList<qint32>>(id);
    } else {
        const MessagesAffectedMessages &result = MessagesAffectedMessages();
        if(callBack)
            callBack(0, result, apiError());
    }
    return msgId;
}

void TelegramCore::onMessagesDeleteMessagesAnswer(qint64 msgId, const MessagesAffectedMessages &result, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mRecallArgs.remove(msgId);
    callBackCall<MessagesAffectedMessages >(msgId, result);
    stopTimeOut(msgId);
    Q_EMIT messagesDeleteMessagesAnswer(msgId, result);
}

void TelegramCore::onMessagesDeleteMessagesError(qint64 msgId, qint32 errorCode, const QString &errorText, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mRecallArgs.remove(msgId);
    const MessagesAffectedMessages &result = MessagesAffectedMessages();
    CallbackError error;
    error.errorCode = errorCode;
    error.errorText = errorText;
    error.null = false;
    callBackCall<MessagesAffectedMessages >(msgId, result, error);
    stopTimeOut(msgId);
    Q_EMIT messagesDeleteMessagesError(msgId, errorCode, errorText);
}

qint64 TelegramCore::messagesReceivedMessages(qint32 max_id, Callback<QList<ReceivedNotifyMessage> > callBack, qint32 timeout) {
    if(!mApi) {
        const QList<ReceivedNotifyMessage> &result = QList<ReceivedNotifyMessage>();
        if(callBack)
            callBack(0, result, apiError());
        return 0;
    }
    qint64 msgId = mApi->messagesReceivedMessages(max_id);
    if(msgId) {
        callBackPush<QList<ReceivedNotifyMessage> >(msgId, callBack);
        startTimeOut(msgId, timeout);
        mRecallArgs[msgId][""] = "messagesReceivedMessages";
        mRecallArgs[msgId]["max_id"] = QVariant::fromValue<qint32>(max_id);
    } else {
        const QList<ReceivedNotifyMessage> &result = QList<ReceivedNotifyMessage>();
        if(callBack)
            callBack(0, result, apiError());
    }
    return msgId;
}

void TelegramCore::onMessagesReceivedMessagesAnswer(qint64 msgId, const QList<ReceivedNotifyMessage> &result, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mRecallArgs.remove(msgId);
    callBackCall<QList<ReceivedNotifyMessage> >(msgId, result);
    stopTimeOut(msgId);
    Q_EMIT messagesReceivedMessagesAnswer(msgId, result);
}

void TelegramCore::onMessagesReceivedMessagesError(qint64 msgId, qint32 errorCode, const QString &errorText, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mRecallArgs.remove(msgId);
    const QList<ReceivedNotifyMessage> &result = QList<ReceivedNotifyMessage>();
    CallbackError error;
    error.errorCode = errorCode;
    error.errorText = errorText;
    error.null = false;
    callBackCall<QList<ReceivedNotifyMessage> >(msgId, result, error);
    stopTimeOut(msgId);
    Q_EMIT messagesReceivedMessagesError(msgId, errorCode, errorText);
}

qint64 TelegramCore::messagesSetTyping(const InputPeer &peer, const SendMessageAction &action, Callback<bool > callBack, qint32 timeout) {
    if(!mApi) {
        bool result = 0;
        if(callBack)
            callBack(0, result, apiError());
        return 0;
    }
    qint64 msgId = mApi->messagesSetTyping(peer, action);
    if(msgId) {
        callBackPush<bool >(msgId, callBack);
        startTimeOut(msgId, timeout);
        mRecallArgs[msgId][""] = "messagesSetTyping";
        mRecallArgs[msgId]["peer"] = QVariant::fromValue<InputPeer>(peer);
        mRecallArgs[msgId]["action"] = QVariant::fromValue<SendMessageAction>(action);
    } else {
        bool result = 0;
        if(callBack)
            callBack(0, result, apiError());
    }
    return msgId;
}

void TelegramCore::onMessagesSetTypingAnswer(qint64 msgId, bool result, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mRecallArgs.remove(msgId);
    callBackCall<bool >(msgId, result);
    stopTimeOut(msgId);
    Q_EMIT messagesSetTypingAnswer(msgId, result);
}

void TelegramCore::onMessagesSetTypingError(qint64 msgId, qint32 errorCode, const QString &errorText, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mRecallArgs.remove(msgId);
    bool result = 0;
    CallbackError error;
    error.errorCode = errorCode;
    error.errorText = errorText;
    error.null = false;
    callBackCall<bool >(msgId, result, error);
    stopTimeOut(msgId);
    Q_EMIT messagesSetTypingError(msgId, errorCode, errorText);
}

qint64 TelegramCore::messagesSendMessage(bool no_webpage, bool broadcast, const InputPeer &peer, qint32 reply_to_msg_id, const QString &message, qint64 random_id, const ReplyMarkup &reply_markup, const QList<MessageEntity> &entities, Callback<UpdatesType > callBack, qint32 timeout) {
    if(!mApi) {
        const UpdatesType &result = UpdatesType();
        if(callBack)
            callBack(0, result, apiError());
        return 0;
    }
    qint64 msgId = mApi->messagesSendMessage(no_webpage, broadcast, peer, reply_to_msg_id, message, random_id, reply_markup, entities);
    if(msgId) {
        callBackPush<UpdatesType >(msgId, callBack);
        startTimeOut(msgId, timeout);
        mRecallArgs[msgId][""] = "messagesSendMessage";
        mRecallArgs[msgId]["no_webpage"] = QVariant::fromValue<bool>(no_webpage);
        mRecallArgs[msgId]["broadcast"] = QVariant::fromValue<bool>(broadcast);
        mRecallArgs[msgId]["peer"] = QVariant::fromValue<InputPeer>(peer);
        mRecallArgs[msgId]["reply_to_msg_id"] = QVariant::fromValue<qint32>(reply_to_msg_id);
        mRecallArgs[msgId]["message"] = QVariant::fromValue<QString>(message);
        mRecallArgs[msgId]["random_id"] = QVariant::fromValue<qint64>(random_id);
        mRecallArgs[msgId]["reply_markup"] = QVariant::fromValue<ReplyMarkup>(reply_markup);
        mRecallArgs[msgId]["entities"] = QVariant::fromValue<QList<MessageEntity>>(entities);
    } else {
        const UpdatesType &result = UpdatesType();
        if(callBack)
            callBack(0, result, apiError());
    }
    return msgId;
}

void TelegramCore::onMessagesSendMessageAnswer(qint64 msgId, const UpdatesType &result, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mRecallArgs.remove(msgId);
    callBackCall<UpdatesType >(msgId, result);
    stopTimeOut(msgId);
    Q_EMIT messagesSendMessageAnswer(msgId, result);
}

void TelegramCore::onMessagesSendMessageError(qint64 msgId, qint32 errorCode, const QString &errorText, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mRecallArgs.remove(msgId);
    const UpdatesType &result = UpdatesType();
    CallbackError error;
    error.errorCode = errorCode;
    error.errorText = errorText;
    error.null = false;
    callBackCall<UpdatesType >(msgId, result, error);
    stopTimeOut(msgId);
    Q_EMIT messagesSendMessageError(msgId, errorCode, errorText);
}

qint64 TelegramCore::messagesSendMedia(bool broadcast, const InputPeer &peer, qint32 reply_to_msg_id, const InputMedia &media, qint64 random_id, const ReplyMarkup &reply_markup, Callback<UpdatesType > callBack, qint32 timeout) {
    if(!mApi) {
        const UpdatesType &result = UpdatesType();
        if(callBack)
            callBack(0, result, apiError());
        return 0;
    }
    qint64 msgId = mApi->messagesSendMedia(broadcast, peer, reply_to_msg_id, media, random_id, reply_markup);
    if(msgId) {
        callBackPush<UpdatesType >(msgId, callBack);
        startTimeOut(msgId, timeout);
        mRecallArgs[msgId][""] = "messagesSendMedia";
        mRecallArgs[msgId]["broadcast"] = QVariant::fromValue<bool>(broadcast);
        mRecallArgs[msgId]["peer"] = QVariant::fromValue<InputPeer>(peer);
        mRecallArgs[msgId]["reply_to_msg_id"] = QVariant::fromValue<qint32>(reply_to_msg_id);
        mRecallArgs[msgId]["media"] = QVariant::fromValue<InputMedia>(media);
        mRecallArgs[msgId]["random_id"] = QVariant::fromValue<qint64>(random_id);
        mRecallArgs[msgId]["reply_markup"] = QVariant::fromValue<ReplyMarkup>(reply_markup);
    } else {
        const UpdatesType &result = UpdatesType();
        if(callBack)
            callBack(0, result, apiError());
    }
    return msgId;
}

void TelegramCore::onMessagesSendMediaAnswer(qint64 msgId, const UpdatesType &result, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mRecallArgs.remove(msgId);
    callBackCall<UpdatesType >(msgId, result);
    stopTimeOut(msgId);
    Q_EMIT messagesSendMediaAnswer(msgId, result);
}

void TelegramCore::onMessagesSendMediaError(qint64 msgId, qint32 errorCode, const QString &errorText, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mRecallArgs.remove(msgId);
    const UpdatesType &result = UpdatesType();
    CallbackError error;
    error.errorCode = errorCode;
    error.errorText = errorText;
    error.null = false;
    callBackCall<UpdatesType >(msgId, result, error);
    stopTimeOut(msgId);
    Q_EMIT messagesSendMediaError(msgId, errorCode, errorText);
}

qint64 TelegramCore::messagesForwardMessages(bool broadcast, const InputPeer &from_peer, const QList<qint32> &id, const QList<qint64> &random_id, const InputPeer &to_peer, Callback<UpdatesType > callBack, qint32 timeout) {
    if(!mApi) {
        const UpdatesType &result = UpdatesType();
        if(callBack)
            callBack(0, result, apiError());
        return 0;
    }
    qint64 msgId = mApi->messagesForwardMessages(broadcast, from_peer, id, random_id, to_peer);
    if(msgId) {
        callBackPush<UpdatesType >(msgId, callBack);
        startTimeOut(msgId, timeout);
        mRecallArgs[msgId][""] = "messagesForwardMessages";
        mRecallArgs[msgId]["broadcast"] = QVariant::fromValue<bool>(broadcast);
        mRecallArgs[msgId]["from_peer"] = QVariant::fromValue<InputPeer>(from_peer);
        mRecallArgs[msgId]["id"] = QVariant::fromValue<QList<qint32>>(id);
        mRecallArgs[msgId]["random_id"] = QVariant::fromValue<QList<qint64>>(random_id);
        mRecallArgs[msgId]["to_peer"] = QVariant::fromValue<InputPeer>(to_peer);
    } else {
        const UpdatesType &result = UpdatesType();
        if(callBack)
            callBack(0, result, apiError());
    }
    return msgId;
}

void TelegramCore::onMessagesForwardMessagesAnswer(qint64 msgId, const UpdatesType &result, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mRecallArgs.remove(msgId);
    callBackCall<UpdatesType >(msgId, result);
    stopTimeOut(msgId);
    Q_EMIT messagesForwardMessagesAnswer(msgId, result);
}

void TelegramCore::onMessagesForwardMessagesError(qint64 msgId, qint32 errorCode, const QString &errorText, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mRecallArgs.remove(msgId);
    const UpdatesType &result = UpdatesType();
    CallbackError error;
    error.errorCode = errorCode;
    error.errorText = errorText;
    error.null = false;
    callBackCall<UpdatesType >(msgId, result, error);
    stopTimeOut(msgId);
    Q_EMIT messagesForwardMessagesError(msgId, errorCode, errorText);
}

qint64 TelegramCore::messagesReportSpam(const InputPeer &peer, Callback<bool > callBack, qint32 timeout) {
    if(!mApi) {
        bool result = 0;
        if(callBack)
            callBack(0, result, apiError());
        return 0;
    }
    qint64 msgId = mApi->messagesReportSpam(peer);
    if(msgId) {
        callBackPush<bool >(msgId, callBack);
        startTimeOut(msgId, timeout);
        mRecallArgs[msgId][""] = "messagesReportSpam";
        mRecallArgs[msgId]["peer"] = QVariant::fromValue<InputPeer>(peer);
    } else {
        bool result = 0;
        if(callBack)
            callBack(0, result, apiError());
    }
    return msgId;
}

void TelegramCore::onMessagesReportSpamAnswer(qint64 msgId, bool result, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mRecallArgs.remove(msgId);
    callBackCall<bool >(msgId, result);
    stopTimeOut(msgId);
    Q_EMIT messagesReportSpamAnswer(msgId, result);
}

void TelegramCore::onMessagesReportSpamError(qint64 msgId, qint32 errorCode, const QString &errorText, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mRecallArgs.remove(msgId);
    bool result = 0;
    CallbackError error;
    error.errorCode = errorCode;
    error.errorText = errorText;
    error.null = false;
    callBackCall<bool >(msgId, result, error);
    stopTimeOut(msgId);
    Q_EMIT messagesReportSpamError(msgId, errorCode, errorText);
}

qint64 TelegramCore::messagesGetChats(const QList<qint32> &id, Callback<MessagesChats > callBack, qint32 timeout) {
    if(!mApi) {
        const MessagesChats &result = MessagesChats();
        if(callBack)
            callBack(0, result, apiError());
        return 0;
    }
    qint64 msgId = mApi->messagesGetChats(id);
    if(msgId) {
        callBackPush<MessagesChats >(msgId, callBack);
        startTimeOut(msgId, timeout);
        mRecallArgs[msgId][""] = "messagesGetChats";
        mRecallArgs[msgId]["id"] = QVariant::fromValue<QList<qint32>>(id);
    } else {
        const MessagesChats &result = MessagesChats();
        if(callBack)
            callBack(0, result, apiError());
    }
    return msgId;
}

void TelegramCore::onMessagesGetChatsAnswer(qint64 msgId, const MessagesChats &result, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mRecallArgs.remove(msgId);
    callBackCall<MessagesChats >(msgId, result);
    stopTimeOut(msgId);
    Q_EMIT messagesGetChatsAnswer(msgId, result);
}

void TelegramCore::onMessagesGetChatsError(qint64 msgId, qint32 errorCode, const QString &errorText, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mRecallArgs.remove(msgId);
    const MessagesChats &result = MessagesChats();
    CallbackError error;
    error.errorCode = errorCode;
    error.errorText = errorText;
    error.null = false;
    callBackCall<MessagesChats >(msgId, result, error);
    stopTimeOut(msgId);
    Q_EMIT messagesGetChatsError(msgId, errorCode, errorText);
}

qint64 TelegramCore::messagesGetFullChat(qint32 chat_id, Callback<MessagesChatFull > callBack, qint32 timeout) {
    if(!mApi) {
        const MessagesChatFull &result = MessagesChatFull();
        if(callBack)
            callBack(0, result, apiError());
        return 0;
    }
    qint64 msgId = mApi->messagesGetFullChat(chat_id);
    if(msgId) {
        callBackPush<MessagesChatFull >(msgId, callBack);
        startTimeOut(msgId, timeout);
        mRecallArgs[msgId][""] = "messagesGetFullChat";
        mRecallArgs[msgId]["chat_id"] = QVariant::fromValue<qint32>(chat_id);
    } else {
        const MessagesChatFull &result = MessagesChatFull();
        if(callBack)
            callBack(0, result, apiError());
    }
    return msgId;
}

void TelegramCore::onMessagesGetFullChatAnswer(qint64 msgId, const MessagesChatFull &result, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mRecallArgs.remove(msgId);
    callBackCall<MessagesChatFull >(msgId, result);
    stopTimeOut(msgId);
    Q_EMIT messagesGetFullChatAnswer(msgId, result);
}

void TelegramCore::onMessagesGetFullChatError(qint64 msgId, qint32 errorCode, const QString &errorText, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mRecallArgs.remove(msgId);
    const MessagesChatFull &result = MessagesChatFull();
    CallbackError error;
    error.errorCode = errorCode;
    error.errorText = errorText;
    error.null = false;
    callBackCall<MessagesChatFull >(msgId, result, error);
    stopTimeOut(msgId);
    Q_EMIT messagesGetFullChatError(msgId, errorCode, errorText);
}

qint64 TelegramCore::messagesEditChatTitle(qint32 chat_id, const QString &title, Callback<UpdatesType > callBack, qint32 timeout) {
    if(!mApi) {
        const UpdatesType &result = UpdatesType();
        if(callBack)
            callBack(0, result, apiError());
        return 0;
    }
    qint64 msgId = mApi->messagesEditChatTitle(chat_id, title);
    if(msgId) {
        callBackPush<UpdatesType >(msgId, callBack);
        startTimeOut(msgId, timeout);
        mRecallArgs[msgId][""] = "messagesEditChatTitle";
        mRecallArgs[msgId]["chat_id"] = QVariant::fromValue<qint32>(chat_id);
        mRecallArgs[msgId]["title"] = QVariant::fromValue<QString>(title);
    } else {
        const UpdatesType &result = UpdatesType();
        if(callBack)
            callBack(0, result, apiError());
    }
    return msgId;
}

void TelegramCore::onMessagesEditChatTitleAnswer(qint64 msgId, const UpdatesType &result, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mRecallArgs.remove(msgId);
    callBackCall<UpdatesType >(msgId, result);
    stopTimeOut(msgId);
    Q_EMIT messagesEditChatTitleAnswer(msgId, result);
}

void TelegramCore::onMessagesEditChatTitleError(qint64 msgId, qint32 errorCode, const QString &errorText, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mRecallArgs.remove(msgId);
    const UpdatesType &result = UpdatesType();
    CallbackError error;
    error.errorCode = errorCode;
    error.errorText = errorText;
    error.null = false;
    callBackCall<UpdatesType >(msgId, result, error);
    stopTimeOut(msgId);
    Q_EMIT messagesEditChatTitleError(msgId, errorCode, errorText);
}

qint64 TelegramCore::messagesEditChatPhoto(qint32 chat_id, const InputChatPhoto &photo, Callback<UpdatesType > callBack, qint32 timeout) {
    if(!mApi) {
        const UpdatesType &result = UpdatesType();
        if(callBack)
            callBack(0, result, apiError());
        return 0;
    }
    qint64 msgId = mApi->messagesEditChatPhoto(chat_id, photo);
    if(msgId) {
        callBackPush<UpdatesType >(msgId, callBack);
        startTimeOut(msgId, timeout);
        mRecallArgs[msgId][""] = "messagesEditChatPhoto";
        mRecallArgs[msgId]["chat_id"] = QVariant::fromValue<qint32>(chat_id);
        mRecallArgs[msgId]["photo"] = QVariant::fromValue<InputChatPhoto>(photo);
    } else {
        const UpdatesType &result = UpdatesType();
        if(callBack)
            callBack(0, result, apiError());
    }
    return msgId;
}

void TelegramCore::onMessagesEditChatPhotoAnswer(qint64 msgId, const UpdatesType &result, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mRecallArgs.remove(msgId);
    callBackCall<UpdatesType >(msgId, result);
    stopTimeOut(msgId);
    Q_EMIT messagesEditChatPhotoAnswer(msgId, result);
}

void TelegramCore::onMessagesEditChatPhotoError(qint64 msgId, qint32 errorCode, const QString &errorText, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mRecallArgs.remove(msgId);
    const UpdatesType &result = UpdatesType();
    CallbackError error;
    error.errorCode = errorCode;
    error.errorText = errorText;
    error.null = false;
    callBackCall<UpdatesType >(msgId, result, error);
    stopTimeOut(msgId);
    Q_EMIT messagesEditChatPhotoError(msgId, errorCode, errorText);
}

qint64 TelegramCore::messagesAddChatUser(qint32 chat_id, const InputUser &user_id, qint32 fwd_limit, Callback<UpdatesType > callBack, qint32 timeout) {
    if(!mApi) {
        const UpdatesType &result = UpdatesType();
        if(callBack)
            callBack(0, result, apiError());
        return 0;
    }
    qint64 msgId = mApi->messagesAddChatUser(chat_id, user_id, fwd_limit);
    if(msgId) {
        callBackPush<UpdatesType >(msgId, callBack);
        startTimeOut(msgId, timeout);
        mRecallArgs[msgId][""] = "messagesAddChatUser";
        mRecallArgs[msgId]["chat_id"] = QVariant::fromValue<qint32>(chat_id);
        mRecallArgs[msgId]["user_id"] = QVariant::fromValue<InputUser>(user_id);
        mRecallArgs[msgId]["fwd_limit"] = QVariant::fromValue<qint32>(fwd_limit);
    } else {
        const UpdatesType &result = UpdatesType();
        if(callBack)
            callBack(0, result, apiError());
    }
    return msgId;
}

void TelegramCore::onMessagesAddChatUserAnswer(qint64 msgId, const UpdatesType &result, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mRecallArgs.remove(msgId);
    callBackCall<UpdatesType >(msgId, result);
    stopTimeOut(msgId);
    Q_EMIT messagesAddChatUserAnswer(msgId, result);
}

void TelegramCore::onMessagesAddChatUserError(qint64 msgId, qint32 errorCode, const QString &errorText, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mRecallArgs.remove(msgId);
    const UpdatesType &result = UpdatesType();
    CallbackError error;
    error.errorCode = errorCode;
    error.errorText = errorText;
    error.null = false;
    callBackCall<UpdatesType >(msgId, result, error);
    stopTimeOut(msgId);
    Q_EMIT messagesAddChatUserError(msgId, errorCode, errorText);
}

qint64 TelegramCore::messagesDeleteChatUser(qint32 chat_id, const InputUser &user_id, Callback<UpdatesType > callBack, qint32 timeout) {
    if(!mApi) {
        const UpdatesType &result = UpdatesType();
        if(callBack)
            callBack(0, result, apiError());
        return 0;
    }
    qint64 msgId = mApi->messagesDeleteChatUser(chat_id, user_id);
    if(msgId) {
        callBackPush<UpdatesType >(msgId, callBack);
        startTimeOut(msgId, timeout);
        mRecallArgs[msgId][""] = "messagesDeleteChatUser";
        mRecallArgs[msgId]["chat_id"] = QVariant::fromValue<qint32>(chat_id);
        mRecallArgs[msgId]["user_id"] = QVariant::fromValue<InputUser>(user_id);
    } else {
        const UpdatesType &result = UpdatesType();
        if(callBack)
            callBack(0, result, apiError());
    }
    return msgId;
}

void TelegramCore::onMessagesDeleteChatUserAnswer(qint64 msgId, const UpdatesType &result, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mRecallArgs.remove(msgId);
    callBackCall<UpdatesType >(msgId, result);
    stopTimeOut(msgId);
    Q_EMIT messagesDeleteChatUserAnswer(msgId, result);
}

void TelegramCore::onMessagesDeleteChatUserError(qint64 msgId, qint32 errorCode, const QString &errorText, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mRecallArgs.remove(msgId);
    const UpdatesType &result = UpdatesType();
    CallbackError error;
    error.errorCode = errorCode;
    error.errorText = errorText;
    error.null = false;
    callBackCall<UpdatesType >(msgId, result, error);
    stopTimeOut(msgId);
    Q_EMIT messagesDeleteChatUserError(msgId, errorCode, errorText);
}

qint64 TelegramCore::messagesCreateChat(const QList<InputUser> &users, const QString &title, Callback<UpdatesType > callBack, qint32 timeout) {
    if(!mApi) {
        const UpdatesType &result = UpdatesType();
        if(callBack)
            callBack(0, result, apiError());
        return 0;
    }
    qint64 msgId = mApi->messagesCreateChat(users, title);
    if(msgId) {
        callBackPush<UpdatesType >(msgId, callBack);
        startTimeOut(msgId, timeout);
        mRecallArgs[msgId][""] = "messagesCreateChat";
        mRecallArgs[msgId]["users"] = QVariant::fromValue<QList<InputUser>>(users);
        mRecallArgs[msgId]["title"] = QVariant::fromValue<QString>(title);
    } else {
        const UpdatesType &result = UpdatesType();
        if(callBack)
            callBack(0, result, apiError());
    }
    return msgId;
}

void TelegramCore::onMessagesCreateChatAnswer(qint64 msgId, const UpdatesType &result, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mRecallArgs.remove(msgId);
    callBackCall<UpdatesType >(msgId, result);
    stopTimeOut(msgId);
    Q_EMIT messagesCreateChatAnswer(msgId, result);
}

void TelegramCore::onMessagesCreateChatError(qint64 msgId, qint32 errorCode, const QString &errorText, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mRecallArgs.remove(msgId);
    const UpdatesType &result = UpdatesType();
    CallbackError error;
    error.errorCode = errorCode;
    error.errorText = errorText;
    error.null = false;
    callBackCall<UpdatesType >(msgId, result, error);
    stopTimeOut(msgId);
    Q_EMIT messagesCreateChatError(msgId, errorCode, errorText);
}

qint64 TelegramCore::messagesForwardMessage(const InputPeer &peer, qint32 id, qint64 random_id, Callback<UpdatesType > callBack, qint32 timeout) {
    if(!mApi) {
        const UpdatesType &result = UpdatesType();
        if(callBack)
            callBack(0, result, apiError());
        return 0;
    }
    qint64 msgId = mApi->messagesForwardMessage(peer, id, random_id);
    if(msgId) {
        callBackPush<UpdatesType >(msgId, callBack);
        startTimeOut(msgId, timeout);
        mRecallArgs[msgId][""] = "messagesForwardMessage";
        mRecallArgs[msgId]["peer"] = QVariant::fromValue<InputPeer>(peer);
        mRecallArgs[msgId]["id"] = QVariant::fromValue<qint32>(id);
        mRecallArgs[msgId]["random_id"] = QVariant::fromValue<qint64>(random_id);
    } else {
        const UpdatesType &result = UpdatesType();
        if(callBack)
            callBack(0, result, apiError());
    }
    return msgId;
}

void TelegramCore::onMessagesForwardMessageAnswer(qint64 msgId, const UpdatesType &result, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mRecallArgs.remove(msgId);
    callBackCall<UpdatesType >(msgId, result);
    stopTimeOut(msgId);
    Q_EMIT messagesForwardMessageAnswer(msgId, result);
}

void TelegramCore::onMessagesForwardMessageError(qint64 msgId, qint32 errorCode, const QString &errorText, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mRecallArgs.remove(msgId);
    const UpdatesType &result = UpdatesType();
    CallbackError error;
    error.errorCode = errorCode;
    error.errorText = errorText;
    error.null = false;
    callBackCall<UpdatesType >(msgId, result, error);
    stopTimeOut(msgId);
    Q_EMIT messagesForwardMessageError(msgId, errorCode, errorText);
}

qint64 TelegramCore::messagesSendBroadcast(const QList<InputUser> &contacts, const QList<qint64> &random_id, const QString &message, const InputMedia &media, Callback<UpdatesType > callBack, qint32 timeout) {
    if(!mApi) {
        const UpdatesType &result = UpdatesType();
        if(callBack)
            callBack(0, result, apiError());
        return 0;
    }
    qint64 msgId = mApi->messagesSendBroadcast(contacts, random_id, message, media);
    if(msgId) {
        callBackPush<UpdatesType >(msgId, callBack);
        startTimeOut(msgId, timeout);
        mRecallArgs[msgId][""] = "messagesSendBroadcast";
        mRecallArgs[msgId]["contacts"] = QVariant::fromValue<QList<InputUser>>(contacts);
        mRecallArgs[msgId]["random_id"] = QVariant::fromValue<QList<qint64>>(random_id);
        mRecallArgs[msgId]["message"] = QVariant::fromValue<QString>(message);
        mRecallArgs[msgId]["media"] = QVariant::fromValue<InputMedia>(media);
    } else {
        const UpdatesType &result = UpdatesType();
        if(callBack)
            callBack(0, result, apiError());
    }
    return msgId;
}

void TelegramCore::onMessagesSendBroadcastAnswer(qint64 msgId, const UpdatesType &result, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mRecallArgs.remove(msgId);
    callBackCall<UpdatesType >(msgId, result);
    stopTimeOut(msgId);
    Q_EMIT messagesSendBroadcastAnswer(msgId, result);
}

void TelegramCore::onMessagesSendBroadcastError(qint64 msgId, qint32 errorCode, const QString &errorText, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mRecallArgs.remove(msgId);
    const UpdatesType &result = UpdatesType();
    CallbackError error;
    error.errorCode = errorCode;
    error.errorText = errorText;
    error.null = false;
    callBackCall<UpdatesType >(msgId, result, error);
    stopTimeOut(msgId);
    Q_EMIT messagesSendBroadcastError(msgId, errorCode, errorText);
}

qint64 TelegramCore::messagesGetDhConfig(qint32 version, qint32 random_length, Callback<MessagesDhConfig > callBack, qint32 timeout) {
    if(!mApi) {
        const MessagesDhConfig &result = MessagesDhConfig();
        if(callBack)
            callBack(0, result, apiError());
        return 0;
    }
    qint64 msgId = mApi->messagesGetDhConfig(version, random_length);
    if(msgId) {
        callBackPush<MessagesDhConfig >(msgId, callBack);
        startTimeOut(msgId, timeout);
        mRecallArgs[msgId][""] = "messagesGetDhConfig";
        mRecallArgs[msgId]["version"] = QVariant::fromValue<qint32>(version);
        mRecallArgs[msgId]["random_length"] = QVariant::fromValue<qint32>(random_length);
    } else {
        const MessagesDhConfig &result = MessagesDhConfig();
        if(callBack)
            callBack(0, result, apiError());
    }
    return msgId;
}

void TelegramCore::onMessagesGetDhConfigAnswer(qint64 msgId, const MessagesDhConfig &result, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mRecallArgs.remove(msgId);
    callBackCall<MessagesDhConfig >(msgId, result);
    stopTimeOut(msgId);
    Q_EMIT messagesGetDhConfigAnswer(msgId, result);
}

void TelegramCore::onMessagesGetDhConfigError(qint64 msgId, qint32 errorCode, const QString &errorText, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mRecallArgs.remove(msgId);
    const MessagesDhConfig &result = MessagesDhConfig();
    CallbackError error;
    error.errorCode = errorCode;
    error.errorText = errorText;
    error.null = false;
    callBackCall<MessagesDhConfig >(msgId, result, error);
    stopTimeOut(msgId);
    Q_EMIT messagesGetDhConfigError(msgId, errorCode, errorText);
}

qint64 TelegramCore::messagesRequestEncryption(const InputUser &user_id, qint32 random_id, const QByteArray &g_a, Callback<EncryptedChat > callBack, qint32 timeout) {
    if(!mApi) {
        const EncryptedChat &result = EncryptedChat();
        if(callBack)
            callBack(0, result, apiError());
        return 0;
    }
    qint64 msgId = mApi->messagesRequestEncryption(user_id, random_id, g_a);
    if(msgId) {
        callBackPush<EncryptedChat >(msgId, callBack);
        startTimeOut(msgId, timeout);
        mRecallArgs[msgId][""] = "messagesRequestEncryption";
        mRecallArgs[msgId]["user_id"] = QVariant::fromValue<InputUser>(user_id);
        mRecallArgs[msgId]["random_id"] = QVariant::fromValue<qint32>(random_id);
        mRecallArgs[msgId]["g_a"] = QVariant::fromValue<QByteArray>(g_a);
    } else {
        const EncryptedChat &result = EncryptedChat();
        if(callBack)
            callBack(0, result, apiError());
    }
    return msgId;
}

void TelegramCore::onMessagesRequestEncryptionAnswer(qint64 msgId, const EncryptedChat &result, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mRecallArgs.remove(msgId);
    callBackCall<EncryptedChat >(msgId, result);
    stopTimeOut(msgId);
    Q_EMIT messagesRequestEncryptionAnswer(msgId, result);
}

void TelegramCore::onMessagesRequestEncryptionError(qint64 msgId, qint32 errorCode, const QString &errorText, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mRecallArgs.remove(msgId);
    const EncryptedChat &result = EncryptedChat();
    CallbackError error;
    error.errorCode = errorCode;
    error.errorText = errorText;
    error.null = false;
    callBackCall<EncryptedChat >(msgId, result, error);
    stopTimeOut(msgId);
    Q_EMIT messagesRequestEncryptionError(msgId, errorCode, errorText);
}

qint64 TelegramCore::messagesAcceptEncryption(const InputEncryptedChat &peer, const QByteArray &g_b, qint64 key_fingerprint, Callback<EncryptedChat > callBack, qint32 timeout) {
    if(!mApi) {
        const EncryptedChat &result = EncryptedChat();
        if(callBack)
            callBack(0, result, apiError());
        return 0;
    }
    qint64 msgId = mApi->messagesAcceptEncryption(peer, g_b, key_fingerprint);
    if(msgId) {
        callBackPush<EncryptedChat >(msgId, callBack);
        startTimeOut(msgId, timeout);
        mRecallArgs[msgId][""] = "messagesAcceptEncryption";
        mRecallArgs[msgId]["peer"] = QVariant::fromValue<InputEncryptedChat>(peer);
        mRecallArgs[msgId]["g_b"] = QVariant::fromValue<QByteArray>(g_b);
        mRecallArgs[msgId]["key_fingerprint"] = QVariant::fromValue<qint64>(key_fingerprint);
    } else {
        const EncryptedChat &result = EncryptedChat();
        if(callBack)
            callBack(0, result, apiError());
    }
    return msgId;
}

void TelegramCore::onMessagesAcceptEncryptionAnswer(qint64 msgId, const EncryptedChat &result, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mRecallArgs.remove(msgId);
    callBackCall<EncryptedChat >(msgId, result);
    stopTimeOut(msgId);
    Q_EMIT messagesAcceptEncryptionAnswer(msgId, result);
}

void TelegramCore::onMessagesAcceptEncryptionError(qint64 msgId, qint32 errorCode, const QString &errorText, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mRecallArgs.remove(msgId);
    const EncryptedChat &result = EncryptedChat();
    CallbackError error;
    error.errorCode = errorCode;
    error.errorText = errorText;
    error.null = false;
    callBackCall<EncryptedChat >(msgId, result, error);
    stopTimeOut(msgId);
    Q_EMIT messagesAcceptEncryptionError(msgId, errorCode, errorText);
}

qint64 TelegramCore::messagesDiscardEncryption(qint32 chat_id, Callback<bool > callBack, qint32 timeout) {
    if(!mApi) {
        bool result = 0;
        if(callBack)
            callBack(0, result, apiError());
        return 0;
    }
    qint64 msgId = mApi->messagesDiscardEncryption(chat_id);
    if(msgId) {
        callBackPush<bool >(msgId, callBack);
        startTimeOut(msgId, timeout);
        mRecallArgs[msgId][""] = "messagesDiscardEncryption";
        mRecallArgs[msgId]["chat_id"] = QVariant::fromValue<qint32>(chat_id);
    } else {
        bool result = 0;
        if(callBack)
            callBack(0, result, apiError());
    }
    return msgId;
}

void TelegramCore::onMessagesDiscardEncryptionAnswer(qint64 msgId, bool result, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mRecallArgs.remove(msgId);
    callBackCall<bool >(msgId, result);
    stopTimeOut(msgId);
    Q_EMIT messagesDiscardEncryptionAnswer(msgId, result);
}

void TelegramCore::onMessagesDiscardEncryptionError(qint64 msgId, qint32 errorCode, const QString &errorText, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mRecallArgs.remove(msgId);
    bool result = 0;
    CallbackError error;
    error.errorCode = errorCode;
    error.errorText = errorText;
    error.null = false;
    callBackCall<bool >(msgId, result, error);
    stopTimeOut(msgId);
    Q_EMIT messagesDiscardEncryptionError(msgId, errorCode, errorText);
}

qint64 TelegramCore::messagesSetEncryptedTyping(const InputEncryptedChat &peer, bool typing, Callback<bool > callBack, qint32 timeout) {
    if(!mApi) {
        bool result = 0;
        if(callBack)
            callBack(0, result, apiError());
        return 0;
    }
    qint64 msgId = mApi->messagesSetEncryptedTyping(peer, typing);
    if(msgId) {
        callBackPush<bool >(msgId, callBack);
        startTimeOut(msgId, timeout);
        mRecallArgs[msgId][""] = "messagesSetEncryptedTyping";
        mRecallArgs[msgId]["peer"] = QVariant::fromValue<InputEncryptedChat>(peer);
        mRecallArgs[msgId]["typing"] = QVariant::fromValue<bool>(typing);
    } else {
        bool result = 0;
        if(callBack)
            callBack(0, result, apiError());
    }
    return msgId;
}

void TelegramCore::onMessagesSetEncryptedTypingAnswer(qint64 msgId, bool result, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mRecallArgs.remove(msgId);
    callBackCall<bool >(msgId, result);
    stopTimeOut(msgId);
    Q_EMIT messagesSetEncryptedTypingAnswer(msgId, result);
}

void TelegramCore::onMessagesSetEncryptedTypingError(qint64 msgId, qint32 errorCode, const QString &errorText, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mRecallArgs.remove(msgId);
    bool result = 0;
    CallbackError error;
    error.errorCode = errorCode;
    error.errorText = errorText;
    error.null = false;
    callBackCall<bool >(msgId, result, error);
    stopTimeOut(msgId);
    Q_EMIT messagesSetEncryptedTypingError(msgId, errorCode, errorText);
}

qint64 TelegramCore::messagesReadEncryptedHistory(const InputEncryptedChat &peer, qint32 max_date, Callback<bool > callBack, qint32 timeout) {
    if(!mApi) {
        bool result = 0;
        if(callBack)
            callBack(0, result, apiError());
        return 0;
    }
    qint64 msgId = mApi->messagesReadEncryptedHistory(peer, max_date);
    if(msgId) {
        callBackPush<bool >(msgId, callBack);
        startTimeOut(msgId, timeout);
        mRecallArgs[msgId][""] = "messagesReadEncryptedHistory";
        mRecallArgs[msgId]["peer"] = QVariant::fromValue<InputEncryptedChat>(peer);
        mRecallArgs[msgId]["max_date"] = QVariant::fromValue<qint32>(max_date);
    } else {
        bool result = 0;
        if(callBack)
            callBack(0, result, apiError());
    }
    return msgId;
}

void TelegramCore::onMessagesReadEncryptedHistoryAnswer(qint64 msgId, bool result, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mRecallArgs.remove(msgId);
    callBackCall<bool >(msgId, result);
    stopTimeOut(msgId);
    Q_EMIT messagesReadEncryptedHistoryAnswer(msgId, result);
}

void TelegramCore::onMessagesReadEncryptedHistoryError(qint64 msgId, qint32 errorCode, const QString &errorText, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mRecallArgs.remove(msgId);
    bool result = 0;
    CallbackError error;
    error.errorCode = errorCode;
    error.errorText = errorText;
    error.null = false;
    callBackCall<bool >(msgId, result, error);
    stopTimeOut(msgId);
    Q_EMIT messagesReadEncryptedHistoryError(msgId, errorCode, errorText);
}

qint64 TelegramCore::messagesSendEncrypted(const InputEncryptedChat &peer, qint64 random_id, const QByteArray &data, Callback<MessagesSentEncryptedMessage > callBack, qint32 timeout) {
    if(!mApi) {
        const MessagesSentEncryptedMessage &result = MessagesSentEncryptedMessage();
        if(callBack)
            callBack(0, result, apiError());
        return 0;
    }
    qint64 msgId = mApi->messagesSendEncrypted(peer, random_id, data);
    if(msgId) {
        callBackPush<MessagesSentEncryptedMessage >(msgId, callBack);
        startTimeOut(msgId, timeout);
        mRecallArgs[msgId][""] = "messagesSendEncrypted";
        mRecallArgs[msgId]["peer"] = QVariant::fromValue<InputEncryptedChat>(peer);
        mRecallArgs[msgId]["random_id"] = QVariant::fromValue<qint64>(random_id);
        mRecallArgs[msgId]["data"] = QVariant::fromValue<QByteArray>(data);
    } else {
        const MessagesSentEncryptedMessage &result = MessagesSentEncryptedMessage();
        if(callBack)
            callBack(0, result, apiError());
    }
    return msgId;
}

void TelegramCore::onMessagesSendEncryptedAnswer(qint64 msgId, const MessagesSentEncryptedMessage &result, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mRecallArgs.remove(msgId);
    callBackCall<MessagesSentEncryptedMessage >(msgId, result);
    stopTimeOut(msgId);
    Q_EMIT messagesSendEncryptedAnswer(msgId, result);
}

void TelegramCore::onMessagesSendEncryptedError(qint64 msgId, qint32 errorCode, const QString &errorText, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mRecallArgs.remove(msgId);
    const MessagesSentEncryptedMessage &result = MessagesSentEncryptedMessage();
    CallbackError error;
    error.errorCode = errorCode;
    error.errorText = errorText;
    error.null = false;
    callBackCall<MessagesSentEncryptedMessage >(msgId, result, error);
    stopTimeOut(msgId);
    Q_EMIT messagesSendEncryptedError(msgId, errorCode, errorText);
}

qint64 TelegramCore::messagesSendEncryptedFile(const InputEncryptedChat &peer, qint64 random_id, const QByteArray &data, const InputEncryptedFile &file, Callback<MessagesSentEncryptedMessage > callBack, qint32 timeout) {
    if(!mApi) {
        const MessagesSentEncryptedMessage &result = MessagesSentEncryptedMessage();
        if(callBack)
            callBack(0, result, apiError());
        return 0;
    }
    qint64 msgId = mApi->messagesSendEncryptedFile(peer, random_id, data, file);
    if(msgId) {
        callBackPush<MessagesSentEncryptedMessage >(msgId, callBack);
        startTimeOut(msgId, timeout);
        mRecallArgs[msgId][""] = "messagesSendEncryptedFile";
        mRecallArgs[msgId]["peer"] = QVariant::fromValue<InputEncryptedChat>(peer);
        mRecallArgs[msgId]["random_id"] = QVariant::fromValue<qint64>(random_id);
        mRecallArgs[msgId]["data"] = QVariant::fromValue<QByteArray>(data);
        mRecallArgs[msgId]["file"] = QVariant::fromValue<InputEncryptedFile>(file);
    } else {
        const MessagesSentEncryptedMessage &result = MessagesSentEncryptedMessage();
        if(callBack)
            callBack(0, result, apiError());
    }
    return msgId;
}

void TelegramCore::onMessagesSendEncryptedFileAnswer(qint64 msgId, const MessagesSentEncryptedMessage &result, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mRecallArgs.remove(msgId);
    callBackCall<MessagesSentEncryptedMessage >(msgId, result);
    stopTimeOut(msgId);
    Q_EMIT messagesSendEncryptedFileAnswer(msgId, result);
}

void TelegramCore::onMessagesSendEncryptedFileError(qint64 msgId, qint32 errorCode, const QString &errorText, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mRecallArgs.remove(msgId);
    const MessagesSentEncryptedMessage &result = MessagesSentEncryptedMessage();
    CallbackError error;
    error.errorCode = errorCode;
    error.errorText = errorText;
    error.null = false;
    callBackCall<MessagesSentEncryptedMessage >(msgId, result, error);
    stopTimeOut(msgId);
    Q_EMIT messagesSendEncryptedFileError(msgId, errorCode, errorText);
}

qint64 TelegramCore::messagesSendEncryptedService(const InputEncryptedChat &peer, qint64 random_id, const QByteArray &data, Callback<MessagesSentEncryptedMessage > callBack, qint32 timeout) {
    if(!mApi) {
        const MessagesSentEncryptedMessage &result = MessagesSentEncryptedMessage();
        if(callBack)
            callBack(0, result, apiError());
        return 0;
    }
    qint64 msgId = mApi->messagesSendEncryptedService(peer, random_id, data);
    if(msgId) {
        callBackPush<MessagesSentEncryptedMessage >(msgId, callBack);
        startTimeOut(msgId, timeout);
        mRecallArgs[msgId][""] = "messagesSendEncryptedService";
        mRecallArgs[msgId]["peer"] = QVariant::fromValue<InputEncryptedChat>(peer);
        mRecallArgs[msgId]["random_id"] = QVariant::fromValue<qint64>(random_id);
        mRecallArgs[msgId]["data"] = QVariant::fromValue<QByteArray>(data);
    } else {
        const MessagesSentEncryptedMessage &result = MessagesSentEncryptedMessage();
        if(callBack)
            callBack(0, result, apiError());
    }
    return msgId;
}

void TelegramCore::onMessagesSendEncryptedServiceAnswer(qint64 msgId, const MessagesSentEncryptedMessage &result, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mRecallArgs.remove(msgId);
    callBackCall<MessagesSentEncryptedMessage >(msgId, result);
    stopTimeOut(msgId);
    Q_EMIT messagesSendEncryptedServiceAnswer(msgId, result);
}

void TelegramCore::onMessagesSendEncryptedServiceError(qint64 msgId, qint32 errorCode, const QString &errorText, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mRecallArgs.remove(msgId);
    const MessagesSentEncryptedMessage &result = MessagesSentEncryptedMessage();
    CallbackError error;
    error.errorCode = errorCode;
    error.errorText = errorText;
    error.null = false;
    callBackCall<MessagesSentEncryptedMessage >(msgId, result, error);
    stopTimeOut(msgId);
    Q_EMIT messagesSendEncryptedServiceError(msgId, errorCode, errorText);
}

qint64 TelegramCore::messagesReceivedQueue(qint32 max_qts, Callback<QList<qint64> > callBack, qint32 timeout) {
    if(!mApi) {
        const QList<qint64> &result = QList<qint64>();
        if(callBack)
            callBack(0, result, apiError());
        return 0;
    }
    qint64 msgId = mApi->messagesReceivedQueue(max_qts);
    if(msgId) {
        callBackPush<QList<qint64> >(msgId, callBack);
        startTimeOut(msgId, timeout);
        mRecallArgs[msgId][""] = "messagesReceivedQueue";
        mRecallArgs[msgId]["max_qts"] = QVariant::fromValue<qint32>(max_qts);
    } else {
        const QList<qint64> &result = QList<qint64>();
        if(callBack)
            callBack(0, result, apiError());
    }
    return msgId;
}

void TelegramCore::onMessagesReceivedQueueAnswer(qint64 msgId, const QList<qint64> &result, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mRecallArgs.remove(msgId);
    callBackCall<QList<qint64> >(msgId, result);
    stopTimeOut(msgId);
    Q_EMIT messagesReceivedQueueAnswer(msgId, result);
}

void TelegramCore::onMessagesReceivedQueueError(qint64 msgId, qint32 errorCode, const QString &errorText, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mRecallArgs.remove(msgId);
    const QList<qint64> &result = QList<qint64>();
    CallbackError error;
    error.errorCode = errorCode;
    error.errorText = errorText;
    error.null = false;
    callBackCall<QList<qint64> >(msgId, result, error);
    stopTimeOut(msgId);
    Q_EMIT messagesReceivedQueueError(msgId, errorCode, errorText);
}

qint64 TelegramCore::messagesReadMessageContents(const QList<qint32> &id, Callback<MessagesAffectedMessages > callBack, qint32 timeout) {
    if(!mApi) {
        const MessagesAffectedMessages &result = MessagesAffectedMessages();
        if(callBack)
            callBack(0, result, apiError());
        return 0;
    }
    qint64 msgId = mApi->messagesReadMessageContents(id);
    if(msgId) {
        callBackPush<MessagesAffectedMessages >(msgId, callBack);
        startTimeOut(msgId, timeout);
        mRecallArgs[msgId][""] = "messagesReadMessageContents";
        mRecallArgs[msgId]["id"] = QVariant::fromValue<QList<qint32>>(id);
    } else {
        const MessagesAffectedMessages &result = MessagesAffectedMessages();
        if(callBack)
            callBack(0, result, apiError());
    }
    return msgId;
}

void TelegramCore::onMessagesReadMessageContentsAnswer(qint64 msgId, const MessagesAffectedMessages &result, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mRecallArgs.remove(msgId);
    callBackCall<MessagesAffectedMessages >(msgId, result);
    stopTimeOut(msgId);
    Q_EMIT messagesReadMessageContentsAnswer(msgId, result);
}

void TelegramCore::onMessagesReadMessageContentsError(qint64 msgId, qint32 errorCode, const QString &errorText, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mRecallArgs.remove(msgId);
    const MessagesAffectedMessages &result = MessagesAffectedMessages();
    CallbackError error;
    error.errorCode = errorCode;
    error.errorText = errorText;
    error.null = false;
    callBackCall<MessagesAffectedMessages >(msgId, result, error);
    stopTimeOut(msgId);
    Q_EMIT messagesReadMessageContentsError(msgId, errorCode, errorText);
}

qint64 TelegramCore::messagesGetStickers(const QString &emoticon, const QString &hash, Callback<MessagesStickers > callBack, qint32 timeout) {
    if(!mApi) {
        const MessagesStickers &result = MessagesStickers();
        if(callBack)
            callBack(0, result, apiError());
        return 0;
    }
    qint64 msgId = mApi->messagesGetStickers(emoticon, hash);
    if(msgId) {
        callBackPush<MessagesStickers >(msgId, callBack);
        startTimeOut(msgId, timeout);
        mRecallArgs[msgId][""] = "messagesGetStickers";
        mRecallArgs[msgId]["emoticon"] = QVariant::fromValue<QString>(emoticon);
        mRecallArgs[msgId]["hash"] = QVariant::fromValue<QString>(hash);
    } else {
        const MessagesStickers &result = MessagesStickers();
        if(callBack)
            callBack(0, result, apiError());
    }
    return msgId;
}

void TelegramCore::onMessagesGetStickersAnswer(qint64 msgId, const MessagesStickers &result, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mRecallArgs.remove(msgId);
    callBackCall<MessagesStickers >(msgId, result);
    stopTimeOut(msgId);
    Q_EMIT messagesGetStickersAnswer(msgId, result);
}

void TelegramCore::onMessagesGetStickersError(qint64 msgId, qint32 errorCode, const QString &errorText, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mRecallArgs.remove(msgId);
    const MessagesStickers &result = MessagesStickers();
    CallbackError error;
    error.errorCode = errorCode;
    error.errorText = errorText;
    error.null = false;
    callBackCall<MessagesStickers >(msgId, result, error);
    stopTimeOut(msgId);
    Q_EMIT messagesGetStickersError(msgId, errorCode, errorText);
}

qint64 TelegramCore::messagesGetAllStickers(qint32 hash, Callback<MessagesAllStickers > callBack, qint32 timeout) {
    if(!mApi) {
        const MessagesAllStickers &result = MessagesAllStickers();
        if(callBack)
            callBack(0, result, apiError());
        return 0;
    }
    qint64 msgId = mApi->messagesGetAllStickers(hash);
    if(msgId) {
        callBackPush<MessagesAllStickers >(msgId, callBack);
        startTimeOut(msgId, timeout);
        mRecallArgs[msgId][""] = "messagesGetAllStickers";
        mRecallArgs[msgId]["hash"] = QVariant::fromValue<qint32>(hash);
    } else {
        const MessagesAllStickers &result = MessagesAllStickers();
        if(callBack)
            callBack(0, result, apiError());
    }
    return msgId;
}

void TelegramCore::onMessagesGetAllStickersAnswer(qint64 msgId, const MessagesAllStickers &result, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mRecallArgs.remove(msgId);
    callBackCall<MessagesAllStickers >(msgId, result);
    stopTimeOut(msgId);
    Q_EMIT messagesGetAllStickersAnswer(msgId, result);
}

void TelegramCore::onMessagesGetAllStickersError(qint64 msgId, qint32 errorCode, const QString &errorText, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mRecallArgs.remove(msgId);
    const MessagesAllStickers &result = MessagesAllStickers();
    CallbackError error;
    error.errorCode = errorCode;
    error.errorText = errorText;
    error.null = false;
    callBackCall<MessagesAllStickers >(msgId, result, error);
    stopTimeOut(msgId);
    Q_EMIT messagesGetAllStickersError(msgId, errorCode, errorText);
}

qint64 TelegramCore::messagesGetWebPagePreview(const QString &message, Callback<MessageMedia > callBack, qint32 timeout) {
    if(!mApi) {
        const MessageMedia &result = MessageMedia();
        if(callBack)
            callBack(0, result, apiError());
        return 0;
    }
    qint64 msgId = mApi->messagesGetWebPagePreview(message);
    if(msgId) {
        callBackPush<MessageMedia >(msgId, callBack);
        startTimeOut(msgId, timeout);
        mRecallArgs[msgId][""] = "messagesGetWebPagePreview";
        mRecallArgs[msgId]["message"] = QVariant::fromValue<QString>(message);
    } else {
        const MessageMedia &result = MessageMedia();
        if(callBack)
            callBack(0, result, apiError());
    }
    return msgId;
}

void TelegramCore::onMessagesGetWebPagePreviewAnswer(qint64 msgId, const MessageMedia &result, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mRecallArgs.remove(msgId);
    callBackCall<MessageMedia >(msgId, result);
    stopTimeOut(msgId);
    Q_EMIT messagesGetWebPagePreviewAnswer(msgId, result);
}

void TelegramCore::onMessagesGetWebPagePreviewError(qint64 msgId, qint32 errorCode, const QString &errorText, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mRecallArgs.remove(msgId);
    const MessageMedia &result = MessageMedia();
    CallbackError error;
    error.errorCode = errorCode;
    error.errorText = errorText;
    error.null = false;
    callBackCall<MessageMedia >(msgId, result, error);
    stopTimeOut(msgId);
    Q_EMIT messagesGetWebPagePreviewError(msgId, errorCode, errorText);
}

qint64 TelegramCore::messagesExportChatInvite(qint32 chat_id, Callback<ExportedChatInvite > callBack, qint32 timeout) {
    if(!mApi) {
        const ExportedChatInvite &result = ExportedChatInvite();
        if(callBack)
            callBack(0, result, apiError());
        return 0;
    }
    qint64 msgId = mApi->messagesExportChatInvite(chat_id);
    if(msgId) {
        callBackPush<ExportedChatInvite >(msgId, callBack);
        startTimeOut(msgId, timeout);
        mRecallArgs[msgId][""] = "messagesExportChatInvite";
        mRecallArgs[msgId]["chat_id"] = QVariant::fromValue<qint32>(chat_id);
    } else {
        const ExportedChatInvite &result = ExportedChatInvite();
        if(callBack)
            callBack(0, result, apiError());
    }
    return msgId;
}

void TelegramCore::onMessagesExportChatInviteAnswer(qint64 msgId, const ExportedChatInvite &result, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mRecallArgs.remove(msgId);
    callBackCall<ExportedChatInvite >(msgId, result);
    stopTimeOut(msgId);
    Q_EMIT messagesExportChatInviteAnswer(msgId, result);
}

void TelegramCore::onMessagesExportChatInviteError(qint64 msgId, qint32 errorCode, const QString &errorText, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mRecallArgs.remove(msgId);
    const ExportedChatInvite &result = ExportedChatInvite();
    CallbackError error;
    error.errorCode = errorCode;
    error.errorText = errorText;
    error.null = false;
    callBackCall<ExportedChatInvite >(msgId, result, error);
    stopTimeOut(msgId);
    Q_EMIT messagesExportChatInviteError(msgId, errorCode, errorText);
}

qint64 TelegramCore::messagesCheckChatInvite(const QString &hash, Callback<ChatInvite > callBack, qint32 timeout) {
    if(!mApi) {
        const ChatInvite &result = ChatInvite();
        if(callBack)
            callBack(0, result, apiError());
        return 0;
    }
    qint64 msgId = mApi->messagesCheckChatInvite(hash);
    if(msgId) {
        callBackPush<ChatInvite >(msgId, callBack);
        startTimeOut(msgId, timeout);
        mRecallArgs[msgId][""] = "messagesCheckChatInvite";
        mRecallArgs[msgId]["hash"] = QVariant::fromValue<QString>(hash);
    } else {
        const ChatInvite &result = ChatInvite();
        if(callBack)
            callBack(0, result, apiError());
    }
    return msgId;
}

void TelegramCore::onMessagesCheckChatInviteAnswer(qint64 msgId, const ChatInvite &result, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mRecallArgs.remove(msgId);
    callBackCall<ChatInvite >(msgId, result);
    stopTimeOut(msgId);
    Q_EMIT messagesCheckChatInviteAnswer(msgId, result);
}

void TelegramCore::onMessagesCheckChatInviteError(qint64 msgId, qint32 errorCode, const QString &errorText, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mRecallArgs.remove(msgId);
    const ChatInvite &result = ChatInvite();
    CallbackError error;
    error.errorCode = errorCode;
    error.errorText = errorText;
    error.null = false;
    callBackCall<ChatInvite >(msgId, result, error);
    stopTimeOut(msgId);
    Q_EMIT messagesCheckChatInviteError(msgId, errorCode, errorText);
}

qint64 TelegramCore::messagesImportChatInvite(const QString &hash, Callback<UpdatesType > callBack, qint32 timeout) {
    if(!mApi) {
        const UpdatesType &result = UpdatesType();
        if(callBack)
            callBack(0, result, apiError());
        return 0;
    }
    qint64 msgId = mApi->messagesImportChatInvite(hash);
    if(msgId) {
        callBackPush<UpdatesType >(msgId, callBack);
        startTimeOut(msgId, timeout);
        mRecallArgs[msgId][""] = "messagesImportChatInvite";
        mRecallArgs[msgId]["hash"] = QVariant::fromValue<QString>(hash);
    } else {
        const UpdatesType &result = UpdatesType();
        if(callBack)
            callBack(0, result, apiError());
    }
    return msgId;
}

void TelegramCore::onMessagesImportChatInviteAnswer(qint64 msgId, const UpdatesType &result, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mRecallArgs.remove(msgId);
    callBackCall<UpdatesType >(msgId, result);
    stopTimeOut(msgId);
    Q_EMIT messagesImportChatInviteAnswer(msgId, result);
}

void TelegramCore::onMessagesImportChatInviteError(qint64 msgId, qint32 errorCode, const QString &errorText, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mRecallArgs.remove(msgId);
    const UpdatesType &result = UpdatesType();
    CallbackError error;
    error.errorCode = errorCode;
    error.errorText = errorText;
    error.null = false;
    callBackCall<UpdatesType >(msgId, result, error);
    stopTimeOut(msgId);
    Q_EMIT messagesImportChatInviteError(msgId, errorCode, errorText);
}

qint64 TelegramCore::messagesGetStickerSet(const InputStickerSet &stickerset, Callback<MessagesStickerSet > callBack, qint32 timeout) {
    if(!mApi) {
        const MessagesStickerSet &result = MessagesStickerSet();
        if(callBack)
            callBack(0, result, apiError());
        return 0;
    }
    qint64 msgId = mApi->messagesGetStickerSet(stickerset);
    if(msgId) {
        callBackPush<MessagesStickerSet >(msgId, callBack);
        startTimeOut(msgId, timeout);
        mRecallArgs[msgId][""] = "messagesGetStickerSet";
        mRecallArgs[msgId]["stickerset"] = QVariant::fromValue<InputStickerSet>(stickerset);
    } else {
        const MessagesStickerSet &result = MessagesStickerSet();
        if(callBack)
            callBack(0, result, apiError());
    }
    return msgId;
}

void TelegramCore::onMessagesGetStickerSetAnswer(qint64 msgId, const MessagesStickerSet &result, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mRecallArgs.remove(msgId);
    callBackCall<MessagesStickerSet >(msgId, result);
    stopTimeOut(msgId);
    Q_EMIT messagesGetStickerSetAnswer(msgId, result);
}

void TelegramCore::onMessagesGetStickerSetError(qint64 msgId, qint32 errorCode, const QString &errorText, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mRecallArgs.remove(msgId);
    const MessagesStickerSet &result = MessagesStickerSet();
    CallbackError error;
    error.errorCode = errorCode;
    error.errorText = errorText;
    error.null = false;
    callBackCall<MessagesStickerSet >(msgId, result, error);
    stopTimeOut(msgId);
    Q_EMIT messagesGetStickerSetError(msgId, errorCode, errorText);
}

qint64 TelegramCore::messagesInstallStickerSet(const InputStickerSet &stickerset, bool disabled, Callback<bool > callBack, qint32 timeout) {
    if(!mApi) {
        bool result = 0;
        if(callBack)
            callBack(0, result, apiError());
        return 0;
    }
    qint64 msgId = mApi->messagesInstallStickerSet(stickerset, disabled);
    if(msgId) {
        callBackPush<bool >(msgId, callBack);
        startTimeOut(msgId, timeout);
        mRecallArgs[msgId][""] = "messagesInstallStickerSet";
        mRecallArgs[msgId]["stickerset"] = QVariant::fromValue<InputStickerSet>(stickerset);
        mRecallArgs[msgId]["disabled"] = QVariant::fromValue<bool>(disabled);
    } else {
        bool result = 0;
        if(callBack)
            callBack(0, result, apiError());
    }
    return msgId;
}

void TelegramCore::onMessagesInstallStickerSetAnswer(qint64 msgId, bool result, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mRecallArgs.remove(msgId);
    callBackCall<bool >(msgId, result);
    stopTimeOut(msgId);
    Q_EMIT messagesInstallStickerSetAnswer(msgId, result);
}

void TelegramCore::onMessagesInstallStickerSetError(qint64 msgId, qint32 errorCode, const QString &errorText, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mRecallArgs.remove(msgId);
    bool result = 0;
    CallbackError error;
    error.errorCode = errorCode;
    error.errorText = errorText;
    error.null = false;
    callBackCall<bool >(msgId, result, error);
    stopTimeOut(msgId);
    Q_EMIT messagesInstallStickerSetError(msgId, errorCode, errorText);
}

qint64 TelegramCore::messagesUninstallStickerSet(const InputStickerSet &stickerset, Callback<bool > callBack, qint32 timeout) {
    if(!mApi) {
        bool result = 0;
        if(callBack)
            callBack(0, result, apiError());
        return 0;
    }
    qint64 msgId = mApi->messagesUninstallStickerSet(stickerset);
    if(msgId) {
        callBackPush<bool >(msgId, callBack);
        startTimeOut(msgId, timeout);
        mRecallArgs[msgId][""] = "messagesUninstallStickerSet";
        mRecallArgs[msgId]["stickerset"] = QVariant::fromValue<InputStickerSet>(stickerset);
    } else {
        bool result = 0;
        if(callBack)
            callBack(0, result, apiError());
    }
    return msgId;
}

void TelegramCore::onMessagesUninstallStickerSetAnswer(qint64 msgId, bool result, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mRecallArgs.remove(msgId);
    callBackCall<bool >(msgId, result);
    stopTimeOut(msgId);
    Q_EMIT messagesUninstallStickerSetAnswer(msgId, result);
}

void TelegramCore::onMessagesUninstallStickerSetError(qint64 msgId, qint32 errorCode, const QString &errorText, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mRecallArgs.remove(msgId);
    bool result = 0;
    CallbackError error;
    error.errorCode = errorCode;
    error.errorText = errorText;
    error.null = false;
    callBackCall<bool >(msgId, result, error);
    stopTimeOut(msgId);
    Q_EMIT messagesUninstallStickerSetError(msgId, errorCode, errorText);
}

qint64 TelegramCore::messagesStartBot(const InputUser &bot, const InputPeer &peer, qint64 random_id, const QString &start_param, Callback<UpdatesType > callBack, qint32 timeout) {
    if(!mApi) {
        const UpdatesType &result = UpdatesType();
        if(callBack)
            callBack(0, result, apiError());
        return 0;
    }
    qint64 msgId = mApi->messagesStartBot(bot, peer, random_id, start_param);
    if(msgId) {
        callBackPush<UpdatesType >(msgId, callBack);
        startTimeOut(msgId, timeout);
        mRecallArgs[msgId][""] = "messagesStartBot";
        mRecallArgs[msgId]["bot"] = QVariant::fromValue<InputUser>(bot);
        mRecallArgs[msgId]["peer"] = QVariant::fromValue<InputPeer>(peer);
        mRecallArgs[msgId]["random_id"] = QVariant::fromValue<qint64>(random_id);
        mRecallArgs[msgId]["start_param"] = QVariant::fromValue<QString>(start_param);
    } else {
        const UpdatesType &result = UpdatesType();
        if(callBack)
            callBack(0, result, apiError());
    }
    return msgId;
}

void TelegramCore::onMessagesStartBotAnswer(qint64 msgId, const UpdatesType &result, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mRecallArgs.remove(msgId);
    callBackCall<UpdatesType >(msgId, result);
    stopTimeOut(msgId);
    Q_EMIT messagesStartBotAnswer(msgId, result);
}

void TelegramCore::onMessagesStartBotError(qint64 msgId, qint32 errorCode, const QString &errorText, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mRecallArgs.remove(msgId);
    const UpdatesType &result = UpdatesType();
    CallbackError error;
    error.errorCode = errorCode;
    error.errorText = errorText;
    error.null = false;
    callBackCall<UpdatesType >(msgId, result, error);
    stopTimeOut(msgId);
    Q_EMIT messagesStartBotError(msgId, errorCode, errorText);
}

qint64 TelegramCore::messagesGetMessagesViews(const InputPeer &peer, const QList<qint32> &id, bool increment, Callback<QList<qint32> > callBack, qint32 timeout) {
    if(!mApi) {
        const QList<qint32> &result = QList<qint32>();
        if(callBack)
            callBack(0, result, apiError());
        return 0;
    }
    qint64 msgId = mApi->messagesGetMessagesViews(peer, id, increment);
    if(msgId) {
        callBackPush<QList<qint32> >(msgId, callBack);
        startTimeOut(msgId, timeout);
        mRecallArgs[msgId][""] = "messagesGetMessagesViews";
        mRecallArgs[msgId]["peer"] = QVariant::fromValue<InputPeer>(peer);
        mRecallArgs[msgId]["id"] = QVariant::fromValue<QList<qint32>>(id);
        mRecallArgs[msgId]["increment"] = QVariant::fromValue<bool>(increment);
    } else {
        const QList<qint32> &result = QList<qint32>();
        if(callBack)
            callBack(0, result, apiError());
    }
    return msgId;
}

void TelegramCore::onMessagesGetMessagesViewsAnswer(qint64 msgId, const QList<qint32> &result, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mRecallArgs.remove(msgId);
    callBackCall<QList<qint32> >(msgId, result);
    stopTimeOut(msgId);
    Q_EMIT messagesGetMessagesViewsAnswer(msgId, result);
}

void TelegramCore::onMessagesGetMessagesViewsError(qint64 msgId, qint32 errorCode, const QString &errorText, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mRecallArgs.remove(msgId);
    const QList<qint32> &result = QList<qint32>();
    CallbackError error;
    error.errorCode = errorCode;
    error.errorText = errorText;
    error.null = false;
    callBackCall<QList<qint32> >(msgId, result, error);
    stopTimeOut(msgId);
    Q_EMIT messagesGetMessagesViewsError(msgId, errorCode, errorText);
}

qint64 TelegramCore::messagesToggleChatAdmins(qint32 chat_id, bool enabled, Callback<UpdatesType > callBack, qint32 timeout) {
    if(!mApi) {
        const UpdatesType &result = UpdatesType();
        if(callBack)
            callBack(0, result, apiError());
        return 0;
    }
    qint64 msgId = mApi->messagesToggleChatAdmins(chat_id, enabled);
    if(msgId) {
        callBackPush<UpdatesType >(msgId, callBack);
        startTimeOut(msgId, timeout);
        mRecallArgs[msgId][""] = "messagesToggleChatAdmins";
        mRecallArgs[msgId]["chat_id"] = QVariant::fromValue<qint32>(chat_id);
        mRecallArgs[msgId]["enabled"] = QVariant::fromValue<bool>(enabled);
    } else {
        const UpdatesType &result = UpdatesType();
        if(callBack)
            callBack(0, result, apiError());
    }
    return msgId;
}

void TelegramCore::onMessagesToggleChatAdminsAnswer(qint64 msgId, const UpdatesType &result, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mRecallArgs.remove(msgId);
    callBackCall<UpdatesType >(msgId, result);
    stopTimeOut(msgId);
    Q_EMIT messagesToggleChatAdminsAnswer(msgId, result);
}

void TelegramCore::onMessagesToggleChatAdminsError(qint64 msgId, qint32 errorCode, const QString &errorText, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mRecallArgs.remove(msgId);
    const UpdatesType &result = UpdatesType();
    CallbackError error;
    error.errorCode = errorCode;
    error.errorText = errorText;
    error.null = false;
    callBackCall<UpdatesType >(msgId, result, error);
    stopTimeOut(msgId);
    Q_EMIT messagesToggleChatAdminsError(msgId, errorCode, errorText);
}

qint64 TelegramCore::messagesEditChatAdmin(qint32 chat_id, const InputUser &user_id, bool is_admin, Callback<bool > callBack, qint32 timeout) {
    if(!mApi) {
        bool result = 0;
        if(callBack)
            callBack(0, result, apiError());
        return 0;
    }
    qint64 msgId = mApi->messagesEditChatAdmin(chat_id, user_id, is_admin);
    if(msgId) {
        callBackPush<bool >(msgId, callBack);
        startTimeOut(msgId, timeout);
        mRecallArgs[msgId][""] = "messagesEditChatAdmin";
        mRecallArgs[msgId]["chat_id"] = QVariant::fromValue<qint32>(chat_id);
        mRecallArgs[msgId]["user_id"] = QVariant::fromValue<InputUser>(user_id);
        mRecallArgs[msgId]["is_admin"] = QVariant::fromValue<bool>(is_admin);
    } else {
        bool result = 0;
        if(callBack)
            callBack(0, result, apiError());
    }
    return msgId;
}

void TelegramCore::onMessagesEditChatAdminAnswer(qint64 msgId, bool result, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mRecallArgs.remove(msgId);
    callBackCall<bool >(msgId, result);
    stopTimeOut(msgId);
    Q_EMIT messagesEditChatAdminAnswer(msgId, result);
}

void TelegramCore::onMessagesEditChatAdminError(qint64 msgId, qint32 errorCode, const QString &errorText, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mRecallArgs.remove(msgId);
    bool result = 0;
    CallbackError error;
    error.errorCode = errorCode;
    error.errorText = errorText;
    error.null = false;
    callBackCall<bool >(msgId, result, error);
    stopTimeOut(msgId);
    Q_EMIT messagesEditChatAdminError(msgId, errorCode, errorText);
}

qint64 TelegramCore::messagesMigrateChat(qint32 chat_id, Callback<UpdatesType > callBack, qint32 timeout) {
    if(!mApi) {
        const UpdatesType &result = UpdatesType();
        if(callBack)
            callBack(0, result, apiError());
        return 0;
    }
    qint64 msgId = mApi->messagesMigrateChat(chat_id);
    if(msgId) {
        callBackPush<UpdatesType >(msgId, callBack);
        startTimeOut(msgId, timeout);
        mRecallArgs[msgId][""] = "messagesMigrateChat";
        mRecallArgs[msgId]["chat_id"] = QVariant::fromValue<qint32>(chat_id);
    } else {
        const UpdatesType &result = UpdatesType();
        if(callBack)
            callBack(0, result, apiError());
    }
    return msgId;
}

void TelegramCore::onMessagesMigrateChatAnswer(qint64 msgId, const UpdatesType &result, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mRecallArgs.remove(msgId);
    callBackCall<UpdatesType >(msgId, result);
    stopTimeOut(msgId);
    Q_EMIT messagesMigrateChatAnswer(msgId, result);
}

void TelegramCore::onMessagesMigrateChatError(qint64 msgId, qint32 errorCode, const QString &errorText, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mRecallArgs.remove(msgId);
    const UpdatesType &result = UpdatesType();
    CallbackError error;
    error.errorCode = errorCode;
    error.errorText = errorText;
    error.null = false;
    callBackCall<UpdatesType >(msgId, result, error);
    stopTimeOut(msgId);
    Q_EMIT messagesMigrateChatError(msgId, errorCode, errorText);
}

qint64 TelegramCore::messagesSearchGlobal(const QString &q, qint32 offset_date, const InputPeer &offset_peer, qint32 offset_id, qint32 limit, Callback<MessagesMessages > callBack, qint32 timeout) {
    if(!mApi) {
        const MessagesMessages &result = MessagesMessages();
        if(callBack)
            callBack(0, result, apiError());
        return 0;
    }
    qint64 msgId = mApi->messagesSearchGlobal(q, offset_date, offset_peer, offset_id, limit);
    if(msgId) {
        callBackPush<MessagesMessages >(msgId, callBack);
        startTimeOut(msgId, timeout);
        mRecallArgs[msgId][""] = "messagesSearchGlobal";
        mRecallArgs[msgId]["q"] = QVariant::fromValue<QString>(q);
        mRecallArgs[msgId]["offset_date"] = QVariant::fromValue<qint32>(offset_date);
        mRecallArgs[msgId]["offset_peer"] = QVariant::fromValue<InputPeer>(offset_peer);
        mRecallArgs[msgId]["offset_id"] = QVariant::fromValue<qint32>(offset_id);
        mRecallArgs[msgId]["limit"] = QVariant::fromValue<qint32>(limit);
    } else {
        const MessagesMessages &result = MessagesMessages();
        if(callBack)
            callBack(0, result, apiError());
    }
    return msgId;
}

void TelegramCore::onMessagesSearchGlobalAnswer(qint64 msgId, const MessagesMessages &result, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mRecallArgs.remove(msgId);
    callBackCall<MessagesMessages >(msgId, result);
    stopTimeOut(msgId);
    Q_EMIT messagesSearchGlobalAnswer(msgId, result);
}

void TelegramCore::onMessagesSearchGlobalError(qint64 msgId, qint32 errorCode, const QString &errorText, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mRecallArgs.remove(msgId);
    const MessagesMessages &result = MessagesMessages();
    CallbackError error;
    error.errorCode = errorCode;
    error.errorText = errorText;
    error.null = false;
    callBackCall<MessagesMessages >(msgId, result, error);
    stopTimeOut(msgId);
    Q_EMIT messagesSearchGlobalError(msgId, errorCode, errorText);
}

qint64 TelegramCore::messagesReorderStickerSets(const QList<qint64> &order, Callback<bool > callBack, qint32 timeout) {
    if(!mApi) {
        bool result = 0;
        if(callBack)
            callBack(0, result, apiError());
        return 0;
    }
    qint64 msgId = mApi->messagesReorderStickerSets(order);
    if(msgId) {
        callBackPush<bool >(msgId, callBack);
        startTimeOut(msgId, timeout);
        mRecallArgs[msgId][""] = "messagesReorderStickerSets";
        mRecallArgs[msgId]["order"] = QVariant::fromValue<QList<qint64>>(order);
    } else {
        bool result = 0;
        if(callBack)
            callBack(0, result, apiError());
    }
    return msgId;
}

void TelegramCore::onMessagesReorderStickerSetsAnswer(qint64 msgId, bool result, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mRecallArgs.remove(msgId);
    callBackCall<bool >(msgId, result);
    stopTimeOut(msgId);
    Q_EMIT messagesReorderStickerSetsAnswer(msgId, result);
}

void TelegramCore::onMessagesReorderStickerSetsError(qint64 msgId, qint32 errorCode, const QString &errorText, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mRecallArgs.remove(msgId);
    bool result = 0;
    CallbackError error;
    error.errorCode = errorCode;
    error.errorText = errorText;
    error.null = false;
    callBackCall<bool >(msgId, result, error);
    stopTimeOut(msgId);
    Q_EMIT messagesReorderStickerSetsError(msgId, errorCode, errorText);
}

qint64 TelegramCore::messagesGetDocumentByHash(const QByteArray &sha256, qint32 size, const QString &mime_type, Callback<Document > callBack, qint32 timeout) {
    if(!mApi) {
        const Document &result = Document();
        if(callBack)
            callBack(0, result, apiError());
        return 0;
    }
    qint64 msgId = mApi->messagesGetDocumentByHash(sha256, size, mime_type);
    if(msgId) {
        callBackPush<Document >(msgId, callBack);
        startTimeOut(msgId, timeout);
        mRecallArgs[msgId][""] = "messagesGetDocumentByHash";
        mRecallArgs[msgId]["sha256"] = QVariant::fromValue<QByteArray>(sha256);
        mRecallArgs[msgId]["size"] = QVariant::fromValue<qint32>(size);
        mRecallArgs[msgId]["mime_type"] = QVariant::fromValue<QString>(mime_type);
    } else {
        const Document &result = Document();
        if(callBack)
            callBack(0, result, apiError());
    }
    return msgId;
}

void TelegramCore::onMessagesGetDocumentByHashAnswer(qint64 msgId, const Document &result, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mRecallArgs.remove(msgId);
    callBackCall<Document >(msgId, result);
    stopTimeOut(msgId);
    Q_EMIT messagesGetDocumentByHashAnswer(msgId, result);
}

void TelegramCore::onMessagesGetDocumentByHashError(qint64 msgId, qint32 errorCode, const QString &errorText, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mRecallArgs.remove(msgId);
    const Document &result = Document();
    CallbackError error;
    error.errorCode = errorCode;
    error.errorText = errorText;
    error.null = false;
    callBackCall<Document >(msgId, result, error);
    stopTimeOut(msgId);
    Q_EMIT messagesGetDocumentByHashError(msgId, errorCode, errorText);
}

qint64 TelegramCore::messagesSearchGifs(const QString &q, qint32 offset, Callback<MessagesFoundGifs > callBack, qint32 timeout) {
    if(!mApi) {
        const MessagesFoundGifs &result = MessagesFoundGifs();
        if(callBack)
            callBack(0, result, apiError());
        return 0;
    }
    qint64 msgId = mApi->messagesSearchGifs(q, offset);
    if(msgId) {
        callBackPush<MessagesFoundGifs >(msgId, callBack);
        startTimeOut(msgId, timeout);
        mRecallArgs[msgId][""] = "messagesSearchGifs";
        mRecallArgs[msgId]["q"] = QVariant::fromValue<QString>(q);
        mRecallArgs[msgId]["offset"] = QVariant::fromValue<qint32>(offset);
    } else {
        const MessagesFoundGifs &result = MessagesFoundGifs();
        if(callBack)
            callBack(0, result, apiError());
    }
    return msgId;
}

void TelegramCore::onMessagesSearchGifsAnswer(qint64 msgId, const MessagesFoundGifs &result, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mRecallArgs.remove(msgId);
    callBackCall<MessagesFoundGifs >(msgId, result);
    stopTimeOut(msgId);
    Q_EMIT messagesSearchGifsAnswer(msgId, result);
}

void TelegramCore::onMessagesSearchGifsError(qint64 msgId, qint32 errorCode, const QString &errorText, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mRecallArgs.remove(msgId);
    const MessagesFoundGifs &result = MessagesFoundGifs();
    CallbackError error;
    error.errorCode = errorCode;
    error.errorText = errorText;
    error.null = false;
    callBackCall<MessagesFoundGifs >(msgId, result, error);
    stopTimeOut(msgId);
    Q_EMIT messagesSearchGifsError(msgId, errorCode, errorText);
}

qint64 TelegramCore::messagesGetSavedGifs(qint32 hash, Callback<MessagesSavedGifs > callBack, qint32 timeout) {
    if(!mApi) {
        const MessagesSavedGifs &result = MessagesSavedGifs();
        if(callBack)
            callBack(0, result, apiError());
        return 0;
    }
    qint64 msgId = mApi->messagesGetSavedGifs(hash);
    if(msgId) {
        callBackPush<MessagesSavedGifs >(msgId, callBack);
        startTimeOut(msgId, timeout);
        mRecallArgs[msgId][""] = "messagesGetSavedGifs";
        mRecallArgs[msgId]["hash"] = QVariant::fromValue<qint32>(hash);
    } else {
        const MessagesSavedGifs &result = MessagesSavedGifs();
        if(callBack)
            callBack(0, result, apiError());
    }
    return msgId;
}

void TelegramCore::onMessagesGetSavedGifsAnswer(qint64 msgId, const MessagesSavedGifs &result, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mRecallArgs.remove(msgId);
    callBackCall<MessagesSavedGifs >(msgId, result);
    stopTimeOut(msgId);
    Q_EMIT messagesGetSavedGifsAnswer(msgId, result);
}

void TelegramCore::onMessagesGetSavedGifsError(qint64 msgId, qint32 errorCode, const QString &errorText, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mRecallArgs.remove(msgId);
    const MessagesSavedGifs &result = MessagesSavedGifs();
    CallbackError error;
    error.errorCode = errorCode;
    error.errorText = errorText;
    error.null = false;
    callBackCall<MessagesSavedGifs >(msgId, result, error);
    stopTimeOut(msgId);
    Q_EMIT messagesGetSavedGifsError(msgId, errorCode, errorText);
}

qint64 TelegramCore::messagesSaveGif(const InputDocument &id, bool unsave, Callback<bool > callBack, qint32 timeout) {
    if(!mApi) {
        bool result = 0;
        if(callBack)
            callBack(0, result, apiError());
        return 0;
    }
    qint64 msgId = mApi->messagesSaveGif(id, unsave);
    if(msgId) {
        callBackPush<bool >(msgId, callBack);
        startTimeOut(msgId, timeout);
        mRecallArgs[msgId][""] = "messagesSaveGif";
        mRecallArgs[msgId]["id"] = QVariant::fromValue<InputDocument>(id);
        mRecallArgs[msgId]["unsave"] = QVariant::fromValue<bool>(unsave);
    } else {
        bool result = 0;
        if(callBack)
            callBack(0, result, apiError());
    }
    return msgId;
}

void TelegramCore::onMessagesSaveGifAnswer(qint64 msgId, bool result, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mRecallArgs.remove(msgId);
    callBackCall<bool >(msgId, result);
    stopTimeOut(msgId);
    Q_EMIT messagesSaveGifAnswer(msgId, result);
}

void TelegramCore::onMessagesSaveGifError(qint64 msgId, qint32 errorCode, const QString &errorText, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mRecallArgs.remove(msgId);
    bool result = 0;
    CallbackError error;
    error.errorCode = errorCode;
    error.errorText = errorText;
    error.null = false;
    callBackCall<bool >(msgId, result, error);
    stopTimeOut(msgId);
    Q_EMIT messagesSaveGifError(msgId, errorCode, errorText);
}

qint64 TelegramCore::messagesGetInlineBotResults(const InputUser &bot, const QString &query, const QString &offset, Callback<MessagesBotResults > callBack, qint32 timeout) {
    if(!mApi) {
        const MessagesBotResults &result = MessagesBotResults();
        if(callBack)
            callBack(0, result, apiError());
        return 0;
    }
    qint64 msgId = mApi->messagesGetInlineBotResults(bot, query, offset);
    if(msgId) {
        callBackPush<MessagesBotResults >(msgId, callBack);
        startTimeOut(msgId, timeout);
        mRecallArgs[msgId][""] = "messagesGetInlineBotResults";
        mRecallArgs[msgId]["bot"] = QVariant::fromValue<InputUser>(bot);
        mRecallArgs[msgId]["query"] = QVariant::fromValue<QString>(query);
        mRecallArgs[msgId]["offset"] = QVariant::fromValue<QString>(offset);
    } else {
        const MessagesBotResults &result = MessagesBotResults();
        if(callBack)
            callBack(0, result, apiError());
    }
    return msgId;
}

void TelegramCore::onMessagesGetInlineBotResultsAnswer(qint64 msgId, const MessagesBotResults &result, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mRecallArgs.remove(msgId);
    callBackCall<MessagesBotResults >(msgId, result);
    stopTimeOut(msgId);
    Q_EMIT messagesGetInlineBotResultsAnswer(msgId, result);
}

void TelegramCore::onMessagesGetInlineBotResultsError(qint64 msgId, qint32 errorCode, const QString &errorText, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mRecallArgs.remove(msgId);
    const MessagesBotResults &result = MessagesBotResults();
    CallbackError error;
    error.errorCode = errorCode;
    error.errorText = errorText;
    error.null = false;
    callBackCall<MessagesBotResults >(msgId, result, error);
    stopTimeOut(msgId);
    Q_EMIT messagesGetInlineBotResultsError(msgId, errorCode, errorText);
}

qint64 TelegramCore::messagesSetInlineBotResults(bool gallery, bool privateValue, qint64 query_id, const QList<InputBotInlineResult> &results, qint32 cache_time, const QString &next_offset, Callback<bool > callBack, qint32 timeout) {
    if(!mApi) {
        bool result = 0;
        if(callBack)
            callBack(0, result, apiError());
        return 0;
    }
    qint64 msgId = mApi->messagesSetInlineBotResults(gallery, privateValue, query_id, results, cache_time, next_offset);
    if(msgId) {
        callBackPush<bool >(msgId, callBack);
        startTimeOut(msgId, timeout);
        mRecallArgs[msgId][""] = "messagesSetInlineBotResults";
        mRecallArgs[msgId]["gallery"] = QVariant::fromValue<bool>(gallery);
        mRecallArgs[msgId]["privateValue"] = QVariant::fromValue<bool>(privateValue);
        mRecallArgs[msgId]["query_id"] = QVariant::fromValue<qint64>(query_id);
        mRecallArgs[msgId]["results"] = QVariant::fromValue<QList<InputBotInlineResult>>(results);
        mRecallArgs[msgId]["cache_time"] = QVariant::fromValue<qint32>(cache_time);
        mRecallArgs[msgId]["next_offset"] = QVariant::fromValue<QString>(next_offset);
    } else {
        bool result = 0;
        if(callBack)
            callBack(0, result, apiError());
    }
    return msgId;
}

void TelegramCore::onMessagesSetInlineBotResultsAnswer(qint64 msgId, bool result, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mRecallArgs.remove(msgId);
    callBackCall<bool >(msgId, result);
    stopTimeOut(msgId);
    Q_EMIT messagesSetInlineBotResultsAnswer(msgId, result);
}

void TelegramCore::onMessagesSetInlineBotResultsError(qint64 msgId, qint32 errorCode, const QString &errorText, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mRecallArgs.remove(msgId);
    bool result = 0;
    CallbackError error;
    error.errorCode = errorCode;
    error.errorText = errorText;
    error.null = false;
    callBackCall<bool >(msgId, result, error);
    stopTimeOut(msgId);
    Q_EMIT messagesSetInlineBotResultsError(msgId, errorCode, errorText);
}

qint64 TelegramCore::messagesSendInlineBotResult(bool broadcast, const InputPeer &peer, qint32 reply_to_msg_id, qint64 random_id, qint64 query_id, const QString &id, Callback<UpdatesType > callBack, qint32 timeout) {
    if(!mApi) {
        const UpdatesType &result = UpdatesType();
        if(callBack)
            callBack(0, result, apiError());
        return 0;
    }
    qint64 msgId = mApi->messagesSendInlineBotResult(broadcast, peer, reply_to_msg_id, random_id, query_id, id);
    if(msgId) {
        callBackPush<UpdatesType >(msgId, callBack);
        startTimeOut(msgId, timeout);
        mRecallArgs[msgId][""] = "messagesSendInlineBotResult";
        mRecallArgs[msgId]["broadcast"] = QVariant::fromValue<bool>(broadcast);
        mRecallArgs[msgId]["peer"] = QVariant::fromValue<InputPeer>(peer);
        mRecallArgs[msgId]["reply_to_msg_id"] = QVariant::fromValue<qint32>(reply_to_msg_id);
        mRecallArgs[msgId]["random_id"] = QVariant::fromValue<qint64>(random_id);
        mRecallArgs[msgId]["query_id"] = QVariant::fromValue<qint64>(query_id);
        mRecallArgs[msgId]["id"] = QVariant::fromValue<QString>(id);
    } else {
        const UpdatesType &result = UpdatesType();
        if(callBack)
            callBack(0, result, apiError());
    }
    return msgId;
}

void TelegramCore::onMessagesSendInlineBotResultAnswer(qint64 msgId, const UpdatesType &result, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mRecallArgs.remove(msgId);
    callBackCall<UpdatesType >(msgId, result);
    stopTimeOut(msgId);
    Q_EMIT messagesSendInlineBotResultAnswer(msgId, result);
}

void TelegramCore::onMessagesSendInlineBotResultError(qint64 msgId, qint32 errorCode, const QString &errorText, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mRecallArgs.remove(msgId);
    const UpdatesType &result = UpdatesType();
    CallbackError error;
    error.errorCode = errorCode;
    error.errorText = errorText;
    error.null = false;
    callBackCall<UpdatesType >(msgId, result, error);
    stopTimeOut(msgId);
    Q_EMIT messagesSendInlineBotResultError(msgId, errorCode, errorText);
}


qint64 TelegramCore::photosUpdateProfilePhoto(const InputPhoto &id, const InputPhotoCrop &crop, Callback<UserProfilePhoto > callBack, qint32 timeout) {
    if(!mApi) {
        const UserProfilePhoto &result = UserProfilePhoto();
        if(callBack)
            callBack(0, result, apiError());
        return 0;
    }
    qint64 msgId = mApi->photosUpdateProfilePhoto(id, crop);
    if(msgId) {
        callBackPush<UserProfilePhoto >(msgId, callBack);
        startTimeOut(msgId, timeout);
        mRecallArgs[msgId][""] = "photosUpdateProfilePhoto";
        mRecallArgs[msgId]["id"] = QVariant::fromValue<InputPhoto>(id);
        mRecallArgs[msgId]["crop"] = QVariant::fromValue<InputPhotoCrop>(crop);
    } else {
        const UserProfilePhoto &result = UserProfilePhoto();
        if(callBack)
            callBack(0, result, apiError());
    }
    return msgId;
}

void TelegramCore::onPhotosUpdateProfilePhotoAnswer(qint64 msgId, const UserProfilePhoto &result, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mRecallArgs.remove(msgId);
    callBackCall<UserProfilePhoto >(msgId, result);
    stopTimeOut(msgId);
    Q_EMIT photosUpdateProfilePhotoAnswer(msgId, result);
}

void TelegramCore::onPhotosUpdateProfilePhotoError(qint64 msgId, qint32 errorCode, const QString &errorText, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mRecallArgs.remove(msgId);
    const UserProfilePhoto &result = UserProfilePhoto();
    CallbackError error;
    error.errorCode = errorCode;
    error.errorText = errorText;
    error.null = false;
    callBackCall<UserProfilePhoto >(msgId, result, error);
    stopTimeOut(msgId);
    Q_EMIT photosUpdateProfilePhotoError(msgId, errorCode, errorText);
}

qint64 TelegramCore::photosUploadProfilePhoto(const InputFile &file, const QString &caption, const InputGeoPoint &geo_point, const InputPhotoCrop &crop, Callback<PhotosPhoto > callBack, qint32 timeout) {
    if(!mApi) {
        const PhotosPhoto &result = PhotosPhoto();
        if(callBack)
            callBack(0, result, apiError());
        return 0;
    }
    qint64 msgId = mApi->photosUploadProfilePhoto(file, caption, geo_point, crop);
    if(msgId) {
        callBackPush<PhotosPhoto >(msgId, callBack);
        startTimeOut(msgId, timeout);
        mRecallArgs[msgId][""] = "photosUploadProfilePhoto";
        mRecallArgs[msgId]["file"] = QVariant::fromValue<InputFile>(file);
        mRecallArgs[msgId]["caption"] = QVariant::fromValue<QString>(caption);
        mRecallArgs[msgId]["geo_point"] = QVariant::fromValue<InputGeoPoint>(geo_point);
        mRecallArgs[msgId]["crop"] = QVariant::fromValue<InputPhotoCrop>(crop);
    } else {
        const PhotosPhoto &result = PhotosPhoto();
        if(callBack)
            callBack(0, result, apiError());
    }
    return msgId;
}

void TelegramCore::onPhotosUploadProfilePhotoAnswer(qint64 msgId, const PhotosPhoto &result, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mRecallArgs.remove(msgId);
    callBackCall<PhotosPhoto >(msgId, result);
    stopTimeOut(msgId);
    Q_EMIT photosUploadProfilePhotoAnswer(msgId, result);
}

void TelegramCore::onPhotosUploadProfilePhotoError(qint64 msgId, qint32 errorCode, const QString &errorText, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mRecallArgs.remove(msgId);
    const PhotosPhoto &result = PhotosPhoto();
    CallbackError error;
    error.errorCode = errorCode;
    error.errorText = errorText;
    error.null = false;
    callBackCall<PhotosPhoto >(msgId, result, error);
    stopTimeOut(msgId);
    Q_EMIT photosUploadProfilePhotoError(msgId, errorCode, errorText);
}

qint64 TelegramCore::photosDeletePhotos(const QList<InputPhoto> &id, Callback<QList<qint64> > callBack, qint32 timeout) {
    if(!mApi) {
        const QList<qint64> &result = QList<qint64>();
        if(callBack)
            callBack(0, result, apiError());
        return 0;
    }
    qint64 msgId = mApi->photosDeletePhotos(id);
    if(msgId) {
        callBackPush<QList<qint64> >(msgId, callBack);
        startTimeOut(msgId, timeout);
        mRecallArgs[msgId][""] = "photosDeletePhotos";
        mRecallArgs[msgId]["id"] = QVariant::fromValue<QList<InputPhoto>>(id);
    } else {
        const QList<qint64> &result = QList<qint64>();
        if(callBack)
            callBack(0, result, apiError());
    }
    return msgId;
}

void TelegramCore::onPhotosDeletePhotosAnswer(qint64 msgId, const QList<qint64> &result, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mRecallArgs.remove(msgId);
    callBackCall<QList<qint64> >(msgId, result);
    stopTimeOut(msgId);
    Q_EMIT photosDeletePhotosAnswer(msgId, result);
}

void TelegramCore::onPhotosDeletePhotosError(qint64 msgId, qint32 errorCode, const QString &errorText, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mRecallArgs.remove(msgId);
    const QList<qint64> &result = QList<qint64>();
    CallbackError error;
    error.errorCode = errorCode;
    error.errorText = errorText;
    error.null = false;
    callBackCall<QList<qint64> >(msgId, result, error);
    stopTimeOut(msgId);
    Q_EMIT photosDeletePhotosError(msgId, errorCode, errorText);
}

qint64 TelegramCore::photosGetUserPhotos(const InputUser &user_id, qint32 offset, qint64 max_id, qint32 limit, Callback<PhotosPhotos > callBack, qint32 timeout) {
    if(!mApi) {
        const PhotosPhotos &result = PhotosPhotos();
        if(callBack)
            callBack(0, result, apiError());
        return 0;
    }
    qint64 msgId = mApi->photosGetUserPhotos(user_id, offset, max_id, limit);
    if(msgId) {
        callBackPush<PhotosPhotos >(msgId, callBack);
        startTimeOut(msgId, timeout);
        mRecallArgs[msgId][""] = "photosGetUserPhotos";
        mRecallArgs[msgId]["user_id"] = QVariant::fromValue<InputUser>(user_id);
        mRecallArgs[msgId]["offset"] = QVariant::fromValue<qint32>(offset);
        mRecallArgs[msgId]["max_id"] = QVariant::fromValue<qint64>(max_id);
        mRecallArgs[msgId]["limit"] = QVariant::fromValue<qint32>(limit);
    } else {
        const PhotosPhotos &result = PhotosPhotos();
        if(callBack)
            callBack(0, result, apiError());
    }
    return msgId;
}

void TelegramCore::onPhotosGetUserPhotosAnswer(qint64 msgId, const PhotosPhotos &result, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mRecallArgs.remove(msgId);
    callBackCall<PhotosPhotos >(msgId, result);
    stopTimeOut(msgId);
    Q_EMIT photosGetUserPhotosAnswer(msgId, result);
}

void TelegramCore::onPhotosGetUserPhotosError(qint64 msgId, qint32 errorCode, const QString &errorText, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mRecallArgs.remove(msgId);
    const PhotosPhotos &result = PhotosPhotos();
    CallbackError error;
    error.errorCode = errorCode;
    error.errorText = errorText;
    error.null = false;
    callBackCall<PhotosPhotos >(msgId, result, error);
    stopTimeOut(msgId);
    Q_EMIT photosGetUserPhotosError(msgId, errorCode, errorText);
}


qint64 TelegramCore::updatesGetState(Callback<UpdatesState > callBack, qint32 timeout) {
    if(!mApi) {
        const UpdatesState &result = UpdatesState();
        if(callBack)
            callBack(0, result, apiError());
        return 0;
    }
    qint64 msgId = mApi->updatesGetState();
    if(msgId) {
        callBackPush<UpdatesState >(msgId, callBack);
        startTimeOut(msgId, timeout);
        mRecallArgs[msgId][""] = "updatesGetState";
    } else {
        const UpdatesState &result = UpdatesState();
        if(callBack)
            callBack(0, result, apiError());
    }
    return msgId;
}

void TelegramCore::onUpdatesGetStateAnswer(qint64 msgId, const UpdatesState &result, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mRecallArgs.remove(msgId);
    callBackCall<UpdatesState >(msgId, result);
    stopTimeOut(msgId);
    Q_EMIT updatesGetStateAnswer(msgId, result);
}

void TelegramCore::onUpdatesGetStateError(qint64 msgId, qint32 errorCode, const QString &errorText, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mRecallArgs.remove(msgId);
    const UpdatesState &result = UpdatesState();
    CallbackError error;
    error.errorCode = errorCode;
    error.errorText = errorText;
    error.null = false;
    callBackCall<UpdatesState >(msgId, result, error);
    stopTimeOut(msgId);
    Q_EMIT updatesGetStateError(msgId, errorCode, errorText);
}

qint64 TelegramCore::updatesGetDifference(qint32 pts, qint32 date, qint32 qts, Callback<UpdatesDifference > callBack, qint32 timeout) {
    if(!mApi) {
        const UpdatesDifference &result = UpdatesDifference();
        if(callBack)
            callBack(0, result, apiError());
        return 0;
    }
    qint64 msgId = mApi->updatesGetDifference(pts, date, qts);
    if(msgId) {
        callBackPush<UpdatesDifference >(msgId, callBack);
        startTimeOut(msgId, timeout);
        mRecallArgs[msgId][""] = "updatesGetDifference";
        mRecallArgs[msgId]["pts"] = QVariant::fromValue<qint32>(pts);
        mRecallArgs[msgId]["date"] = QVariant::fromValue<qint32>(date);
        mRecallArgs[msgId]["qts"] = QVariant::fromValue<qint32>(qts);
    } else {
        const UpdatesDifference &result = UpdatesDifference();
        if(callBack)
            callBack(0, result, apiError());
    }
    return msgId;
}

void TelegramCore::onUpdatesGetDifferenceAnswer(qint64 msgId, const UpdatesDifference &result, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mRecallArgs.remove(msgId);
    callBackCall<UpdatesDifference >(msgId, result);
    stopTimeOut(msgId);
    Q_EMIT updatesGetDifferenceAnswer(msgId, result);
}

void TelegramCore::onUpdatesGetDifferenceError(qint64 msgId, qint32 errorCode, const QString &errorText, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mRecallArgs.remove(msgId);
    const UpdatesDifference &result = UpdatesDifference();
    CallbackError error;
    error.errorCode = errorCode;
    error.errorText = errorText;
    error.null = false;
    callBackCall<UpdatesDifference >(msgId, result, error);
    stopTimeOut(msgId);
    Q_EMIT updatesGetDifferenceError(msgId, errorCode, errorText);
}

qint64 TelegramCore::updatesGetChannelDifference(const InputChannel &channel, const ChannelMessagesFilter &filter, qint32 pts, qint32 limit, Callback<UpdatesChannelDifference > callBack, qint32 timeout) {
    if(!mApi) {
        const UpdatesChannelDifference &result = UpdatesChannelDifference();
        if(callBack)
            callBack(0, result, apiError());
        return 0;
    }
    qint64 msgId = mApi->updatesGetChannelDifference(channel, filter, pts, limit);
    if(msgId) {
        callBackPush<UpdatesChannelDifference >(msgId, callBack);
        startTimeOut(msgId, timeout);
        mRecallArgs[msgId][""] = "updatesGetChannelDifference";
        mRecallArgs[msgId]["channel"] = QVariant::fromValue<InputChannel>(channel);
        mRecallArgs[msgId]["filter"] = QVariant::fromValue<ChannelMessagesFilter>(filter);
        mRecallArgs[msgId]["pts"] = QVariant::fromValue<qint32>(pts);
        mRecallArgs[msgId]["limit"] = QVariant::fromValue<qint32>(limit);
    } else {
        const UpdatesChannelDifference &result = UpdatesChannelDifference();
        if(callBack)
            callBack(0, result, apiError());
    }
    return msgId;
}

void TelegramCore::onUpdatesGetChannelDifferenceAnswer(qint64 msgId, const UpdatesChannelDifference &result, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mRecallArgs.remove(msgId);
    callBackCall<UpdatesChannelDifference >(msgId, result);
    stopTimeOut(msgId);
    Q_EMIT updatesGetChannelDifferenceAnswer(msgId, result);
}

void TelegramCore::onUpdatesGetChannelDifferenceError(qint64 msgId, qint32 errorCode, const QString &errorText, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mRecallArgs.remove(msgId);
    const UpdatesChannelDifference &result = UpdatesChannelDifference();
    CallbackError error;
    error.errorCode = errorCode;
    error.errorText = errorText;
    error.null = false;
    callBackCall<UpdatesChannelDifference >(msgId, result, error);
    stopTimeOut(msgId);
    Q_EMIT updatesGetChannelDifferenceError(msgId, errorCode, errorText);
}


qint64 TelegramCore::uploadSaveFilePart(qint64 file_id, qint32 file_part, const QByteArray &bytes, Callback<bool > callBack, qint32 timeout) {
    if(!mApi) {
        bool result = 0;
        if(callBack)
            callBack(0, result, apiError());
        return 0;
    }
    qint64 msgId = mApi->uploadSaveFilePart(file_id, file_part, bytes);
    if(msgId) {
        callBackPush<bool >(msgId, callBack);
        startTimeOut(msgId, timeout);
        mRecallArgs[msgId][""] = "uploadSaveFilePart";
        mRecallArgs[msgId]["file_id"] = QVariant::fromValue<qint64>(file_id);
        mRecallArgs[msgId]["file_part"] = QVariant::fromValue<qint32>(file_part);
        mRecallArgs[msgId]["bytes"] = QVariant::fromValue<QByteArray>(bytes);
    } else {
        bool result = 0;
        if(callBack)
            callBack(0, result, apiError());
    }
    return msgId;
}

void TelegramCore::onUploadSaveFilePartAnswer(qint64 msgId, bool result, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mRecallArgs.remove(msgId);
    callBackCall<bool >(msgId, result);
    stopTimeOut(msgId);
    Q_EMIT uploadSaveFilePartAnswer(msgId, result);
}

void TelegramCore::onUploadSaveFilePartError(qint64 msgId, qint32 errorCode, const QString &errorText, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mRecallArgs.remove(msgId);
    bool result = 0;
    CallbackError error;
    error.errorCode = errorCode;
    error.errorText = errorText;
    error.null = false;
    callBackCall<bool >(msgId, result, error);
    stopTimeOut(msgId);
    Q_EMIT uploadSaveFilePartError(msgId, errorCode, errorText);
}

qint64 TelegramCore::uploadGetFile(const InputFileLocation &location, qint32 offset, qint32 limit, Callback<UploadFile > callBack, qint32 timeout) {
    if(!mApi) {
        const UploadFile &result = UploadFile();
        if(callBack)
            callBack(0, result, apiError());
        return 0;
    }
    qint64 msgId = mApi->uploadGetFile(location, offset, limit);
    if(msgId) {
        callBackPush<UploadFile >(msgId, callBack);
        startTimeOut(msgId, timeout);
        mRecallArgs[msgId][""] = "uploadGetFile";
        mRecallArgs[msgId]["location"] = QVariant::fromValue<InputFileLocation>(location);
        mRecallArgs[msgId]["offset"] = QVariant::fromValue<qint32>(offset);
        mRecallArgs[msgId]["limit"] = QVariant::fromValue<qint32>(limit);
    } else {
        const UploadFile &result = UploadFile();
        if(callBack)
            callBack(0, result, apiError());
    }
    return msgId;
}

void TelegramCore::onUploadGetFileAnswer(qint64 msgId, const UploadFile &result, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mRecallArgs.remove(msgId);
    callBackCall<UploadFile >(msgId, result);
    stopTimeOut(msgId);
    Q_EMIT uploadGetFileAnswer(msgId, result);
}

void TelegramCore::onUploadGetFileError(qint64 msgId, qint32 errorCode, const QString &errorText, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mRecallArgs.remove(msgId);
    const UploadFile &result = UploadFile();
    CallbackError error;
    error.errorCode = errorCode;
    error.errorText = errorText;
    error.null = false;
    callBackCall<UploadFile >(msgId, result, error);
    stopTimeOut(msgId);
    Q_EMIT uploadGetFileError(msgId, errorCode, errorText);
}

qint64 TelegramCore::uploadSaveBigFilePart(qint64 file_id, qint32 file_part, qint32 file_total_parts, const QByteArray &bytes, Callback<bool > callBack, qint32 timeout) {
    if(!mApi) {
        bool result = 0;
        if(callBack)
            callBack(0, result, apiError());
        return 0;
    }
    qint64 msgId = mApi->uploadSaveBigFilePart(file_id, file_part, file_total_parts, bytes);
    if(msgId) {
        callBackPush<bool >(msgId, callBack);
        startTimeOut(msgId, timeout);
        mRecallArgs[msgId][""] = "uploadSaveBigFilePart";
        mRecallArgs[msgId]["file_id"] = QVariant::fromValue<qint64>(file_id);
        mRecallArgs[msgId]["file_part"] = QVariant::fromValue<qint32>(file_part);
        mRecallArgs[msgId]["file_total_parts"] = QVariant::fromValue<qint32>(file_total_parts);
        mRecallArgs[msgId]["bytes"] = QVariant::fromValue<QByteArray>(bytes);
    } else {
        bool result = 0;
        if(callBack)
            callBack(0, result, apiError());
    }
    return msgId;
}

void TelegramCore::onUploadSaveBigFilePartAnswer(qint64 msgId, bool result, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mRecallArgs.remove(msgId);
    callBackCall<bool >(msgId, result);
    stopTimeOut(msgId);
    Q_EMIT uploadSaveBigFilePartAnswer(msgId, result);
}

void TelegramCore::onUploadSaveBigFilePartError(qint64 msgId, qint32 errorCode, const QString &errorText, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mRecallArgs.remove(msgId);
    bool result = 0;
    CallbackError error;
    error.errorCode = errorCode;
    error.errorText = errorText;
    error.null = false;
    callBackCall<bool >(msgId, result, error);
    stopTimeOut(msgId);
    Q_EMIT uploadSaveBigFilePartError(msgId, errorCode, errorText);
}


qint64 TelegramCore::usersGetUsers(const QList<InputUser> &id, Callback<QList<User> > callBack, qint32 timeout) {
    if(!mApi) {
        const QList<User> &result = QList<User>();
        if(callBack)
            callBack(0, result, apiError());
        return 0;
    }
    qint64 msgId = mApi->usersGetUsers(id);
    if(msgId) {
        callBackPush<QList<User> >(msgId, callBack);
        startTimeOut(msgId, timeout);
        mRecallArgs[msgId][""] = "usersGetUsers";
        mRecallArgs[msgId]["id"] = QVariant::fromValue<QList<InputUser>>(id);
    } else {
        const QList<User> &result = QList<User>();
        if(callBack)
            callBack(0, result, apiError());
    }
    return msgId;
}

void TelegramCore::onUsersGetUsersAnswer(qint64 msgId, const QList<User> &result, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mRecallArgs.remove(msgId);
    callBackCall<QList<User> >(msgId, result);
    stopTimeOut(msgId);
    Q_EMIT usersGetUsersAnswer(msgId, result);
}

void TelegramCore::onUsersGetUsersError(qint64 msgId, qint32 errorCode, const QString &errorText, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mRecallArgs.remove(msgId);
    const QList<User> &result = QList<User>();
    CallbackError error;
    error.errorCode = errorCode;
    error.errorText = errorText;
    error.null = false;
    callBackCall<QList<User> >(msgId, result, error);
    stopTimeOut(msgId);
    Q_EMIT usersGetUsersError(msgId, errorCode, errorText);
}

qint64 TelegramCore::usersGetFullUser(const InputUser &id, Callback<UserFull > callBack, qint32 timeout) {
    if(!mApi) {
        const UserFull &result = UserFull();
        if(callBack)
            callBack(0, result, apiError());
        return 0;
    }
    qint64 msgId = mApi->usersGetFullUser(id);
    if(msgId) {
        callBackPush<UserFull >(msgId, callBack);
        startTimeOut(msgId, timeout);
        mRecallArgs[msgId][""] = "usersGetFullUser";
        mRecallArgs[msgId]["id"] = QVariant::fromValue<InputUser>(id);
    } else {
        const UserFull &result = UserFull();
        if(callBack)
            callBack(0, result, apiError());
    }
    return msgId;
}

void TelegramCore::onUsersGetFullUserAnswer(qint64 msgId, const UserFull &result, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mRecallArgs.remove(msgId);
    callBackCall<UserFull >(msgId, result);
    stopTimeOut(msgId);
    Q_EMIT usersGetFullUserAnswer(msgId, result);
}

void TelegramCore::onUsersGetFullUserError(qint64 msgId, qint32 errorCode, const QString &errorText, const QVariant &attachedData) {
    Q_UNUSED(attachedData);
    mRecallArgs.remove(msgId);
    const UserFull &result = UserFull();
    CallbackError error;
    error.errorCode = errorCode;
    error.errorText = errorText;
    error.null = false;
    callBackCall<UserFull >(msgId, result, error);
    stopTimeOut(msgId);
    Q_EMIT usersGetFullUserError(msgId, errorCode, errorText);
}


void TelegramCore::onError(qint64 id, qint32 errorCode, const QString &errorText, const QString &functionName, const QVariant &attachedData, bool &accepted)
{
    Q_EMIT error(id, errorCode, errorText, functionName);
    Q_UNUSED(accepted)
    Q_UNUSED(attachedData)
}

qint64 TelegramCore::retry(qint64 mid)
{
    qint64 result = 0;
    if(!mRecallArgs.contains(mid))
        return result;
    const QVariantHash &args = mRecallArgs.take(mid);
    const QString &functionName = args.value("").toString();
    if(functionName.isEmpty())
        return result;
    if(functionName == "accountRegisterDevice") {
        result = accountRegisterDevice(args["token_type"].value<qint32>(), args["token"].value<QString>(), args["device_model"].value<QString>(), args["system_version"].value<QString>(), args["app_version"].value<QString>(), args["app_sandbox"].value<bool>(), args["lang_code"].value<QString>(), [this, mid](TG_CALLBACK_SIGNATURE(bool)){ Q_UNUSED(msgId); callBackCall<bool>(mid, result, error); } );
    } else if(functionName == "accountUnregisterDevice") {
        result = accountUnregisterDevice(args["token_type"].value<qint32>(), args["token"].value<QString>(), [this, mid](TG_CALLBACK_SIGNATURE(bool)){ Q_UNUSED(msgId); callBackCall<bool>(mid, result, error); } );
    } else if(functionName == "accountUpdateNotifySettings") {
        result = accountUpdateNotifySettings(args["peer"].value<InputNotifyPeer>(), args["settings"].value<InputPeerNotifySettings>(), [this, mid](TG_CALLBACK_SIGNATURE(bool)){ Q_UNUSED(msgId); callBackCall<bool>(mid, result, error); } );
    } else if(functionName == "accountGetNotifySettings") {
        result = accountGetNotifySettings(args["peer"].value<InputNotifyPeer>(), [this, mid](TG_CALLBACK_SIGNATURE(PeerNotifySettings)){ Q_UNUSED(msgId); callBackCall<PeerNotifySettings>(mid, result, error); } );
    } else if(functionName == "accountResetNotifySettings") {
        result = accountResetNotifySettings([this, mid](TG_CALLBACK_SIGNATURE(bool)){ Q_UNUSED(msgId); callBackCall<bool>(mid, result, error); } );
    } else if(functionName == "accountUpdateProfile") {
        result = accountUpdateProfile(args["first_name"].value<QString>(), args["last_name"].value<QString>(), [this, mid](TG_CALLBACK_SIGNATURE(User)){ Q_UNUSED(msgId); callBackCall<User>(mid, result, error); } );
    } else if(functionName == "accountUpdateStatus") {
        result = accountUpdateStatus(args["offline"].value<bool>(), [this, mid](TG_CALLBACK_SIGNATURE(bool)){ Q_UNUSED(msgId); callBackCall<bool>(mid, result, error); } );
    } else if(functionName == "accountGetWallPapers") {
        result = accountGetWallPapers([this, mid](TG_CALLBACK_SIGNATURE(QList<WallPaper>)){ Q_UNUSED(msgId); callBackCall<QList<WallPaper>>(mid, result, error); } );
    } else if(functionName == "accountReportPeer") {
        result = accountReportPeer(args["peer"].value<InputPeer>(), args["reason"].value<ReportReason>(), [this, mid](TG_CALLBACK_SIGNATURE(bool)){ Q_UNUSED(msgId); callBackCall<bool>(mid, result, error); } );
    } else if(functionName == "accountCheckUsername") {
        result = accountCheckUsername(args["username"].value<QString>(), [this, mid](TG_CALLBACK_SIGNATURE(bool)){ Q_UNUSED(msgId); callBackCall<bool>(mid, result, error); } );
    } else if(functionName == "accountUpdateUsername") {
        result = accountUpdateUsername(args["username"].value<QString>(), [this, mid](TG_CALLBACK_SIGNATURE(User)){ Q_UNUSED(msgId); callBackCall<User>(mid, result, error); } );
    } else if(functionName == "accountGetPrivacy") {
        result = accountGetPrivacy(args["key"].value<InputPrivacyKey>(), [this, mid](TG_CALLBACK_SIGNATURE(AccountPrivacyRules)){ Q_UNUSED(msgId); callBackCall<AccountPrivacyRules>(mid, result, error); } );
    } else if(functionName == "accountSetPrivacy") {
        result = accountSetPrivacy(args["key"].value<InputPrivacyKey>(), args["rules"].value<QList<InputPrivacyRule>>(), [this, mid](TG_CALLBACK_SIGNATURE(AccountPrivacyRules)){ Q_UNUSED(msgId); callBackCall<AccountPrivacyRules>(mid, result, error); } );
    } else if(functionName == "accountDeleteAccount") {
        result = accountDeleteAccount(args["reason"].value<QString>(), [this, mid](TG_CALLBACK_SIGNATURE(bool)){ Q_UNUSED(msgId); callBackCall<bool>(mid, result, error); } );
    } else if(functionName == "accountGetAccountTTL") {
        result = accountGetAccountTTL([this, mid](TG_CALLBACK_SIGNATURE(AccountDaysTTL)){ Q_UNUSED(msgId); callBackCall<AccountDaysTTL>(mid, result, error); } );
    } else if(functionName == "accountSetAccountTTL") {
        result = accountSetAccountTTL(args["ttl"].value<AccountDaysTTL>(), [this, mid](TG_CALLBACK_SIGNATURE(bool)){ Q_UNUSED(msgId); callBackCall<bool>(mid, result, error); } );
    } else if(functionName == "accountSendChangePhoneCode") {
        result = accountSendChangePhoneCode(args["phone_number"].value<QString>(), [this, mid](TG_CALLBACK_SIGNATURE(AccountSentChangePhoneCode)){ Q_UNUSED(msgId); callBackCall<AccountSentChangePhoneCode>(mid, result, error); } );
    } else if(functionName == "accountChangePhone") {
        result = accountChangePhone(args["phone_number"].value<QString>(), args["phone_code_hash"].value<QString>(), args["phone_code"].value<QString>(), [this, mid](TG_CALLBACK_SIGNATURE(User)){ Q_UNUSED(msgId); callBackCall<User>(mid, result, error); } );
    } else if(functionName == "accountUpdateDeviceLocked") {
        result = accountUpdateDeviceLocked(args["period"].value<qint32>(), [this, mid](TG_CALLBACK_SIGNATURE(bool)){ Q_UNUSED(msgId); callBackCall<bool>(mid, result, error); } );
    } else if(functionName == "accountGetAuthorizations") {
        result = accountGetAuthorizations([this, mid](TG_CALLBACK_SIGNATURE(AccountAuthorizations)){ Q_UNUSED(msgId); callBackCall<AccountAuthorizations>(mid, result, error); } );
    } else if(functionName == "accountResetAuthorization") {
        result = accountResetAuthorization(args["hash"].value<qint64>(), [this, mid](TG_CALLBACK_SIGNATURE(bool)){ Q_UNUSED(msgId); callBackCall<bool>(mid, result, error); } );
    } else if(functionName == "accountGetPassword") {
        result = accountGetPassword([this, mid](TG_CALLBACK_SIGNATURE(AccountPassword)){ Q_UNUSED(msgId); callBackCall<AccountPassword>(mid, result, error); } );
    } else if(functionName == "accountGetPasswordSettings") {
        result = accountGetPasswordSettings(args["current_password_hash"].value<QByteArray>(), [this, mid](TG_CALLBACK_SIGNATURE(AccountPasswordSettings)){ Q_UNUSED(msgId); callBackCall<AccountPasswordSettings>(mid, result, error); } );
    } else if(functionName == "accountUpdatePasswordSettings") {
        result = accountUpdatePasswordSettings(args["current_password_hash"].value<QByteArray>(), args["new_settings"].value<AccountPasswordInputSettings>(), [this, mid](TG_CALLBACK_SIGNATURE(bool)){ Q_UNUSED(msgId); callBackCall<bool>(mid, result, error); } );
    } else if(functionName == "authCheckPhone") {
        result = authCheckPhone(args["phone_number"].value<QString>(), [this, mid](TG_CALLBACK_SIGNATURE(AuthCheckedPhone)){ Q_UNUSED(msgId); callBackCall<AuthCheckedPhone>(mid, result, error); } );
    } else if(functionName == "authSendCode") {
        result = authSendCode(args["phone_number"].value<QString>(), args["sms_type"].value<qint32>(), args["api_id"].value<qint32>(), args["api_hash"].value<QString>(), args["lang_code"].value<QString>(), [this, mid](TG_CALLBACK_SIGNATURE(AuthSentCode)){ Q_UNUSED(msgId); callBackCall<AuthSentCode>(mid, result, error); } );
    } else if(functionName == "authSendCall") {
        result = authSendCall(args["phone_number"].value<QString>(), args["phone_code_hash"].value<QString>(), [this, mid](TG_CALLBACK_SIGNATURE(bool)){ Q_UNUSED(msgId); callBackCall<bool>(mid, result, error); } );
    } else if(functionName == "authSignUp") {
        result = authSignUp(args["phone_number"].value<QString>(), args["phone_code_hash"].value<QString>(), args["phone_code"].value<QString>(), args["first_name"].value<QString>(), args["last_name"].value<QString>(), [this, mid](TG_CALLBACK_SIGNATURE(AuthAuthorization)){ Q_UNUSED(msgId); callBackCall<AuthAuthorization>(mid, result, error); } );
    } else if(functionName == "authSignIn") {
        result = authSignIn(args["phone_number"].value<QString>(), args["phone_code_hash"].value<QString>(), args["phone_code"].value<QString>(), [this, mid](TG_CALLBACK_SIGNATURE(AuthAuthorization)){ Q_UNUSED(msgId); callBackCall<AuthAuthorization>(mid, result, error); } );
    } else if(functionName == "authLogOut") {
        result = authLogOut([this, mid](TG_CALLBACK_SIGNATURE(bool)){ Q_UNUSED(msgId); callBackCall<bool>(mid, result, error); } );
    } else if(functionName == "authResetAuthorizations") {
        result = authResetAuthorizations([this, mid](TG_CALLBACK_SIGNATURE(bool)){ Q_UNUSED(msgId); callBackCall<bool>(mid, result, error); } );
    } else if(functionName == "authSendInvites") {
        result = authSendInvites(args["phone_numbers"].value<QList<QString>>(), args["message"].value<QString>(), [this, mid](TG_CALLBACK_SIGNATURE(bool)){ Q_UNUSED(msgId); callBackCall<bool>(mid, result, error); } );
    } else if(functionName == "authExportAuthorization") {
        result = authExportAuthorization(args["dc_id"].value<qint32>(), [this, mid](TG_CALLBACK_SIGNATURE(AuthExportedAuthorization)){ Q_UNUSED(msgId); callBackCall<AuthExportedAuthorization>(mid, result, error); } );
    } else if(functionName == "authImportAuthorization") {
        result = authImportAuthorization(args["id"].value<qint32>(), args["bytes"].value<QByteArray>(), [this, mid](TG_CALLBACK_SIGNATURE(AuthAuthorization)){ Q_UNUSED(msgId); callBackCall<AuthAuthorization>(mid, result, error); } );
    } else if(functionName == "authBindTempAuthKey") {
        result = authBindTempAuthKey(args["perm_auth_key_id"].value<qint64>(), args["nonce"].value<qint64>(), args["expires_at"].value<qint32>(), args["encrypted_message"].value<QByteArray>(), [this, mid](TG_CALLBACK_SIGNATURE(bool)){ Q_UNUSED(msgId); callBackCall<bool>(mid, result, error); } );
    } else if(functionName == "authSendSms") {
        result = authSendSms(args["phone_number"].value<QString>(), args["phone_code_hash"].value<QString>(), [this, mid](TG_CALLBACK_SIGNATURE(bool)){ Q_UNUSED(msgId); callBackCall<bool>(mid, result, error); } );
    } else if(functionName == "authImportBotAuthorization") {
        result = authImportBotAuthorization(args["flags"].value<qint32>(), args["api_id"].value<qint32>(), args["api_hash"].value<QString>(), args["bot_auth_token"].value<QString>(), [this, mid](TG_CALLBACK_SIGNATURE(AuthAuthorization)){ Q_UNUSED(msgId); callBackCall<AuthAuthorization>(mid, result, error); } );
    } else if(functionName == "authCheckPassword") {
        result = authCheckPassword(args["password_hash"].value<QByteArray>(), [this, mid](TG_CALLBACK_SIGNATURE(AuthAuthorization)){ Q_UNUSED(msgId); callBackCall<AuthAuthorization>(mid, result, error); } );
    } else if(functionName == "authRequestPasswordRecovery") {
        result = authRequestPasswordRecovery([this, mid](TG_CALLBACK_SIGNATURE(AuthPasswordRecovery)){ Q_UNUSED(msgId); callBackCall<AuthPasswordRecovery>(mid, result, error); } );
    } else if(functionName == "authRecoverPassword") {
        result = authRecoverPassword(args["code"].value<QString>(), [this, mid](TG_CALLBACK_SIGNATURE(AuthAuthorization)){ Q_UNUSED(msgId); callBackCall<AuthAuthorization>(mid, result, error); } );
    } else if(functionName == "channelsGetDialogs") {
        result = channelsGetDialogs(args["offset"].value<qint32>(), args["limit"].value<qint32>(), [this, mid](TG_CALLBACK_SIGNATURE(MessagesDialogs)){ Q_UNUSED(msgId); callBackCall<MessagesDialogs>(mid, result, error); } );
    } else if(functionName == "channelsGetImportantHistory") {
        result = channelsGetImportantHistory(args["channel"].value<InputChannel>(), args["offset_id"].value<qint32>(), args["add_offset"].value<qint32>(), args["limit"].value<qint32>(), args["max_id"].value<qint32>(), args["min_id"].value<qint32>(), [this, mid](TG_CALLBACK_SIGNATURE(MessagesMessages)){ Q_UNUSED(msgId); callBackCall<MessagesMessages>(mid, result, error); } );
    } else if(functionName == "channelsReadHistory") {
        result = channelsReadHistory(args["channel"].value<InputChannel>(), args["max_id"].value<qint32>(), [this, mid](TG_CALLBACK_SIGNATURE(bool)){ Q_UNUSED(msgId); callBackCall<bool>(mid, result, error); } );
    } else if(functionName == "channelsDeleteMessages") {
        result = channelsDeleteMessages(args["channel"].value<InputChannel>(), args["id"].value<QList<qint32>>(), [this, mid](TG_CALLBACK_SIGNATURE(MessagesAffectedMessages)){ Q_UNUSED(msgId); callBackCall<MessagesAffectedMessages>(mid, result, error); } );
    } else if(functionName == "channelsDeleteUserHistory") {
        result = channelsDeleteUserHistory(args["channel"].value<InputChannel>(), args["user_id"].value<InputUser>(), [this, mid](TG_CALLBACK_SIGNATURE(MessagesAffectedHistory)){ Q_UNUSED(msgId); callBackCall<MessagesAffectedHistory>(mid, result, error); } );
    } else if(functionName == "channelsReportSpam") {
        result = channelsReportSpam(args["channel"].value<InputChannel>(), args["user_id"].value<InputUser>(), args["id"].value<QList<qint32>>(), [this, mid](TG_CALLBACK_SIGNATURE(bool)){ Q_UNUSED(msgId); callBackCall<bool>(mid, result, error); } );
    } else if(functionName == "channelsGetMessages") {
        result = channelsGetMessages(args["channel"].value<InputChannel>(), args["id"].value<QList<qint32>>(), [this, mid](TG_CALLBACK_SIGNATURE(MessagesMessages)){ Q_UNUSED(msgId); callBackCall<MessagesMessages>(mid, result, error); } );
    } else if(functionName == "channelsGetParticipants") {
        result = channelsGetParticipants(args["channel"].value<InputChannel>(), args["filter"].value<ChannelParticipantsFilter>(), args["offset"].value<qint32>(), args["limit"].value<qint32>(), [this, mid](TG_CALLBACK_SIGNATURE(ChannelsChannelParticipants)){ Q_UNUSED(msgId); callBackCall<ChannelsChannelParticipants>(mid, result, error); } );
    } else if(functionName == "channelsGetParticipant") {
        result = channelsGetParticipant(args["channel"].value<InputChannel>(), args["user_id"].value<InputUser>(), [this, mid](TG_CALLBACK_SIGNATURE(ChannelsChannelParticipant)){ Q_UNUSED(msgId); callBackCall<ChannelsChannelParticipant>(mid, result, error); } );
    } else if(functionName == "channelsGetChannels") {
        result = channelsGetChannels(args["id"].value<QList<InputChannel>>(), [this, mid](TG_CALLBACK_SIGNATURE(MessagesChats)){ Q_UNUSED(msgId); callBackCall<MessagesChats>(mid, result, error); } );
    } else if(functionName == "channelsGetFullChannel") {
        result = channelsGetFullChannel(args["channel"].value<InputChannel>(), [this, mid](TG_CALLBACK_SIGNATURE(MessagesChatFull)){ Q_UNUSED(msgId); callBackCall<MessagesChatFull>(mid, result, error); } );
    } else if(functionName == "channelsCreateChannel") {
        result = channelsCreateChannel(args["broadcast"].value<bool>(), args["megagroup"].value<bool>(), args["title"].value<QString>(), args["about"].value<QString>(), [this, mid](TG_CALLBACK_SIGNATURE(UpdatesType)){ Q_UNUSED(msgId); callBackCall<UpdatesType>(mid, result, error); } );
    } else if(functionName == "channelsEditAbout") {
        result = channelsEditAbout(args["channel"].value<InputChannel>(), args["about"].value<QString>(), [this, mid](TG_CALLBACK_SIGNATURE(bool)){ Q_UNUSED(msgId); callBackCall<bool>(mid, result, error); } );
    } else if(functionName == "channelsEditAdmin") {
        result = channelsEditAdmin(args["channel"].value<InputChannel>(), args["user_id"].value<InputUser>(), args["role"].value<ChannelParticipantRole>(), [this, mid](TG_CALLBACK_SIGNATURE(UpdatesType)){ Q_UNUSED(msgId); callBackCall<UpdatesType>(mid, result, error); } );
    } else if(functionName == "channelsEditTitle") {
        result = channelsEditTitle(args["channel"].value<InputChannel>(), args["title"].value<QString>(), [this, mid](TG_CALLBACK_SIGNATURE(UpdatesType)){ Q_UNUSED(msgId); callBackCall<UpdatesType>(mid, result, error); } );
    } else if(functionName == "channelsEditPhoto") {
        result = channelsEditPhoto(args["channel"].value<InputChannel>(), args["photo"].value<InputChatPhoto>(), [this, mid](TG_CALLBACK_SIGNATURE(UpdatesType)){ Q_UNUSED(msgId); callBackCall<UpdatesType>(mid, result, error); } );
    } else if(functionName == "channelsToggleComments") {
        result = channelsToggleComments(args["channel"].value<InputChannel>(), args["enabled"].value<bool>(), [this, mid](TG_CALLBACK_SIGNATURE(UpdatesType)){ Q_UNUSED(msgId); callBackCall<UpdatesType>(mid, result, error); } );
    } else if(functionName == "channelsCheckUsername") {
        result = channelsCheckUsername(args["channel"].value<InputChannel>(), args["username"].value<QString>(), [this, mid](TG_CALLBACK_SIGNATURE(bool)){ Q_UNUSED(msgId); callBackCall<bool>(mid, result, error); } );
    } else if(functionName == "channelsUpdateUsername") {
        result = channelsUpdateUsername(args["channel"].value<InputChannel>(), args["username"].value<QString>(), [this, mid](TG_CALLBACK_SIGNATURE(bool)){ Q_UNUSED(msgId); callBackCall<bool>(mid, result, error); } );
    } else if(functionName == "channelsJoinChannel") {
        result = channelsJoinChannel(args["channel"].value<InputChannel>(), [this, mid](TG_CALLBACK_SIGNATURE(UpdatesType)){ Q_UNUSED(msgId); callBackCall<UpdatesType>(mid, result, error); } );
    } else if(functionName == "channelsLeaveChannel") {
        result = channelsLeaveChannel(args["channel"].value<InputChannel>(), [this, mid](TG_CALLBACK_SIGNATURE(UpdatesType)){ Q_UNUSED(msgId); callBackCall<UpdatesType>(mid, result, error); } );
    } else if(functionName == "channelsInviteToChannel") {
        result = channelsInviteToChannel(args["channel"].value<InputChannel>(), args["users"].value<QList<InputUser>>(), [this, mid](TG_CALLBACK_SIGNATURE(UpdatesType)){ Q_UNUSED(msgId); callBackCall<UpdatesType>(mid, result, error); } );
    } else if(functionName == "channelsKickFromChannel") {
        result = channelsKickFromChannel(args["channel"].value<InputChannel>(), args["user_id"].value<InputUser>(), args["kicked"].value<bool>(), [this, mid](TG_CALLBACK_SIGNATURE(UpdatesType)){ Q_UNUSED(msgId); callBackCall<UpdatesType>(mid, result, error); } );
    } else if(functionName == "channelsExportInvite") {
        result = channelsExportInvite(args["channel"].value<InputChannel>(), [this, mid](TG_CALLBACK_SIGNATURE(ExportedChatInvite)){ Q_UNUSED(msgId); callBackCall<ExportedChatInvite>(mid, result, error); } );
    } else if(functionName == "channelsDeleteChannel") {
        result = channelsDeleteChannel(args["channel"].value<InputChannel>(), [this, mid](TG_CALLBACK_SIGNATURE(UpdatesType)){ Q_UNUSED(msgId); callBackCall<UpdatesType>(mid, result, error); } );
    } else if(functionName == "contactsGetStatuses") {
        result = contactsGetStatuses([this, mid](TG_CALLBACK_SIGNATURE(QList<ContactStatus>)){ Q_UNUSED(msgId); callBackCall<QList<ContactStatus>>(mid, result, error); } );
    } else if(functionName == "contactsGetContacts") {
        result = contactsGetContacts(args["hash"].value<QString>(), [this, mid](TG_CALLBACK_SIGNATURE(ContactsContacts)){ Q_UNUSED(msgId); callBackCall<ContactsContacts>(mid, result, error); } );
    } else if(functionName == "contactsImportContacts") {
        result = contactsImportContacts(args["contacts"].value<QList<InputContact>>(), args["replace"].value<bool>(), [this, mid](TG_CALLBACK_SIGNATURE(ContactsImportedContacts)){ Q_UNUSED(msgId); callBackCall<ContactsImportedContacts>(mid, result, error); } );
    } else if(functionName == "contactsGetSuggested") {
        result = contactsGetSuggested(args["limit"].value<qint32>(), [this, mid](TG_CALLBACK_SIGNATURE(ContactsSuggested)){ Q_UNUSED(msgId); callBackCall<ContactsSuggested>(mid, result, error); } );
    } else if(functionName == "contactsDeleteContact") {
        result = contactsDeleteContact(args["id"].value<InputUser>(), [this, mid](TG_CALLBACK_SIGNATURE(ContactsLink)){ Q_UNUSED(msgId); callBackCall<ContactsLink>(mid, result, error); } );
    } else if(functionName == "contactsDeleteContacts") {
        result = contactsDeleteContacts(args["id"].value<QList<InputUser>>(), [this, mid](TG_CALLBACK_SIGNATURE(bool)){ Q_UNUSED(msgId); callBackCall<bool>(mid, result, error); } );
    } else if(functionName == "contactsBlock") {
        result = contactsBlock(args["id"].value<InputUser>(), [this, mid](TG_CALLBACK_SIGNATURE(bool)){ Q_UNUSED(msgId); callBackCall<bool>(mid, result, error); } );
    } else if(functionName == "contactsUnblock") {
        result = contactsUnblock(args["id"].value<InputUser>(), [this, mid](TG_CALLBACK_SIGNATURE(bool)){ Q_UNUSED(msgId); callBackCall<bool>(mid, result, error); } );
    } else if(functionName == "contactsGetBlocked") {
        result = contactsGetBlocked(args["offset"].value<qint32>(), args["limit"].value<qint32>(), [this, mid](TG_CALLBACK_SIGNATURE(ContactsBlocked)){ Q_UNUSED(msgId); callBackCall<ContactsBlocked>(mid, result, error); } );
    } else if(functionName == "contactsExportCard") {
        result = contactsExportCard([this, mid](TG_CALLBACK_SIGNATURE(QList<qint32>)){ Q_UNUSED(msgId); callBackCall<QList<qint32>>(mid, result, error); } );
    } else if(functionName == "contactsImportCard") {
        result = contactsImportCard(args["export_card"].value<QList<qint32>>(), [this, mid](TG_CALLBACK_SIGNATURE(User)){ Q_UNUSED(msgId); callBackCall<User>(mid, result, error); } );
    } else if(functionName == "contactsSearch") {
        result = contactsSearch(args["q"].value<QString>(), args["limit"].value<qint32>(), [this, mid](TG_CALLBACK_SIGNATURE(ContactsFound)){ Q_UNUSED(msgId); callBackCall<ContactsFound>(mid, result, error); } );
    } else if(functionName == "contactsResolveUsername") {
        result = contactsResolveUsername(args["username"].value<QString>(), [this, mid](TG_CALLBACK_SIGNATURE(ContactsResolvedPeer)){ Q_UNUSED(msgId); callBackCall<ContactsResolvedPeer>(mid, result, error); } );
    } else if(functionName == "helpGetConfig") {
        result = helpGetConfig([this, mid](TG_CALLBACK_SIGNATURE(Config)){ Q_UNUSED(msgId); callBackCall<Config>(mid, result, error); } );
    } else if(functionName == "helpGetNearestDc") {
        result = helpGetNearestDc([this, mid](TG_CALLBACK_SIGNATURE(NearestDc)){ Q_UNUSED(msgId); callBackCall<NearestDc>(mid, result, error); } );
    } else if(functionName == "helpGetAppUpdate") {
        result = helpGetAppUpdate(args["device_model"].value<QString>(), args["system_version"].value<QString>(), args["app_version"].value<QString>(), args["lang_code"].value<QString>(), [this, mid](TG_CALLBACK_SIGNATURE(HelpAppUpdate)){ Q_UNUSED(msgId); callBackCall<HelpAppUpdate>(mid, result, error); } );
    } else if(functionName == "helpSaveAppLog") {
        result = helpSaveAppLog(args["events"].value<QList<InputAppEvent>>(), [this, mid](TG_CALLBACK_SIGNATURE(bool)){ Q_UNUSED(msgId); callBackCall<bool>(mid, result, error); } );
    } else if(functionName == "helpGetInviteText") {
        result = helpGetInviteText(args["lang_code"].value<QString>(), [this, mid](TG_CALLBACK_SIGNATURE(HelpInviteText)){ Q_UNUSED(msgId); callBackCall<HelpInviteText>(mid, result, error); } );
    } else if(functionName == "helpGetSupport") {
        result = helpGetSupport([this, mid](TG_CALLBACK_SIGNATURE(HelpSupport)){ Q_UNUSED(msgId); callBackCall<HelpSupport>(mid, result, error); } );
    } else if(functionName == "helpGetAppChangelog") {
        result = helpGetAppChangelog(args["device_model"].value<QString>(), args["system_version"].value<QString>(), args["app_version"].value<QString>(), args["lang_code"].value<QString>(), [this, mid](TG_CALLBACK_SIGNATURE(HelpAppChangelog)){ Q_UNUSED(msgId); callBackCall<HelpAppChangelog>(mid, result, error); } );
    } else if(functionName == "helpGetTermsOfService") {
        result = helpGetTermsOfService(args["lang_code"].value<QString>(), [this, mid](TG_CALLBACK_SIGNATURE(HelpTermsOfService)){ Q_UNUSED(msgId); callBackCall<HelpTermsOfService>(mid, result, error); } );
    } else if(functionName == "messagesGetMessages") {
        result = messagesGetMessages(args["id"].value<QList<qint32>>(), [this, mid](TG_CALLBACK_SIGNATURE(MessagesMessages)){ Q_UNUSED(msgId); callBackCall<MessagesMessages>(mid, result, error); } );
    } else if(functionName == "messagesGetDialogs") {
        result = messagesGetDialogs(args["offset_date"].value<qint32>(), args["offset_id"].value<qint32>(), args["offset_peer"].value<InputPeer>(), args["limit"].value<qint32>(), [this, mid](TG_CALLBACK_SIGNATURE(MessagesDialogs)){ Q_UNUSED(msgId); callBackCall<MessagesDialogs>(mid, result, error); } );
    } else if(functionName == "messagesGetHistory") {
        result = messagesGetHistory(args["peer"].value<InputPeer>(), args["offset_id"].value<qint32>(), args["add_offset"].value<qint32>(), args["limit"].value<qint32>(), args["max_id"].value<qint32>(), args["min_id"].value<qint32>(), [this, mid](TG_CALLBACK_SIGNATURE(MessagesMessages)){ Q_UNUSED(msgId); callBackCall<MessagesMessages>(mid, result, error); } );
    } else if(functionName == "messagesSearch") {
        result = messagesSearch(args["important_only"].value<bool>(), args["peer"].value<InputPeer>(), args["q"].value<QString>(), args["filter"].value<MessagesFilter>(), args["min_date"].value<qint32>(), args["max_date"].value<qint32>(), args["offset"].value<qint32>(), args["max_id"].value<qint32>(), args["limit"].value<qint32>(), [this, mid](TG_CALLBACK_SIGNATURE(MessagesMessages)){ Q_UNUSED(msgId); callBackCall<MessagesMessages>(mid, result, error); } );
    } else if(functionName == "messagesReadHistory") {
        result = messagesReadHistory(args["peer"].value<InputPeer>(), args["max_id"].value<qint32>(), [this, mid](TG_CALLBACK_SIGNATURE(MessagesAffectedMessages)){ Q_UNUSED(msgId); callBackCall<MessagesAffectedMessages>(mid, result, error); } );
    } else if(functionName == "messagesDeleteHistory") {
        result = messagesDeleteHistory(args["peer"].value<InputPeer>(), args["max_id"].value<qint32>(), [this, mid](TG_CALLBACK_SIGNATURE(MessagesAffectedHistory)){ Q_UNUSED(msgId); callBackCall<MessagesAffectedHistory>(mid, result, error); } );
    } else if(functionName == "messagesDeleteMessages") {
        result = messagesDeleteMessages(args["id"].value<QList<qint32>>(), [this, mid](TG_CALLBACK_SIGNATURE(MessagesAffectedMessages)){ Q_UNUSED(msgId); callBackCall<MessagesAffectedMessages>(mid, result, error); } );
    } else if(functionName == "messagesReceivedMessages") {
        result = messagesReceivedMessages(args["max_id"].value<qint32>(), [this, mid](TG_CALLBACK_SIGNATURE(QList<ReceivedNotifyMessage>)){ Q_UNUSED(msgId); callBackCall<QList<ReceivedNotifyMessage>>(mid, result, error); } );
    } else if(functionName == "messagesSetTyping") {
        result = messagesSetTyping(args["peer"].value<InputPeer>(), args["action"].value<SendMessageAction>(), [this, mid](TG_CALLBACK_SIGNATURE(bool)){ Q_UNUSED(msgId); callBackCall<bool>(mid, result, error); } );
    } else if(functionName == "messagesSendMessage") {
        result = messagesSendMessage(args["no_webpage"].value<bool>(), args["broadcast"].value<bool>(), args["peer"].value<InputPeer>(), args["reply_to_msg_id"].value<qint32>(), args["message"].value<QString>(), args["random_id"].value<qint64>(), args["reply_markup"].value<ReplyMarkup>(), args["entities"].value<QList<MessageEntity>>(), [this, mid](TG_CALLBACK_SIGNATURE(UpdatesType)){ Q_UNUSED(msgId); callBackCall<UpdatesType>(mid, result, error); } );
    } else if(functionName == "messagesSendMedia") {
        result = messagesSendMedia(args["broadcast"].value<bool>(), args["peer"].value<InputPeer>(), args["reply_to_msg_id"].value<qint32>(), args["media"].value<InputMedia>(), args["random_id"].value<qint64>(), args["reply_markup"].value<ReplyMarkup>(), [this, mid](TG_CALLBACK_SIGNATURE(UpdatesType)){ Q_UNUSED(msgId); callBackCall<UpdatesType>(mid, result, error); } );
    } else if(functionName == "messagesForwardMessages") {
        result = messagesForwardMessages(args["broadcast"].value<bool>(), args["from_peer"].value<InputPeer>(), args["id"].value<QList<qint32>>(), args["random_id"].value<QList<qint64>>(), args["to_peer"].value<InputPeer>(), [this, mid](TG_CALLBACK_SIGNATURE(UpdatesType)){ Q_UNUSED(msgId); callBackCall<UpdatesType>(mid, result, error); } );
    } else if(functionName == "messagesReportSpam") {
        result = messagesReportSpam(args["peer"].value<InputPeer>(), [this, mid](TG_CALLBACK_SIGNATURE(bool)){ Q_UNUSED(msgId); callBackCall<bool>(mid, result, error); } );
    } else if(functionName == "messagesGetChats") {
        result = messagesGetChats(args["id"].value<QList<qint32>>(), [this, mid](TG_CALLBACK_SIGNATURE(MessagesChats)){ Q_UNUSED(msgId); callBackCall<MessagesChats>(mid, result, error); } );
    } else if(functionName == "messagesGetFullChat") {
        result = messagesGetFullChat(args["chat_id"].value<qint32>(), [this, mid](TG_CALLBACK_SIGNATURE(MessagesChatFull)){ Q_UNUSED(msgId); callBackCall<MessagesChatFull>(mid, result, error); } );
    } else if(functionName == "messagesEditChatTitle") {
        result = messagesEditChatTitle(args["chat_id"].value<qint32>(), args["title"].value<QString>(), [this, mid](TG_CALLBACK_SIGNATURE(UpdatesType)){ Q_UNUSED(msgId); callBackCall<UpdatesType>(mid, result, error); } );
    } else if(functionName == "messagesEditChatPhoto") {
        result = messagesEditChatPhoto(args["chat_id"].value<qint32>(), args["photo"].value<InputChatPhoto>(), [this, mid](TG_CALLBACK_SIGNATURE(UpdatesType)){ Q_UNUSED(msgId); callBackCall<UpdatesType>(mid, result, error); } );
    } else if(functionName == "messagesAddChatUser") {
        result = messagesAddChatUser(args["chat_id"].value<qint32>(), args["user_id"].value<InputUser>(), args["fwd_limit"].value<qint32>(), [this, mid](TG_CALLBACK_SIGNATURE(UpdatesType)){ Q_UNUSED(msgId); callBackCall<UpdatesType>(mid, result, error); } );
    } else if(functionName == "messagesDeleteChatUser") {
        result = messagesDeleteChatUser(args["chat_id"].value<qint32>(), args["user_id"].value<InputUser>(), [this, mid](TG_CALLBACK_SIGNATURE(UpdatesType)){ Q_UNUSED(msgId); callBackCall<UpdatesType>(mid, result, error); } );
    } else if(functionName == "messagesCreateChat") {
        result = messagesCreateChat(args["users"].value<QList<InputUser>>(), args["title"].value<QString>(), [this, mid](TG_CALLBACK_SIGNATURE(UpdatesType)){ Q_UNUSED(msgId); callBackCall<UpdatesType>(mid, result, error); } );
    } else if(functionName == "messagesForwardMessage") {
        result = messagesForwardMessage(args["peer"].value<InputPeer>(), args["id"].value<qint32>(), args["random_id"].value<qint64>(), [this, mid](TG_CALLBACK_SIGNATURE(UpdatesType)){ Q_UNUSED(msgId); callBackCall<UpdatesType>(mid, result, error); } );
    } else if(functionName == "messagesSendBroadcast") {
        result = messagesSendBroadcast(args["contacts"].value<QList<InputUser>>(), args["random_id"].value<QList<qint64>>(), args["message"].value<QString>(), args["media"].value<InputMedia>(), [this, mid](TG_CALLBACK_SIGNATURE(UpdatesType)){ Q_UNUSED(msgId); callBackCall<UpdatesType>(mid, result, error); } );
    } else if(functionName == "messagesGetDhConfig") {
        result = messagesGetDhConfig(args["version"].value<qint32>(), args["random_length"].value<qint32>(), [this, mid](TG_CALLBACK_SIGNATURE(MessagesDhConfig)){ Q_UNUSED(msgId); callBackCall<MessagesDhConfig>(mid, result, error); } );
    } else if(functionName == "messagesRequestEncryption") {
        result = messagesRequestEncryption(args["user_id"].value<InputUser>(), args["random_id"].value<qint32>(), args["g_a"].value<QByteArray>(), [this, mid](TG_CALLBACK_SIGNATURE(EncryptedChat)){ Q_UNUSED(msgId); callBackCall<EncryptedChat>(mid, result, error); } );
    } else if(functionName == "messagesAcceptEncryption") {
        result = messagesAcceptEncryption(args["peer"].value<InputEncryptedChat>(), args["g_b"].value<QByteArray>(), args["key_fingerprint"].value<qint64>(), [this, mid](TG_CALLBACK_SIGNATURE(EncryptedChat)){ Q_UNUSED(msgId); callBackCall<EncryptedChat>(mid, result, error); } );
    } else if(functionName == "messagesDiscardEncryption") {
        result = messagesDiscardEncryption(args["chat_id"].value<qint32>(), [this, mid](TG_CALLBACK_SIGNATURE(bool)){ Q_UNUSED(msgId); callBackCall<bool>(mid, result, error); } );
    } else if(functionName == "messagesSetEncryptedTyping") {
        result = messagesSetEncryptedTyping(args["peer"].value<InputEncryptedChat>(), args["typing"].value<bool>(), [this, mid](TG_CALLBACK_SIGNATURE(bool)){ Q_UNUSED(msgId); callBackCall<bool>(mid, result, error); } );
    } else if(functionName == "messagesReadEncryptedHistory") {
        result = messagesReadEncryptedHistory(args["peer"].value<InputEncryptedChat>(), args["max_date"].value<qint32>(), [this, mid](TG_CALLBACK_SIGNATURE(bool)){ Q_UNUSED(msgId); callBackCall<bool>(mid, result, error); } );
    } else if(functionName == "messagesSendEncrypted") {
        result = messagesSendEncrypted(args["peer"].value<InputEncryptedChat>(), args["random_id"].value<qint64>(), args["data"].value<QByteArray>(), [this, mid](TG_CALLBACK_SIGNATURE(MessagesSentEncryptedMessage)){ Q_UNUSED(msgId); callBackCall<MessagesSentEncryptedMessage>(mid, result, error); } );
    } else if(functionName == "messagesSendEncryptedFile") {
        result = messagesSendEncryptedFile(args["peer"].value<InputEncryptedChat>(), args["random_id"].value<qint64>(), args["data"].value<QByteArray>(), args["file"].value<InputEncryptedFile>(), [this, mid](TG_CALLBACK_SIGNATURE(MessagesSentEncryptedMessage)){ Q_UNUSED(msgId); callBackCall<MessagesSentEncryptedMessage>(mid, result, error); } );
    } else if(functionName == "messagesSendEncryptedService") {
        result = messagesSendEncryptedService(args["peer"].value<InputEncryptedChat>(), args["random_id"].value<qint64>(), args["data"].value<QByteArray>(), [this, mid](TG_CALLBACK_SIGNATURE(MessagesSentEncryptedMessage)){ Q_UNUSED(msgId); callBackCall<MessagesSentEncryptedMessage>(mid, result, error); } );
    } else if(functionName == "messagesReceivedQueue") {
        result = messagesReceivedQueue(args["max_qts"].value<qint32>(), [this, mid](TG_CALLBACK_SIGNATURE(QList<qint64>)){ Q_UNUSED(msgId); callBackCall<QList<qint64>>(mid, result, error); } );
    } else if(functionName == "messagesReadMessageContents") {
        result = messagesReadMessageContents(args["id"].value<QList<qint32>>(), [this, mid](TG_CALLBACK_SIGNATURE(MessagesAffectedMessages)){ Q_UNUSED(msgId); callBackCall<MessagesAffectedMessages>(mid, result, error); } );
    } else if(functionName == "messagesGetStickers") {
        result = messagesGetStickers(args["emoticon"].value<QString>(), args["hash"].value<QString>(), [this, mid](TG_CALLBACK_SIGNATURE(MessagesStickers)){ Q_UNUSED(msgId); callBackCall<MessagesStickers>(mid, result, error); } );
    } else if(functionName == "messagesGetAllStickers") {
        result = messagesGetAllStickers(args["hash"].value<qint32>(), [this, mid](TG_CALLBACK_SIGNATURE(MessagesAllStickers)){ Q_UNUSED(msgId); callBackCall<MessagesAllStickers>(mid, result, error); } );
    } else if(functionName == "messagesGetWebPagePreview") {
        result = messagesGetWebPagePreview(args["message"].value<QString>(), [this, mid](TG_CALLBACK_SIGNATURE(MessageMedia)){ Q_UNUSED(msgId); callBackCall<MessageMedia>(mid, result, error); } );
    } else if(functionName == "messagesExportChatInvite") {
        result = messagesExportChatInvite(args["chat_id"].value<qint32>(), [this, mid](TG_CALLBACK_SIGNATURE(ExportedChatInvite)){ Q_UNUSED(msgId); callBackCall<ExportedChatInvite>(mid, result, error); } );
    } else if(functionName == "messagesCheckChatInvite") {
        result = messagesCheckChatInvite(args["hash"].value<QString>(), [this, mid](TG_CALLBACK_SIGNATURE(ChatInvite)){ Q_UNUSED(msgId); callBackCall<ChatInvite>(mid, result, error); } );
    } else if(functionName == "messagesImportChatInvite") {
        result = messagesImportChatInvite(args["hash"].value<QString>(), [this, mid](TG_CALLBACK_SIGNATURE(UpdatesType)){ Q_UNUSED(msgId); callBackCall<UpdatesType>(mid, result, error); } );
    } else if(functionName == "messagesGetStickerSet") {
        result = messagesGetStickerSet(args["stickerset"].value<InputStickerSet>(), [this, mid](TG_CALLBACK_SIGNATURE(MessagesStickerSet)){ Q_UNUSED(msgId); callBackCall<MessagesStickerSet>(mid, result, error); } );
    } else if(functionName == "messagesInstallStickerSet") {
        result = messagesInstallStickerSet(args["stickerset"].value<InputStickerSet>(), args["disabled"].value<bool>(), [this, mid](TG_CALLBACK_SIGNATURE(bool)){ Q_UNUSED(msgId); callBackCall<bool>(mid, result, error); } );
    } else if(functionName == "messagesUninstallStickerSet") {
        result = messagesUninstallStickerSet(args["stickerset"].value<InputStickerSet>(), [this, mid](TG_CALLBACK_SIGNATURE(bool)){ Q_UNUSED(msgId); callBackCall<bool>(mid, result, error); } );
    } else if(functionName == "messagesStartBot") {
        result = messagesStartBot(args["bot"].value<InputUser>(), args["peer"].value<InputPeer>(), args["random_id"].value<qint64>(), args["start_param"].value<QString>(), [this, mid](TG_CALLBACK_SIGNATURE(UpdatesType)){ Q_UNUSED(msgId); callBackCall<UpdatesType>(mid, result, error); } );
    } else if(functionName == "messagesGetMessagesViews") {
        result = messagesGetMessagesViews(args["peer"].value<InputPeer>(), args["id"].value<QList<qint32>>(), args["increment"].value<bool>(), [this, mid](TG_CALLBACK_SIGNATURE(QList<qint32>)){ Q_UNUSED(msgId); callBackCall<QList<qint32>>(mid, result, error); } );
    } else if(functionName == "messagesToggleChatAdmins") {
        result = messagesToggleChatAdmins(args["chat_id"].value<qint32>(), args["enabled"].value<bool>(), [this, mid](TG_CALLBACK_SIGNATURE(UpdatesType)){ Q_UNUSED(msgId); callBackCall<UpdatesType>(mid, result, error); } );
    } else if(functionName == "messagesEditChatAdmin") {
        result = messagesEditChatAdmin(args["chat_id"].value<qint32>(), args["user_id"].value<InputUser>(), args["is_admin"].value<bool>(), [this, mid](TG_CALLBACK_SIGNATURE(bool)){ Q_UNUSED(msgId); callBackCall<bool>(mid, result, error); } );
    } else if(functionName == "messagesMigrateChat") {
        result = messagesMigrateChat(args["chat_id"].value<qint32>(), [this, mid](TG_CALLBACK_SIGNATURE(UpdatesType)){ Q_UNUSED(msgId); callBackCall<UpdatesType>(mid, result, error); } );
    } else if(functionName == "messagesSearchGlobal") {
        result = messagesSearchGlobal(args["q"].value<QString>(), args["offset_date"].value<qint32>(), args["offset_peer"].value<InputPeer>(), args["offset_id"].value<qint32>(), args["limit"].value<qint32>(), [this, mid](TG_CALLBACK_SIGNATURE(MessagesMessages)){ Q_UNUSED(msgId); callBackCall<MessagesMessages>(mid, result, error); } );
    } else if(functionName == "messagesReorderStickerSets") {
        result = messagesReorderStickerSets(args["order"].value<QList<qint64>>(), [this, mid](TG_CALLBACK_SIGNATURE(bool)){ Q_UNUSED(msgId); callBackCall<bool>(mid, result, error); } );
    } else if(functionName == "messagesGetDocumentByHash") {
        result = messagesGetDocumentByHash(args["sha256"].value<QByteArray>(), args["size"].value<qint32>(), args["mime_type"].value<QString>(), [this, mid](TG_CALLBACK_SIGNATURE(Document)){ Q_UNUSED(msgId); callBackCall<Document>(mid, result, error); } );
    } else if(functionName == "messagesSearchGifs") {
        result = messagesSearchGifs(args["q"].value<QString>(), args["offset"].value<qint32>(), [this, mid](TG_CALLBACK_SIGNATURE(MessagesFoundGifs)){ Q_UNUSED(msgId); callBackCall<MessagesFoundGifs>(mid, result, error); } );
    } else if(functionName == "messagesGetSavedGifs") {
        result = messagesGetSavedGifs(args["hash"].value<qint32>(), [this, mid](TG_CALLBACK_SIGNATURE(MessagesSavedGifs)){ Q_UNUSED(msgId); callBackCall<MessagesSavedGifs>(mid, result, error); } );
    } else if(functionName == "messagesSaveGif") {
        result = messagesSaveGif(args["id"].value<InputDocument>(), args["unsave"].value<bool>(), [this, mid](TG_CALLBACK_SIGNATURE(bool)){ Q_UNUSED(msgId); callBackCall<bool>(mid, result, error); } );
    } else if(functionName == "messagesGetInlineBotResults") {
        result = messagesGetInlineBotResults(args["bot"].value<InputUser>(), args["query"].value<QString>(), args["offset"].value<QString>(), [this, mid](TG_CALLBACK_SIGNATURE(MessagesBotResults)){ Q_UNUSED(msgId); callBackCall<MessagesBotResults>(mid, result, error); } );
    } else if(functionName == "messagesSetInlineBotResults") {
        result = messagesSetInlineBotResults(args["gallery"].value<bool>(), args["privateValue"].value<bool>(), args["query_id"].value<qint64>(), args["results"].value<QList<InputBotInlineResult>>(), args["cache_time"].value<qint32>(), args["next_offset"].value<QString>(), [this, mid](TG_CALLBACK_SIGNATURE(bool)){ Q_UNUSED(msgId); callBackCall<bool>(mid, result, error); } );
    } else if(functionName == "messagesSendInlineBotResult") {
        result = messagesSendInlineBotResult(args["broadcast"].value<bool>(), args["peer"].value<InputPeer>(), args["reply_to_msg_id"].value<qint32>(), args["random_id"].value<qint64>(), args["query_id"].value<qint64>(), args["id"].value<QString>(), [this, mid](TG_CALLBACK_SIGNATURE(UpdatesType)){ Q_UNUSED(msgId); callBackCall<UpdatesType>(mid, result, error); } );
    } else if(functionName == "photosUpdateProfilePhoto") {
        result = photosUpdateProfilePhoto(args["id"].value<InputPhoto>(), args["crop"].value<InputPhotoCrop>(), [this, mid](TG_CALLBACK_SIGNATURE(UserProfilePhoto)){ Q_UNUSED(msgId); callBackCall<UserProfilePhoto>(mid, result, error); } );
    } else if(functionName == "photosUploadProfilePhoto") {
        result = photosUploadProfilePhoto(args["file"].value<InputFile>(), args["caption"].value<QString>(), args["geo_point"].value<InputGeoPoint>(), args["crop"].value<InputPhotoCrop>(), [this, mid](TG_CALLBACK_SIGNATURE(PhotosPhoto)){ Q_UNUSED(msgId); callBackCall<PhotosPhoto>(mid, result, error); } );
    } else if(functionName == "photosDeletePhotos") {
        result = photosDeletePhotos(args["id"].value<QList<InputPhoto>>(), [this, mid](TG_CALLBACK_SIGNATURE(QList<qint64>)){ Q_UNUSED(msgId); callBackCall<QList<qint64>>(mid, result, error); } );
    } else if(functionName == "photosGetUserPhotos") {
        result = photosGetUserPhotos(args["user_id"].value<InputUser>(), args["offset"].value<qint32>(), args["max_id"].value<qint64>(), args["limit"].value<qint32>(), [this, mid](TG_CALLBACK_SIGNATURE(PhotosPhotos)){ Q_UNUSED(msgId); callBackCall<PhotosPhotos>(mid, result, error); } );
    } else if(functionName == "updatesGetState") {
        result = updatesGetState([this, mid](TG_CALLBACK_SIGNATURE(UpdatesState)){ Q_UNUSED(msgId); callBackCall<UpdatesState>(mid, result, error); } );
    } else if(functionName == "updatesGetDifference") {
        result = updatesGetDifference(args["pts"].value<qint32>(), args["date"].value<qint32>(), args["qts"].value<qint32>(), [this, mid](TG_CALLBACK_SIGNATURE(UpdatesDifference)){ Q_UNUSED(msgId); callBackCall<UpdatesDifference>(mid, result, error); } );
    } else if(functionName == "updatesGetChannelDifference") {
        result = updatesGetChannelDifference(args["channel"].value<InputChannel>(), args["filter"].value<ChannelMessagesFilter>(), args["pts"].value<qint32>(), args["limit"].value<qint32>(), [this, mid](TG_CALLBACK_SIGNATURE(UpdatesChannelDifference)){ Q_UNUSED(msgId); callBackCall<UpdatesChannelDifference>(mid, result, error); } );
    } else if(functionName == "uploadSaveFilePart") {
        result = uploadSaveFilePart(args["file_id"].value<qint64>(), args["file_part"].value<qint32>(), args["bytes"].value<QByteArray>(), [this, mid](TG_CALLBACK_SIGNATURE(bool)){ Q_UNUSED(msgId); callBackCall<bool>(mid, result, error); } );
    } else if(functionName == "uploadGetFile") {
        result = uploadGetFile(args["location"].value<InputFileLocation>(), args["offset"].value<qint32>(), args["limit"].value<qint32>(), [this, mid](TG_CALLBACK_SIGNATURE(UploadFile)){ Q_UNUSED(msgId); callBackCall<UploadFile>(mid, result, error); } );
    } else if(functionName == "uploadSaveBigFilePart") {
        result = uploadSaveBigFilePart(args["file_id"].value<qint64>(), args["file_part"].value<qint32>(), args["file_total_parts"].value<qint32>(), args["bytes"].value<QByteArray>(), [this, mid](TG_CALLBACK_SIGNATURE(bool)){ Q_UNUSED(msgId); callBackCall<bool>(mid, result, error); } );
    } else if(functionName == "usersGetUsers") {
        result = usersGetUsers(args["id"].value<QList<InputUser>>(), [this, mid](TG_CALLBACK_SIGNATURE(QList<User>)){ Q_UNUSED(msgId); callBackCall<QList<User>>(mid, result, error); } );
    } else if(functionName == "usersGetFullUser") {
        result = usersGetFullUser(args["id"].value<InputUser>(), [this, mid](TG_CALLBACK_SIGNATURE(UserFull)){ Q_UNUSED(msgId); callBackCall<UserFull>(mid, result, error); } );
    } else  {
        return result;
    }

    return result;
}

void TelegramCore::timerEvent(QTimerEvent *e)
{
    const qint64 msgId = mTimer.key(e->timerId());
    if(msgId)
    {
        mTimer.remove(msgId);
        killTimer(e->timerId());
        qDebug() << "Timed out. Retrying msgId=" << msgId;
        retry(msgId);
    }

    QObject::timerEvent(e);
}

TelegramCore::~TelegramCore()
{
    QHashIterator<qint64, void*> i(mCallbacks);
    while(i.hasNext())
    {
        i.next();
        Callback<int> *ptr = reinterpret_cast<Callback<int>*>(i.value());
        delete ptr;
    }
    mCallbacks.clear();
}

